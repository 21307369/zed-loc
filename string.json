{
  "zed/crates/activity_indicator/src/activity_indicator.rs": {
    "Language server error: {}\\n\\n{}": "",
    " ({}%)": "",
    ": ": "",
    " + {} more": "",
    "arrow-circle": "",
    "Debug: {}": "",
    "Downloading {}...": "",
    ", ": "",
    "Checking for updates to {}...": "",
    "Failed to run {}. Click to show error.": "",
    "Formatting failed: {}. Click to see logs.": "",
    "Checking for Zed updates…": "",
    "Downloading Zed update…": "",
    "Installing Zed update…": "",
    "Click to restart and update Zed": "",
    "Auto update failed": "",
    "Updating {extension_id} extension…": "",
    "Version: {}": "",
    "{}…": "",
    "activity-indicator": "",
    "activity-indicator-popover": "",
    "activity-indicator-trigger": "",
    "activity-indicator-status": "",
    "Version: 1.0.0": "",
    "14d9a4189f058d8736339b06ff2340101eaea5af": "",
    "Version: 14d9a41…": ""
  },
  "zed/crates/agent/src/agent_panel.rs": {
    "agent_panel": "",
    "View All": "",
    "NavigationMenu": "",
    "No configured model available for continuation": "",
    "Recently Opened": "",
    "Close Entry": "",
    "AgentPanel": "",
    "Agent Panel": "",
    "Loading Summary…": "",
    "retry-summary-generation": "",
    "Failed to generate title": "",
    "Click to try again": "",
    "History": "",
    "Settings": "",
    "TitleEditor": "",
    "go-back": "",
    "Go Back": "",
    "agent-nav-menu": "",
    "Toggle Panel Menu": "",
    "Zoom Out": "",
    "Zoom In": "",
    "agent-options-menu": "",
    "Toggle Agent Menu": "",
    "New Thread": "",
    "New Text Thread": "",
    "New From Summary": "",
    "MCP Servers": "",
    "View Server Extensions": "",
    "Add Custom Server…": "",
    "Prompt Usage": "",
    "Manage": "",
    "usage": "",
    "{} / {limit}": "",
    "{} / ∞": "",
    "Rules…": "",
    "assistant-toolbar": "",
    "new": "",
    "token-count": "",
    "Estimated New Token Count": "",
    "Current Conversation Tokens: {}": "",
    "used-tokens-label": "",
    "/": "",
    "dont-show-again": "",
    "Don't show again": "",
    "Build better with Zed Pro": "",
    "Your GitHub account was created less than 30 days ago, so we can't offer you a free trial.": "",
    "Use your own API keys, upgrade to Zed Pro or send an email to billing-support@zed.dev.": "",
    "dismiss-button": "",
    "Not Now": "",
    "cta-button": "",
    "Upgrade to Zed Pro": "",
    "Try Zed Pro for free for 14 days - no credit card required.": "",
    "Use your own API keys or enable usage-based billing once you hit the cap.": "",
    "Start Trial": "",
    "Your Zed Pro trial has expired.": "",
    "You've been automatically reset to the free plan.": "",
    "Stay on Free": "",
    "Welcome to the Agent Panel": "",
    "Ask and build anything.": "",
    "new-thread": "",
    "Start New Thread": "",
    "context": "",
    "Add Context": "",
    "mode": "",
    "Switch Model": "",
    "settings": "",
    "View Settings": "",
    "To start using the agent, configure at least one LLM provider.": "",
    "Configure a Provider": "",
    "Recent": "",
    "view-history": "",
    "Configure at least one LLM provider to start using the panel.": "",
    "Configure Provider": "",
    "Consecutive tool use limit reached.": "",
    "continue-conversation": "",
    "Continue": "",
    "continue-burn-mode": "",
    "Continue with Burn Mode": "",
    "Enable Burn Mode for unlimited tool use.": "",
    "Free tier exceeded. Subscribe and add payment to continue using Zed LLMs. You'll be billed at cost for tokens used.": "",
    "Free Usage Exceeded": "",
    "error-message": "",
    "subscribe": "",
    "Subscribe": "",
    "dismiss": "",
    "Dismiss": "",
    "Model request limit reached. Upgrade to usage-based billing for more requests.": "",
    "Model request limit reached. Upgrade to Zed Pro for more requests.": "",
    "Upgrade to usage-based billing": "",
    "Model Request Limit Reached": "",
    "{}\\n{}": "",
    "copy": "",
    "Copy Error Message": "",
    "prompt_editor": "",
    "Agent panel not found": "",
    "opening remote context not implemented": "",
    "dismissed-trial-upsell": "",
    "dismissed-trial-end-upsell": ""
  },
  "zed/crates/anthropic/src/anthropic.rs": {
    "https://api.anthropic.com": "",
    "schemars": "",
    "claude-3-5-sonnet": "",
    "claude-3-5-sonnet-latest": "",
    "claude-3-7-sonnet": "",
    "claude-3-7-sonnet-latest": "",
    "claude-3-7-sonnet-thinking": "",
    "claude-3-7-sonnet-thinking-latest": "",
    "claude-opus-4": "",
    "claude-opus-4-latest": "",
    "claude-opus-4-thinking": "",
    "claude-opus-4-thinking-latest": "",
    "claude-sonnet-4": "",
    "claude-sonnet-4-latest": "",
    "claude-sonnet-4-thinking": "",
    "claude-sonnet-4-thinking-latest": "",
    "claude-3-5-haiku": "",
    "claude-3-5-haiku-latest": "",
    "claude-3-opus": "",
    "claude-3-opus-latest": "",
    "claude-3-sonnet": "",
    "claude-3-sonnet-latest": "",
    "claude-3-haiku": "",
    "claude-3-haiku-latest": "",
    "custom": "",
    "invalid model id {id}": "",
    "claude-3-sonnet-20240229": "",
    "claude-3-haiku-20240307": "",
    "claude-opus-4-20250514": "",
    "claude-sonnet-4-20250514": "",
    "Claude Opus 4": "",
    "Claude Opus 4 Thinking": "",
    "Claude Sonnet 4": "",
    "Claude Sonnet 4 Thinking": "",
    "Claude 3.7 Sonnet": "",
    "Claude 3.5 Sonnet": "",
    "Claude 3.7 Sonnet Thinking": "",
    "Claude 3.5 Haiku": "",
    "Claude 3 Opus": "",
    "Claude 3 Sonnet": "",
    "Claude 3 Haiku": "",
    "prompt-caching-2024-07-31": "",
    "token-efficient-tools-2025-02-19": "",
    ",": "",
    "{api_url}/v1/messages": "",
    "Anthropic-Version": "",
    "2023-06-01": "",
    "Anthropic-Beta": "",
    "X-Api-Key": "",
    "Content-Type": "",
    "application/json": "",
    "failed to serialize request": "",
    "failed to construct request body": "",
    "failed to send request to Anthropic": "",
    "failed to read response body": "",
    "failed to deserialize response body": "",
    "failed to parse response body as UTF-8": "",
    "Failed to connect to API: {} {}": "",
    "anthropic-ratelimit-{resource}-limit": "",
    "anthropic-ratelimit-{resource}-remaining": "",
    "anthropic-ratelimit-{resource}-reset": "",
    "retry-after": "",
    "anthropic-ratelimit-": "",
    "requests": "",
    "tokens": "",
    "input-tokens": "",
    "output-tokens": "",
    "missing header `{key}`": "",
    "data: ": "",
    "Unexpected success response while expecting an error: '{body_str}'": "",
    "lowercase": "",
    "type": "",
    "text": "",
    "Option::is_none": "",
    "thinking": "",
    "redacted_thinking": "",
    "image": "",
    "tool_use": "",
    "tool_result": "",
    "Vec::is_empty": "",
    "message_start": "",
    "content_block_start": "",
    "content_block_delta": "",
    "content_block_stop": "",
    "message_delta": "",
    "message_stop": "",
    "ping": "",
    "error": "",
    "text_delta": "",
    "thinking_delta": "",
    "signature_delta": "",
    "input_json_delta": "",
    "rate limit exceeded, retry after {0:?}": "",
    "an error occurred while interacting with the Anthropic API: {error_type}: {message}": "",
    "{0}": "",
    "snake_case": "",
    "rate_limit_error": "",
    "prompt is too long: ": "",
    " tokens": "",
    "invalid_request_error": "",
    "prompt is too long: 220000 tokens > 200000": "",
    "prompt is too long: 1234953 tokens": "",
    "not a prompt length error": "",
    "prompt is too long: 12345 tokens": "",
    "prompt is too long: invalid tokens": ""
  },
  "zed/crates/assets/src/assets.rs": {
    "../../assets": "",
    "fonts/**/*": "",
    "icons/**/*": "",
    "images/**/*": "",
    "themes/**/*": "",
    "themes/src/*": "",
    "sounds/**/*": "",
    "prompts/**/*": "",
    "*.md": "",
    "*.DS_Store": "",
    "loading asset at path {path:?}": "",
    "fonts": "",
    ".ttf": "",
    "Assets should never return None": "",
    "fonts/plex-mono/ZedPlexMono-Regular.ttf": ""
  },
  "zed/crates/assistant_context_editor/src/context_editor.rs": {
    "New Chat": "",
    "/{command_name}\\n\\n": "",
    "/{name}": "",
    " ": "",
    "invoked-slash-command": "",
    "Thinking Process": "",
    "Press": "",
    "esc": "",
    "to cancel": "",
    "You": "",
    "Agent": "",
    "pulsating-label": "",
    "arrow-circle": "",
    "System": "",
    "role": "",
    "Toggle message role": "",
    "Available roles: You (User), Agent, System": "",
    "message_header": "",
    "cached": "",
    "Context Cached": "",
    "Large messages cached to optimize performance": "",
    "show-error": "",
    "Error": "",
    "View Details": "",
    "Canceled": "",
    "old_blocks should contain a message_id we've just removed.": "",
    "```": "",
    "{} copied to clipboard.": "",
    "Code block": "",
    "Selection": "",
    "\\n": "",
    "/{} {}": "",
    "": "",
    "Zed AI is here! Get started by signing in →": "",
    "sign-in": "",
    "Sign in": "",
    "Authentication timeout": "",
    "Connection reset": "",
    "No LLM provider selected.": "",
    "LLM provider is not configured.": "",
    "LLM provider requires accepting the Terms of Service.": "",
    "open-configuration": "",
    "Configure Providers": "",
    "Token limit reached": "",
    "Token limit is close to exhaustion": "",
    "send_button": "",
    "Send": "",
    "trigger": "",
    "Add Context": "",
    "Type / to insert via keyboard": "",
    "burn-mode": "",
    "No model selected": "",
    "active-model": "",
    "Change Model": "",
    "Free tier exceeded. Subscribe and add payment to continue using Zed LLMs. You'll be billed at cost for tokens used.": "",
    "Free Usage Exceeded": "",
    "error-message": "",
    "subscribe": "",
    "Subscribe": "",
    "dismiss": "",
    "Dismiss": "",
    "Error interacting with language model": "",
    "fenced_code_block": "",
    "code_fence_content": "",
    "Thinking…": "",
    "Thought Process": "",
    "slash-command-output-fold-indicator": "",
    "quote-selection-indicator": "",
    "slash-command-gutter-decoration": "",
    "crates-being-indexed": "",
    "Indexing {package}…": "",
    "latest-error": "",
    "Failed to index: {latest_error}": "",
    "ContextEditor": "",
    "Token Limit Reached": "",
    "Token Limit is Close to Exhaustion": "",
    "token-count": "",
    "/": "",
    "chat-title-group": "",
    "regenerate-context": "",
    "Regenerate Title": "",
    "Files to scan: {}": "",
    "/{}": "",
    "error: {message}": "",
    "{}k": "",
    "{}.{}k": "",
    "{}M": "",
    "{}.{}M": "",
    "What is the Zed editor?": "",
    "Zed is a modern, high-performance code editor designed from the ground up for speed and collaboration.": "",
    "\n                What is the Zed editor?\n                Zed is a modern, high-performance code editor designed from the ground up for speed and collaboration.\n                What is the Zed editor?\n            ": "",
    "\n                What is the Zed editor?\n                Zed is a modern, high-performance code editor designed from the ground up for speed and collaboration.\n                What is the Zed editor?\n                Zed is a modern, high-performance code editor designed from the ground up for speed and collaboration.\n            ": "",
    "user1": "",
    "assistant1": "",
    "assistant2": "",
    "\n                user1\n                assistant1\n                assistant2\n                assistant1\n            ": "",
    "\n                user1\n                assistant1\n                assistant2\n                assistant1\n                assistant2\n            ": "",
    "markdown": "",
    "\n                line 0\n                line 1\n                ```rust\n                fn main() {}\n                ```\n                line 5\n                line 6\n                line 7\n                ```go\n                func main() {}\n                ```\n                line 11\n                ```\n                this is plain text code block\n                ```\n\n                ```go\n                func another() {}\n                ```\n                line 19\n            ": "",
    "unexpected result on row {:?}": "",
    "/test": ""
  },
  "zed/crates/assistant_slash_commands/src/diagnostics_command.rs": {
    "diagnostics": "",
    "Insert diagnostics": "",
    "workspace was dropped": "",
    "{}{}": "",
    "No diagnostics found": "",
    "--include-warnings": "",
    "diagnostics: {}": "",
    "{file_path}": "",
    "Diagnostics": "",
    " ({})": "",
    " {} errors": "",
    ",": "",
    " {} warnings": "",
    "warning": "",
    "error": "",
    "```": "",
    "{}": "",
    "//": "",
    " {}: ": "",
    "\\n//{:padding$}": "",
    "": "",
    "{message}": ""
  },
  "zed/crates/assistant_tools/src/now_tool.rs": {
    "snake_case": "",
    "now": "",
    "Returns the current datetime in RFC 3339 format. Only use this tool when the user specifically asks for it or the current task would benefit from knowing the current datetime.": "",
    "Get current time": "",
    "The current datetime is {now}.": ""
  },
  "zed/crates/audio/src/assets.rs": {
    "sounds/{}.wav": "",
    "No asset available for path {path}": ""
  },
  "zed/crates/auto_update/src/auto_update.rs": {
    "auto-updater-should-show-updated-notification": "",
    "hdiutil": "",
    "detach": "",
    "-force": "",
    "Successfully unmounted the disk image": "",
    "Failed to unmount disk image: {:?}": "",
    "Error while trying to unmount disk image: {:?}": "",
    "auto_update": "",
    "update.mode": "",
    "none": "",
    "manual": "",
    "ZED_UPDATE_EXPLANATION": "",
    "Zed was installed via a package manager.": "",
    "Ok": "",
    "Could not check for updates": "",
    "Auto-updates disabled for non-bundled app.": "",
    "/releases/{release_channel}/{current_version}": "",
    "https://github.com/zed-industries/zed/commits/nightly/": "",
    "https://github.com/zed-industries/zed/commits/main/": "",
    "windows": "",
    "zed-auto-update": "",
    "No parent dir for Zed.exe": "",
    "updates": "",
    "auto-update failed: error:{:?}": "",
    "auto-update not initialized": "",
    "zed-remote-server": "",
    "{}-{}": "",
    "{}.gz": "",
    "downloading zed-remote-server {os} {arch} version {}": "",
    "stable": "",
    "/api/releases/{channel}/{version}/{asset}-{os}-{arch}.gz?update=1": "",
    "/api/releases/latest?asset={}&os={}&arch={}": "",
    "&": "",
    "failed to fetch release: {:?}": "",
    "error deserializing release {:?}": "",
    "zed": "",
    "macos": "",
    "Zed.dmg": "",
    "linux": "",
    "zed.tar.gz": "",
    "ZedUpdateInstaller.exe": "",
    "not supported: {unsupported_os}": "",
    "rsync": "",
    "Aborting. Could not find rsync which is required for auto-updates.": "",
    "": "",
    "failed to download remote server release: {:?}": "",
    "remote": "",
    "local": "",
    "downloaded update. path:{:?}": "",
    "HOME": "",
    "no HOME env var set": "",
    "failed to create directory into which to extract update": "",
    "tar": "",
    "-xzf": "",
    "-C": "",
    "failed to extract {:?} to {:?}: {:?}": "",
    "-{}": "",
    "zed{}.app": "",
    ".local": "",
    "{}/libexec/zed-editor": "",
    "-av": "",
    "--delete": "",
    "failed to copy Zed update from {:?} to {:?}: {:?}": "",
    "invalid running app path {running_app_path:?}": "",
    "Zed": "",
    "/": "",
    "attach": "",
    "-nobrowse": "",
    "-mountroot": "",
    "failed to mount: {:?}": "",
    "failed to copy app: {:?}": "",
    "/verysilent": "",
    "/update=true": "",
    "!desktopicon": "",
    "!quicklaunchicon": "",
    "failed to start installer: {:?}": "",
    "versions.txt": "",
    "tools\\\\auto_update_helper.exe": "",
    "a": "",
    "b": "",
    "c": ""
  },
  "zed/crates/breadcrumbs/src/breadcrumbs.rs": {
    "breadcrumb-container": "",
    "⋯": "",
    "⏎": "",
    "›": "",
    "toggle outline view": "",
    "Show Symbol Outline": ""
  },
  "zed/crates/channel/src/channel_buffer.rs": {
    "channel buffer {} disconnected": ""
  },
  "zed/crates/channel/src/channel_chat.rs": {
    "message body can't be empty": "",
    "current_user is not present": "",
    "invalid message": "",
    "empty message": "",
    "nonce is required": ""
  },
  "zed/crates/channel/src/channel_store.rs": {
    "{}/channel/{}-{}": "",
    "/notes": "",
    "#{}": "",
    "channel store dropped": "",
    "no channel for id: {channel_id}": "",
    "{error}": "",
    "missing channel in response": "",
    "invite request already in progress": "",
    "member request already in progress": "",
    "test-support": ""
  },
  "zed/crates/cli/src/main.rs": {
    "linux": "",
    "freebsd": "",
    "windows": "",
    "zed": "",
    "The Zed CLI binary.\nThis CLI is a separate binary that invokes Zed.\n\nExamples:\n    `zed`\n          Simply opens Zed\n    `zed --foreground`\n          Runs in foreground (shows all logs)\n    `zed path-to-your-project`\n          Open your project in Zed\n    `zed -n path-to-file `\n          Open file/folder in a new window": "",
    "To read from stdin, append '-', e.g. 'ps axf | zed -'": "",
    "new": "",
    "add": "",
    "DIR": "",
    "macos": "",
    "no-bundled-uninstall": "",
    "retrieving current directory": "",
    "": "",
    "parsing as path with position {argument_str}": "",
    "--": "",
    "Bundle detection": "",
    "{}": "",
    "The `--system-specs` argument is not supported in the Zed CLI, only on Zed binary.": "",
    "To retrieve the system specs on the command line, run the following command:": "",
    "{} --system-specs": "",
    "\\n": "",
    "../../../script/uninstall.sh": "",
    "uninstall.sh": "",
    "sh": "",
    "ZED_CHANNEL": "",
    "Failed to execute uninstall script": "",
    "Handshake before Zed spawn": "",
    "zed-cli://{server_name}": "",
    "zed://": "",
    "http://": "",
    "https://": "",
    "file://": "",
    "ssh://": "",
    "-": "",
    "Dev servers were removed in v0.157.x please upgrade to SSH remoting: https://zed.dev/docs/remote-development": "",
    "Handshake after Zed spawn": "",
    "{message}": "",
    "/proc/self/fd/": "",
    "memfd:": "",
    "/dev/fd/": "",
    "../../zed/RELEASE_CHANNEL": "",
    "no parent path for cli": "",
    "../libexec/zed-editor": "",
    "../lib/zed/zed-editor": "",
    "./zed": "",
    "could not find any of: {}": "",
    ", ": "",
    "Zed {}{}{} – {}": "",
    "stable": "",
    "{} ": "",
    "RELEASE_VERSION": "",
    "ZED_COMMIT_SHA": "",
    " {commit_sha} ": "",
    "zed-{}.sock": "",
    "--user-data-dir": "",
    "failed to setsid: {}": "",
    "failed to close_fd: {}": "",
    "failed to exec {:?}: {}": "",
    "ZED_FLATPAK_LIB_PATH": "",
    "ZED_FLATPAK_NO_ESCAPE": "",
    "LD_LIBRARY_PATH": "",
    "/usr/bin/flatpak-spawn": "",
    "--host": "",
    "--env=ZED_UPDATE_EXPLANATION=Please use flatpak to update zed": "",
    "--env={EXTRA_LIB_ENV_NAME}={}": "",
    "lib": "",
    "bin": "",
    "--zed": "",
    "libexec": "",
    "zed-editor": "",
    "failed restart cli on host: {:?}": "",
    "FLATPAK_ID": "",
    "dev.zed.Zed": "",
    "/app/libexec/zed-editor": "",
    "ZED_UPDATE_EXPLANATION": "",
    "Please use flatpak to update zed": "",
    "flatpak": "",
    "info": "",
    "--show-location": "",
    "files": "",
    "XDG_DATA_HOME": "",
    "XDG_CONFIG_HOME": "",
    "XDG_CACHE_HOME": "",
    "XDG_STATE_HOME": "",
    "--env=FLATPAK_{}={}": "",
    "{}-Instance-Mutex": "",
    "Unable to create instance sync event": "",
    "\\\\\\\\.\\\\pipe\\\\{}-Named-Pipe": "",
    "--foreground": "",
    "../Zed.exe": "",
    "../lib/zed/zed-editor.exe": "",
    "./zed.exe": "",
    "CFBundleShortVersionString": "",
    "app": "",
    "cannot find app bundle containing {cli_path:?}": "",
    "Args bundle path {bundle_path:?} canonicalization": "",
    "bundle autodiscovery": "",
    "Contents/Info.plist": "",
    "Reading *.app bundle plist file at {plist_path:?}": "",
    "Zed {} – {}": "",
    "invalid app path {app_path:?}": "",
    "cannot start app bundle {}": "",
    "Executable {executable:?} path has no parent": "",
    "zed_dev.log": "",
    "Log file creation in {executable_parent:?}": "",
    "Cloning descriptor for file {subprocess_stdout_file:?}": "",
    "Spawning {command:?}": "",
    "Contents/MacOS/zed": "",
    "<development>": "",
    "id of app \\\"{}\\\"": "",
    "osascript": "",
    "-e": "",
    "Could not determine app id for {}": "",
    "kMDItemCFBundleIdentifier == '{app_name}'": "",
    "mdfind": "",
    "Could not determine app path for {}": "",
    "{app_path}/Contents/MacOS/cli": ""
  },
  "zed/crates/client/src/client.rs": {
    "test-support": "",
    "ZED_SERVER_URL": "",
    "ZED_RPC_URL": "",
    "ZED_IMPERSONATE": "",
    "ZED_ADMIN_API_TOKEN": "",
    "ZED_APP_PATH": "",
    "ZED_ALWAYS_ACTIVE": "",
    "http.proxy": "",
    "Initial authentication timed out": "",
    "Initial authentication connection reset": "",
    "upgrade required": "",
    "unauthorized": "",
    "{0}": "",
    "{} {}": "",
    "handling queued rpc message. client_id:{}, sender_id:{:?}, type:{}": "",
    "unhandled message {}": "",
    "telemetry": "",
    "telemetry.telemetryLevel": "",
    "all": "",
    "error": "",
    "crash": "",
    "diagnostics": "",
    "metrics": "",
    "set status on client {}: {:?}": "",
    "client connect attempt timed out": "",
    "client connect attempt reset": "",
    "failed to connect: {error}": "",
    "already subscribed to entity": "",
    "{}:{} registered handler for the same message {} twice": "",
    "client auth and connect": "",
    "authentication canceled": "",
    "add connection to peer": "",
    "waiting for server hello": "",
    "no hello message received": "",
    "got server hello": "",
    "invalid hello message received: {:?}": "",
    "invalid peer id": "",
    "set status to connected (connection id: {:?}, peer id: {:?})": "",
    "connection error: {:?}": "",
    "invalid rpc url": "",
    "/rpc": "",
    "?": "",
    "unexpected /rpc response status {}": "",
    "Location": "",
    "missing location header in /rpc response": "",
    "parsing colab rpc url {collab_url}": "",
    "https": "",
    "http": "",
    "invalid rpc url: {}": "",
    "missing host in rpc url": "",
    "connected to rpc endpoint {}": "",
    "wss": "",
    "ws": "",
    "Authorization": "",
    "x-zed-protocol-version": "",
    "x-zed-app-version": "",
    "x-zed-release-channel": "",
    "unknown": "",
    "x-zed-system-id": "",
    "x-zed-metrics-id": "",
    "failed to generate keypair for auth": "",
    "failed to serialize public key for auth": "",
    "authenticate as admin {login}, {token}": "",
    "127.0.0.1:0": "",
    "failed to find open port": "",
    "/native_app_signin?native_app_port={}&native_app_public_key={}": "",
    "impersonating user @{}": "",
    "&impersonate={}": "",
    "http://example.com{}": "",
    "failed to parse login notification url": "",
    "access_token": "",
    "user_id": "",
    "/native_app_signin_succeeded": "",
    "failed to respond to login http request": "",
    "missing user_id parameter": "",
    "missing access_token parameter": "",
    "didn't receive login redirect": "",
    "failed to decrypt access token": "",
    "https://api.github.com/users/{login}": "",
    "GITHUB_TOKEN": "",
    "Bearer {}": "",
    "error fetching GitHub user": "",
    "error reading GitHub user": "",
    "status error {}, response: {text:?}": "",
    "Error deserializing: {:?}": "",
    "GitHub API response text: {:?}": "",
    "error deserializing GitHub user": "",
    "github_login": "",
    "github_user_id": "",
    "github_user_created_at": "",
    "/user": "",
    "{}={}": "",
    "&": "",
    "token {api_token}": "",
    "": "",
    "admin user request failed {} - {}": "",
    "ADMIN_TOKEN:": "",
    "not connected": "",
    "rpc send. client_id:{}, name:{}": "",
    "rpc request start. client_id:{}. name:{}": "",
    "rpc request finish. client_id:{}. name:{}": "",
    "rpc message received. client_id:{}, sender_id:{:?}, type:{}": "",
    "rpc message handled. client_id:{}, sender_id:{:?}, type:{}": "",
    "error handling message. client_id:{}, sender_id:{:?}, type:{}, error:{:?}": "",
    "rpc respond. client_id:{}, name:{}": "",
    "zed": "",
    "://": "",
    "token": ""
  },
  "zed/crates/client/src/telemetry.rs": {
    "ZED_CLIENT_CHECKSUM_SEED": "",
    "macos": "",
    "macOS": "",
    "linux": "",
    "freebsd": "",
    "Linux {}": "",
    "windows": "",
    "Windows": "",
    "/etc/os-release": "",
    "/usr/lib/os-release": "",
    "Failed to load /etc/os-release, /usr/lib/os-release": "",
    "": "",
    "unknown": "",
    "ID": "",
    "'),\n                Some((": "",
    ", val)) => version = val.trim_matches('": "",
    "{} {}": "",
    "pnpm-lock.yaml": "",
    "pnpm": "",
    "yarn.lock": "",
    "yarn": "",
    "package.json": "",
    "node": "",
    "test-support": "",
    "App Closed": "",
    "telemetry.log": "",
    "Assistant Responded": "",
    "Assistant Invoked": "",
    "Assistant Response Accepted": "",
    "Assistant Response Rejected": "",
    "Editor Edited": "",
    "Project Opened": "",
    "telemetry": "",
    "{:?}": "",
    "/telemetry/events": "",
    "Content-Type": "",
    "application/json": "",
    "x-zed-checksum": "",
    "\\n": "",
    "Failed to send events: HTTP {:?}": "",
    "{:02x}": "",
    "system_id": "",
    "installation_id": "",
    "session_id": "",
    "test_key": "",
    "test_value": "",
    "test": ""
  },
  "zed/crates/client/src/test.rs": {
    "server dropped": "",
    "server is forbidding connections": "",
    "not connected": "",
    "other half hung up": "",
    "failed to build accepted_tos_at": "",
    "the-metrics-id": "",
    "fake server received unexpected message type: {:?}": ""
  },
  "zed/crates/client/src/user.rs": {
    "ZED_IGNORE_ACCEPTED_TOS": "",
    "test-support": "",
    "can't upgrade user store handle": "",
    "can't upgrade client reference": "",
    "user {user_id} not found": "",
    "server responded with no users": "",
    "no current user": "",
    "client not found": "",
    "error accepting tos": "",
    "error loading users": "",
    "invalid peer id": ""
  },
  "zed/crates/clock/src/clock.rs": {
    "Lamport {{{}: {}}}": "",
    "Global {{": "",
    ", ": "",
    "<branch>: {}": "",
    "{}: {}": "",
    "}}": ""
  },
  "zed/crates/command_palette_hooks/src/command_palette_hooks.rs": {
    "::": "",
    "malformed action name": ""
  },
  "zed/crates/collab/src/api/billing.rs": {
    "/billing/preferences": "",
    "/billing/subscriptions": "",
    "/billing/subscriptions/manage": "",
    "/billing/subscriptions/sync": "",
    "/billing/usage": "",
    "user not found": "",
    "Billing Preferences Updated": "",
    "user_id": "",
    "model_request_overages_enabled": "",
    "model_request_overages_spend_limit_in_cents": "",
    "max_monthly_llm_usage_spending_in_cents": "",
    "Zed Pro": "",
    "Zed Pro (Trial)": "",
    "Zed Free": "",
    "Zed LLM Usage": "",
    "snake_case": "",
    "failed to retrieve Stripe billing object": "",
    "not supported": "",
    "user already has an active subscription": "",
    "user has overdue invoices": "",
    "{}/account?checkout_complete=1": "",
    "user already used free trial": "",
    "failed to retrieve Stripe client": "",
    "billing customer not found": "",
    "failed to parse customer ID": "",
    "subscription not found": "",
    "failed to parse subscription ID": "",
    "missing payment method": "",
    "No subscription item to update": "",
    "{}{path}": "",
    "/account": "",
    "free subscription cannot be canceled": "",
    "{}/account": "",
    "failed to sync subscription {subscription_id} for user {}": "",
    "').to_string()\n    }\n\n    let event_types = [\n        EventType::CustomerCreated,\n        EventType::CustomerUpdated,\n        EventType::CustomerSubscriptionCreated,\n        EventType::CustomerSubscriptionUpdated,\n        EventType::CustomerSubscriptionPaused,\n        EventType::CustomerSubscriptionResumed,\n        EventType::CustomerSubscriptionDeleted,\n    ]\n    .into_iter()\n    .map(event_type_to_string)\n    .collect::<Vec<_>>();\n\n    let mut pages_of_already_processed_events = 0;\n    let mut unprocessed_events = Vec::new();\n\n    log::info!(\n        ": "",
    ",\n        event_types.join(": "",
    ")\n    );\n    let mut params = ListEvents::new();\n    params.types = Some(event_types.clone());\n    params.limit = Some(EVENTS_LIMIT_PER_PAGE);\n\n    let mut event_pages = stripe::Event::list(&real_stripe_client, &params)\n        .await?\n        .paginate(params);\n\n    loop {\n        let processed_event_ids = {\n            let event_ids = event_pages\n                .page\n                .data\n                .iter()\n                .map(|event| event.id.as_str())\n                .collect::<Vec<_>>();\n            app.db\n                .get_processed_stripe_events_by_event_ids(&event_ids)\n                .await?\n                .into_iter()\n                .map(|event| event.stripe_event_id)\n                .collect::<Vec<_>>()\n        };\n\n        let mut processed_events_in_page = 0;\n        let events_in_page = event_pages.page.data.len();\n        for event in &event_pages.page.data {\n            if processed_event_ids.contains(&event.id.to_string()) {\n                processed_events_in_page += 1;\n                log::debug!(": "",
    ", event.id);\n            } else {\n                unprocessed_events.push(event.clone());\n            }\n        }\n\n        if processed_events_in_page == events_in_page {\n            pages_of_already_processed_events += 1;\n        }\n\n        if event_pages.page.has_more {\n            if pages_of_already_processed_events >= NUMBER_OF_ALREADY_PROCESSED_PAGES_BEFORE_WE_STOP\n            {\n                log::info!(\n                    ": "",
    "\n                );\n                break;\n            } else {\n                log::info!(": "",
    ");\n                event_pages = event_pages.next(&real_stripe_client).await?;\n            }\n        } else {\n            break;\n        }\n    }\n\n    log::info!(": "",
    ", unprocessed_events.len());\n\n    // Sort all of the unprocessed events in ascending order, so we can handle them in the order they occurred.\n    unprocessed_events.sort_by(|a, b| a.created.cmp(&b.created).then_with(|| a.id.cmp(&b.id)));\n\n    for event in unprocessed_events {\n        let event_id = event.id.clone();\n        let processed_event_params = CreateProcessedStripeEventParams {\n            stripe_event_id: event.id.to_string(),\n            stripe_event_type: event_type_to_string(event.type_),\n            stripe_event_created_timestamp: event.created,\n        };\n\n        // If the event has happened too far in the past, we don't want to\n        // process it and risk overwriting other more-recent updates.\n        //\n        // 1 day was chosen arbitrarily. This could be made longer or shorter.\n        let one_day = Duration::from_secs(24 * 60 * 60);\n        let a_day_ago = Utc::now() - one_day;\n        if a_day_ago.timestamp() > event.created {\n            log::info!(\n                ": "",
    ",\n                event_id\n            );\n            app.db\n                .create_processed_stripe_event(&processed_event_params)\n                .await?;\n\n            continue;\n        }\n\n        let process_result = match event.type_ {\n            EventType::CustomerCreated | EventType::CustomerUpdated => {\n                handle_customer_event(app, real_stripe_client, event).await\n            }\n            EventType::CustomerSubscriptionCreated\n            | EventType::CustomerSubscriptionUpdated\n            | EventType::CustomerSubscriptionPaused\n            | EventType::CustomerSubscriptionResumed\n            | EventType::CustomerSubscriptionDeleted => {\n                handle_customer_subscription_event(app, rpc_server, stripe_client, event).await\n            }\n            _ => Ok(()),\n        };\n\n        if let Some(()) = process_result\n            .with_context(|| format!(": "",
    "))\n            .log_err()\n        {\n            app.db\n                .create_processed_stripe_event(&processed_event_params)\n                .await?;\n        }\n    }\n\n    Ok(())\n}\n\nasync fn handle_customer_event(\n    app: &Arc<AppState>,\n    _stripe_client: &stripe::Client,\n    event: stripe::Event,\n) -> anyhow::Result<()> {\n    let EventObject::Customer(customer) = event.data.object else {\n        bail!(": "",
    ", event.id);\n    };\n\n    log::info!(": "",
    ", event.type_, event.id);\n\n    let Some(email) = customer.email else {\n        log::info!(": "",
    ");\n        return Ok(());\n    };\n\n    let Some(user) = app.db.get_user_by_email(&email).await? else {\n        log::info!(": "",
    ");\n        return Ok(());\n    };\n\n    if let Some(existing_customer) = app\n        .db\n        .get_billing_customer_by_stripe_customer_id(&customer.id)\n        .await?\n    {\n        app.db\n            .update_billing_customer(\n                existing_customer.id,\n                &UpdateBillingCustomerParams {\n                    // For now we just leave the information as-is, as it is not\n                    // likely to change.\n                    ..Default::default()\n                },\n            )\n            .await?;\n    } else {\n        app.db\n            .create_billing_customer(&CreateBillingCustomerParams {\n                user_id: user.id,\n                stripe_customer_id: customer.id.to_string(),\n            })\n            .await?;\n    }\n\n    Ok(())\n}\n\nasync fn sync_subscription(\n    app: &Arc<AppState>,\n    stripe_client: &Arc<dyn StripeClient>,\n    subscription: StripeSubscription,\n) -> anyhow::Result<billing_customer::Model> {\n    let subscription_kind = if let Some(stripe_billing) = &app.stripe_billing {\n        stripe_billing\n            .determine_subscription_kind(&subscription)\n            .await\n    } else {\n        None\n    };\n\n    let billing_customer =\n        find_or_create_billing_customer(app, stripe_client.as_ref(), &subscription.customer)\n            .await?\n            .context(": "",
    ")?;\n\n    if let Some(SubscriptionKind::ZedProTrial) = subscription_kind {\n        if subscription.status == SubscriptionStatus::Trialing {\n            let current_period_start =\n                DateTime::from_timestamp(subscription.current_period_start, 0)\n                    .context(": "",
    ")?;\n\n            app.db\n                .update_billing_customer(\n                    billing_customer.id,\n                    &UpdateBillingCustomerParams {\n                        trial_started_at: ActiveValue::set(Some(current_period_start.naive_utc())),\n                        ..Default::default()\n                    },\n                )\n                .await?;\n        }\n    }\n\n    let was_canceled_due_to_payment_failure = subscription.status == SubscriptionStatus::Canceled\n        && subscription\n            .cancellation_details\n            .as_ref()\n            .and_then(|details| details.reason)\n            .map_or(false, |reason| {\n                reason == StripeCancellationDetailsReason::PaymentFailed\n            });\n\n    if was_canceled_due_to_payment_failure {\n        app.db\n            .update_billing_customer(\n                billing_customer.id,\n                &UpdateBillingCustomerParams {\n                    has_overdue_invoices: ActiveValue::set(true),\n                    ..Default::default()\n                },\n            )\n            .await?;\n    }\n\n    if let Some(existing_subscription) = app\n        .db\n        .get_billing_subscription_by_stripe_subscription_id(subscription.id.0.as_ref())\n        .await?\n    {\n        app.db\n            .update_billing_subscription(\n                existing_subscription.id,\n                &UpdateBillingSubscriptionParams {\n                    billing_customer_id: ActiveValue::set(billing_customer.id),\n                    kind: ActiveValue::set(subscription_kind),\n                    stripe_subscription_id: ActiveValue::set(subscription.id.to_string()),\n                    stripe_subscription_status: ActiveValue::set(subscription.status.into()),\n                    stripe_cancel_at: ActiveValue::set(\n                        subscription\n                            .cancel_at\n                            .and_then(|cancel_at| DateTime::from_timestamp(cancel_at, 0))\n                            .map(|time| time.naive_utc()),\n                    ),\n                    stripe_cancellation_reason: ActiveValue::set(\n                        subscription\n                            .cancellation_details\n                            .and_then(|details| details.reason)\n                            .map(|reason| reason.into()),\n                    ),\n                    stripe_current_period_start: ActiveValue::set(Some(\n                        subscription.current_period_start,\n                    )),\n                    stripe_current_period_end: ActiveValue::set(Some(\n                        subscription.current_period_end,\n                    )),\n                },\n            )\n            .await?;\n    } else {\n        if let Some(existing_subscription) = app\n            .db\n            .get_active_billing_subscription(billing_customer.user_id)\n            .await?\n        {\n            if existing_subscription.kind == Some(SubscriptionKind::ZedFree)\n                && subscription_kind == Some(SubscriptionKind::ZedProTrial)\n            {\n                let stripe_subscription_id = StripeSubscriptionId(\n                    existing_subscription.stripe_subscription_id.clone().into(),\n                );\n\n                stripe_client\n                    .cancel_subscription(&stripe_subscription_id)\n                    .await?;\n            } else {\n                // If the user already has an active billing subscription, ignore the\n                // event and return an `Ok` to signal that it was processed\n                // successfully.\n                //\n                // There is the possibility that this could cause us to not create a\n                // subscription in the following scenario:\n                //\n                //   1. User has an active subscription A\n                //   2. User cancels subscription A\n                //   3. User creates a new subscription B\n                //   4. We process the new subscription B before the cancellation of subscription A\n                //   5. User ends up with no subscriptions\n                //\n                // In theory this situation shouldn't arise as we try to process the events in the order they occur.\n\n                log::info!(\n                    ": "",
    ",\n                    user_id = billing_customer.user_id,\n                    subscription_id = subscription.id\n                );\n                return Ok(billing_customer);\n            }\n        }\n\n        app.db\n            .create_billing_subscription(&CreateBillingSubscriptionParams {\n                billing_customer_id: billing_customer.id,\n                kind: subscription_kind,\n                stripe_subscription_id: subscription.id.to_string(),\n                stripe_subscription_status: subscription.status.into(),\n                stripe_cancellation_reason: subscription\n                    .cancellation_details\n                    .and_then(|details| details.reason)\n                    .map(|reason| reason.into()),\n                stripe_current_period_start: Some(subscription.current_period_start),\n                stripe_current_period_end: Some(subscription.current_period_end),\n            })\n            .await?;\n    }\n\n    if let Some(stripe_billing) = app.stripe_billing.as_ref() {\n        if subscription.status == SubscriptionStatus::Canceled\n            || subscription.status == SubscriptionStatus::Paused\n        {\n            let already_has_active_billing_subscription = app\n                .db\n                .has_active_billing_subscription(billing_customer.user_id)\n                .await?;\n            if !already_has_active_billing_subscription {\n                let stripe_customer_id =\n                    StripeCustomerId(billing_customer.stripe_customer_id.clone().into());\n\n                stripe_billing\n                    .subscribe_to_zed_free(stripe_customer_id)\n                    .await?;\n            }\n        }\n    }\n\n    Ok(billing_customer)\n}\n\nasync fn handle_customer_subscription_event(\n    app: &Arc<AppState>,\n    rpc_server: &Arc<Server>,\n    stripe_client: &Arc<dyn StripeClient>,\n    event: stripe::Event,\n) -> anyhow::Result<()> {\n    let EventObject::Subscription(subscription) = event.data.object else {\n        bail!(": "",
    ", event.type_, event.id);\n\n    let billing_customer = sync_subscription(app, stripe_client, subscription.into()).await?;\n\n    // When the user's subscription changes, push down any changes to their plan.\n    rpc_server\n        .update_plan_for_user(billing_customer.user_id)\n        .await\n        .trace_err();\n\n    // When the user's subscription changes, we want to refresh their LLM tokens\n    // to either grant/revoke access.\n    rpc_server\n        .refresh_llm_tokens_for_user(billing_customer.user_id)\n        .await;\n\n    Ok(())\n}\n\n#[derive(Debug, Deserialize)]\nstruct GetCurrentUsageParams {\n    github_user_id: i32,\n}\n\n#[derive(Debug, Serialize)]\nstruct UsageCounts {\n    pub used: i32,\n    pub limit: Option<i32>,\n    pub remaining: Option<i32>,\n}\n\n#[derive(Debug, Serialize)]\nstruct ModelRequestUsage {\n    pub model: String,\n    pub mode: CompletionMode,\n    pub requests: i32,\n}\n\n#[derive(Debug, Serialize)]\nstruct CurrentUsage {\n    pub model_requests: UsageCounts,\n    pub model_request_usage: Vec<ModelRequestUsage>,\n    pub edit_predictions: UsageCounts,\n}\n\n#[derive(Debug, Default, Serialize)]\nstruct GetCurrentUsageResponse {\n    pub plan: String,\n    pub current_usage: Option<CurrentUsage>,\n}\n\nasync fn get_current_usage(\n    Extension(app): Extension<Arc<AppState>>,\n    Query(params): Query<GetCurrentUsageParams>,\n) -> Result<Json<GetCurrentUsageResponse>> {\n    let user = app\n        .db\n        .get_user_by_github_user_id(params.github_user_id)\n        .await?\n        .context(": "",
    ")?;\n\n    let feature_flags = app.db.get_user_flags(user.id).await?;\n    let has_extended_trial = feature_flags\n        .iter()\n        .any(|flag| flag == AGENT_EXTENDED_TRIAL_FEATURE_FLAG);\n\n    let Some(llm_db) = app.llm_db.clone() else {\n        return Err(Error::http(\n            StatusCode::NOT_IMPLEMENTED,\n            ": "",
    ".into(),\n        ));\n    };\n\n    let Some(subscription) = app.db.get_active_billing_subscription(user.id).await? else {\n        return Ok(Json(GetCurrentUsageResponse::default()));\n    };\n\n    let subscription_period = maybe!({\n        let period_start_at = subscription.current_period_start_at()?;\n        let period_end_at = subscription.current_period_end_at()?;\n\n        Some((period_start_at, period_end_at))\n    });\n\n    let Some((period_start_at, period_end_at)) = subscription_period else {\n        return Ok(Json(GetCurrentUsageResponse::default()));\n    };\n\n    let usage = llm_db\n        .get_subscription_usage_for_period(user.id, period_start_at, period_end_at)\n        .await?;\n\n    let plan = subscription\n        .kind\n        .map(Into::into)\n        .unwrap_or(zed_llm_client::Plan::ZedFree);\n\n    let model_requests_limit = match plan.model_requests_limit() {\n        zed_llm_client::UsageLimit::Limited(limit) => {\n            let limit = if plan == zed_llm_client::Plan::ZedProTrial && has_extended_trial {\n                1_000\n            } else {\n                limit\n            };\n\n            Some(limit)\n        }\n        zed_llm_client::UsageLimit::Unlimited => None,\n    };\n\n    let edit_predictions_limit = match plan.edit_predictions_limit() {\n        zed_llm_client::UsageLimit::Limited(limit) => Some(limit),\n        zed_llm_client::UsageLimit::Unlimited => None,\n    };\n\n    let Some(usage) = usage else {\n        return Ok(Json(GetCurrentUsageResponse {\n            plan: plan.as_str().to_string(),\n            current_usage: Some(CurrentUsage {\n                model_requests: UsageCounts {\n                    used: 0,\n                    limit: model_requests_limit,\n                    remaining: model_requests_limit,\n                },\n                model_request_usage: Vec::new(),\n                edit_predictions: UsageCounts {\n                    used: 0,\n                    limit: edit_predictions_limit,\n                    remaining: edit_predictions_limit,\n                },\n            }),\n        }));\n    };\n\n    let subscription_usage_meters = llm_db\n        .get_current_subscription_usage_meters_for_user(user.id, Utc::now())\n        .await?;\n\n    let model_request_usage = subscription_usage_meters\n        .into_iter()\n        .filter_map(|(usage_meter, _usage)| {\n            let model = llm_db.model_by_id(usage_meter.model_id).ok()?;\n\n            Some(ModelRequestUsage {\n                model: model.name.clone(),\n                mode: usage_meter.mode,\n                requests: usage_meter.requests,\n            })\n        })\n        .collect::<Vec<_>>();\n\n    Ok(Json(GetCurrentUsageResponse {\n        plan: plan.as_str().to_string(),\n        current_usage: Some(CurrentUsage {\n            model_requests: UsageCounts {\n                used: usage.model_requests,\n                limit: model_requests_limit,\n                remaining: model_requests_limit.map(|limit| (limit - usage.model_requests).max(0)),\n            },\n            model_request_usage,\n            edit_predictions: UsageCounts {\n                used: usage.edit_predictions,\n                limit: edit_predictions_limit,\n                remaining: edit_predictions_limit\n                    .map(|limit| (limit - usage.edit_predictions).max(0)),\n            },\n        }),\n    }))\n}\n\nimpl From<SubscriptionStatus> for StripeSubscriptionStatus {\n    fn from(value: SubscriptionStatus) -> Self {\n        match value {\n            SubscriptionStatus::Incomplete => Self::Incomplete,\n            SubscriptionStatus::IncompleteExpired => Self::IncompleteExpired,\n            SubscriptionStatus::Trialing => Self::Trialing,\n            SubscriptionStatus::Active => Self::Active,\n            SubscriptionStatus::PastDue => Self::PastDue,\n            SubscriptionStatus::Canceled => Self::Canceled,\n            SubscriptionStatus::Unpaid => Self::Unpaid,\n            SubscriptionStatus::Paused => Self::Paused,\n        }\n    }\n}\n\nimpl From<CancellationDetailsReason> for StripeCancellationReason {\n    fn from(value: CancellationDetailsReason) -> Self {\n        match value {\n            CancellationDetailsReason::CancellationRequested => Self::CancellationRequested,\n            CancellationDetailsReason::PaymentDisputed => Self::PaymentDisputed,\n            CancellationDetailsReason::PaymentFailed => Self::PaymentFailed,\n        }\n    }\n}\n\n/// Finds or creates a billing customer using the provided customer.\npub async fn find_or_create_billing_customer(\n    app: &Arc<AppState>,\n    stripe_client: &dyn StripeClient,\n    customer_id: &StripeCustomerId,\n) -> anyhow::Result<Option<billing_customer::Model>> {\n    // If we already have a billing customer record associated with the Stripe customer,\n    // there's nothing more we need to do.\n    if let Some(billing_customer) = app\n        .db\n        .get_billing_customer_by_stripe_customer_id(customer_id.0.as_ref())\n        .await?\n    {\n        return Ok(Some(billing_customer));\n    }\n\n    let customer = stripe_client.get_customer(customer_id).await?;\n\n    let Some(email) = customer.email else {\n        return Ok(None);\n    };\n\n    let Some(user) = app.db.get_user_by_email(&email).await? else {\n        return Ok(None);\n    };\n\n    let billing_customer = app\n        .db\n        .create_billing_customer(&CreateBillingCustomerParams {\n            user_id: user.id,\n            stripe_customer_id: customer.id.to_string(),\n        })\n        .await?;\n\n    Ok(Some(billing_customer))\n}\n\nconst SYNC_LLM_REQUEST_USAGE_WITH_STRIPE_INTERVAL: Duration = Duration::from_secs(60);\n\npub fn sync_llm_request_usage_with_stripe_periodically(app: Arc<AppState>) {\n    let Some(stripe_billing) = app.stripe_billing.clone() else {\n        log::warn!(": "",
    ");\n        return;\n    };\n    let Some(llm_db) = app.llm_db.clone() else {\n        log::warn!(": "",
    ");\n        return;\n    };\n\n    let executor = app.executor.clone();\n    executor.spawn_detached({\n        let executor = executor.clone();\n        async move {\n            loop {\n                sync_model_request_usage_with_stripe(&app, &llm_db, &stripe_billing)\n                    .await\n                    .context(": "",
    ")\n                    .trace_err();\n                executor\n                    .sleep(SYNC_LLM_REQUEST_USAGE_WITH_STRIPE_INTERVAL)\n                    .await;\n            }\n        }\n    });\n}\n\nasync fn sync_model_request_usage_with_stripe(\n    app: &Arc<AppState>,\n    llm_db: &Arc<LlmDatabase>,\n    stripe_billing: &Arc<StripeBilling>,\n) -> anyhow::Result<()> {\n    let staff_users = app.db.get_staff_users().await?;\n    let staff_user_ids = staff_users\n        .iter()\n        .map(|user| user.id)\n        .collect::<HashSet<UserId>>();\n\n    let usage_meters = llm_db\n        .get_current_subscription_usage_meters(Utc::now())\n        .await?;\n    let usage_meters = usage_meters\n        .into_iter()\n        .filter(|(_, usage)| !staff_user_ids.contains(&usage.user_id))\n        .collect::<Vec<_>>();\n    let user_ids = usage_meters\n        .iter()\n        .map(|(_, usage)| usage.user_id)\n        .collect::<HashSet<UserId>>();\n    let billing_subscriptions = app\n        .db\n        .get_active_zed_pro_billing_subscriptions(user_ids)\n        .await?;\n\n    let claude_sonnet_4 = stripe_billing\n        .find_price_by_lookup_key(": "",
    ")\n        .await?;\n    let claude_sonnet_4_max = stripe_billing\n        .find_price_by_lookup_key(": "",
    ")\n        .await?;\n    let claude_opus_4 = stripe_billing\n        .find_price_by_lookup_key(": "",
    ")\n        .await?;\n    let claude_opus_4_max = stripe_billing\n        .find_price_by_lookup_key(": "",
    ")\n        .await?;\n    let claude_3_5_sonnet = stripe_billing\n        .find_price_by_lookup_key(": "",
    ")\n        .await?;\n    let claude_3_7_sonnet = stripe_billing\n        .find_price_by_lookup_key(": "",
    ")\n        .await?;\n    let claude_3_7_sonnet_max = stripe_billing\n        .find_price_by_lookup_key(": "",
    ")\n        .await?;\n\n    for (usage_meter, usage) in usage_meters {\n        maybe!(async {\n            let Some((billing_customer, billing_subscription)) =\n                billing_subscriptions.get(&usage.user_id)\n            else {\n                bail!(\n                    ": "",
    ",\n                    usage.user_id\n                );\n            };\n\n            let stripe_customer_id =\n                StripeCustomerId(billing_customer.stripe_customer_id.clone().into());\n            let stripe_subscription_id =\n                StripeSubscriptionId(billing_subscription.stripe_subscription_id.clone().into());\n\n            let model = llm_db.model_by_id(usage_meter.model_id)?;\n\n            let (price, meter_event_name) = match model.name.as_str() {\n                ": "",
    " => match usage_meter.mode {\n                    CompletionMode::Normal => (&claude_opus_4, ": "",
    "),\n                    CompletionMode::Max => (&claude_opus_4_max, ": "",
    "),\n                },\n                ": "",
    " => match usage_meter.mode {\n                    CompletionMode::Normal => (&claude_sonnet_4, ": "",
    "),\n                    CompletionMode::Max => (&claude_sonnet_4_max, ": "",
    " => (&claude_3_5_sonnet, ": "",
    "),\n                ": "",
    " => match usage_meter.mode {\n                    CompletionMode::Normal => (&claude_3_7_sonnet, ": "",
    "),\n                    CompletionMode::Max => {\n                        (&claude_3_7_sonnet_max, ": "",
    ")\n                    }\n                },\n                model_name => {\n                    bail!(": ""
  },
  "zed/crates/collab/src/api/contributors.rs": {
    "/contributors": "",
    "/contributor": "",
    "must be one of `github_user_id` or `github_login`.": "",
    "renovate[bot]": "",
    "2017-06-02T07:04:12Z": "",
    "failed to parse 'created_at' for 'renovate[bot]'": ""
  },
  "zed/crates/collab/src/api/events.rs": {
    "zed-crash-reports": "",
    "/telemetry/events": "",
    "/telemetry/crashes": "",
    "/telemetry/panics": "",
    "/telemetry/hangs": "",
    "x-zed-checksum": "",
    "dev.zed.Zed-Dev": "",
    "Crash uploads from {} are ignored.": "",
    ".ips": "",
    "We've already uploaded this crash": "",
    "Failed to upload crash: {}": "",
    "x-zed-panicked-on": "",
    "x-zed-installation-id": "",
    "Can't parse {}: {}": "",
    "x-zed-panic": "",
    "client": "",
    "crash report": "",
    "app_version": "",
    "os_version": "",
    "os_name": "",
    "macOS": "",
    "bundle_id": "",
    "incident_id": "",
    "installation_id": "",
    "description": "",
    "backtrace": "",
    "Crash Reported": "",
    "*Version:*\\n{} ({})": "",
    "https://": "",
    "http://": "",
    "*Incident:*\\n<https://{}.{}/{}.ips|{}…>": "",
    "Failed to serialize payload to JSON: {err}": "",
    "Content-Type": "",
    "application/json": "",
    "Failed to send payload to Slack: {err}": "",
    "events not enabled": "",
    "invalid checksum": "",
    ".hang.json": "",
    "can't parse report json: {err}": "",
    "Possible hang detected on main thread:": "",
    "<unknown>": "",
    "\\n{}": "",
    "hang report": "",
    "invalid json": "",
    "Linux": "",
    "1.0.0": "",
    "invalid os version": "",
    ".json": "",
    "\\n": "",
    "panic report": "",
    "Panic Reported": "",
    "{}\\n   and {} more": "",
    "Panic request": "",
    "*Version:*\\n {} ": "",
    "*{} {}:*\\n<https://{}.{}/{}.json|{}…>": "",
    "ERROR_SURFACE_LOST_KHR": "",
    "ERROR_INITIALIZATION_FAILED": "",
    "GPU has crashed, and no debug information is available": "",
    "can't parse event json: {err}": "",
    "no events": "",
    "open": "",
    "Editor Opened": "",
    "save": "",
    "Editor Saved": "",
    "Unknown Editor Event: {}": "",
    "Edit Prediction {}": "",
    "Accepted": "",
    "Discarded": "",
    "Edit Prediction Rated": "",
    "unshare project": "",
    "Project Unshared": "",
    "open channel notes": "",
    "Channel Notes Opened": "",
    "share project": "",
    "Project Shared": "",
    "join channel": "",
    "Channel Joined": "",
    "hang up": "",
    "Call Ended": "",
    "accept incoming": "",
    "Incoming Call Accepted": "",
    "invite": "",
    "Participant Invited": "",
    "disable microphone": "",
    "Microphone Disabled": "",
    "enable microphone": "",
    "Microphone Enabled": "",
    "enable screen share": "",
    "Screen Share Enabled": "",
    "disable screen share": "",
    "Screen Share Disabled": "",
    "decline incoming": "",
    "Incoming Call Declined": "",
    "Unknown Call Event: {}": "",
    "Assistant Responded": "",
    "Assistant Invoked": "",
    "Assistant Response Accepted": "",
    "Assistant Response Rejected": "",
    "App Opened": "",
    "first open": "",
    "App First Opened": "",
    "first open for release channel": "",
    "App First Opened For Release Channel": "",
    "close": "",
    "App Closed": "",
    "open project": "",
    "Project Opened": "",
    "open node project": "",
    "project_type": "",
    "node": "",
    "open pnpm project": "",
    "pnpm": "",
    "open yarn project": "",
    "yarn": "",
    "create ssh server": "",
    "SSH Server Created": "",
    "create ssh project": "",
    "SSH Project Created": "",
    "open ssh project": "",
    "SSH Project Opened": "",
    "welcome page: change keymap": "",
    "Welcome Keymap Changed": "",
    "welcome page: change theme": "",
    "Welcome Theme Changed": "",
    "welcome page: close": "",
    "Welcome Page Closed": "",
    "welcome page: edit settings": "",
    "Welcome Settings Edited": "",
    "welcome page: install cli": "",
    "Welcome CLI Installed": "",
    "welcome page: open": "",
    "Welcome Page Opened": "",
    "welcome page: open extensions": "",
    "Welcome Extensions Page Opened": "",
    "welcome page: sign in to copilot": "",
    "Welcome Copilot Signed In": "",
    "welcome page: toggle diagnostic telemetry": "",
    "Welcome Diagnostic Telemetry Toggled": "",
    "welcome page: toggle metric telemetry": "",
    "Welcome Metric Telemetry Toggled": "",
    "welcome page: toggle vim": "",
    "Welcome Vim Mode Toggled": "",
    "welcome page: view docs": "",
    "Welcome Documentation Viewed": "",
    "extensions page: open": "",
    "Extensions Page Opened": "",
    "extensions: install extension": "",
    "Extension Installed": "",
    "extensions: uninstall extension": "",
    "Extension Uninstalled": "",
    "markdown preview: open": "",
    "Markdown Preview Opened": "",
    "project diagnostics: open": "",
    "Project Diagnostics Opened": "",
    "project search: open": "",
    "Project Search Opened": "",
    "repl sessions: open": "",
    "REPL Session Started": "",
    "feature upsell: toggle vim": "",
    "source": "",
    "Feature Upsell": "",
    "Vim Mode Toggled": "",
    "feature upsell: viewed docs (": "",
    "Unknown App Event: {}": "",
    "url": "",
    "Documentation Viewed": "",
    "Settings Changed": "",
    "Extension Loaded": "",
    "Editor Edited": "",
    "Action Invoked": "",
    "Kernel Status Changed": "",
    "architecture": "",
    "release_channel": "",
    "signed_in": "",
    "checksum_matched": "",
    "country": "",
    "is_staff": ""
  },
  "zed/crates/collab/src/api/extensions.rs": {
    "/extensions": "",
    "/extensions/updates": "",
    "/extensions/:extension_id": "",
    "/extensions/:extension_id/download": "",
    "/extensions/:extension_id/:version/download": "",
    "extension_search": "",
    "unknown extension": "",
    "not supported": "",
    "unknown extension version": "",
    "extensions/{extension_id}/{version}/archive.tar.gz": "",
    "creating presigned extension download url": "",
    "no blob store client": "",
    "no blob store bucket": "",
    "fetching extensions from blob store": "",
    "extensions/": "",
    "fetched {} object(s) from blob store": "",
    "extensions": "",
    "manifest.json": "",
    "found {} published extensions": "",
    "fetched {} new extensions from blob store": "",
    "extensions/{extension_id}/{version}/manifest.json": "",
    "failed to download manifest for extension {extension_id} version {version}": "",
    "invalid manifest for extension {extension_id} version {version}: {}": "",
    "missing last modified timestamp for extension {extension_id} version {version}": "",
    "invalid version for extension {extension_id} version {version}": ""
  },
  "zed/crates/collab/src/api/ips_file.rs": {
    "No header found": "",
    "parsing header": "",
    "No body found": "",
    "parsing body": "",
    "%Y-%m-%d %H:%M:%S%.f %#z": "",
    "Abort trap: 6": "",
    "Panic `{}`": "",
    "Crash `Abort trap: 6` (possible panic)": "",
    "Exception `{}`": "",
    "Crash `{}`": "",
    " on thread {} ({})": "",
    "{:#}": "",
    "<unknown-image>": "",
    "<unknown>": "",
    "  and {} more...": "",
    "\\n": "",
    "<no backtrace available>": "",
    "pthread_kill": "",
    "panic": "",
    "backtrace": "",
    "rust_begin_unwind": "",
    "abort": "",
    "bundleID": "",
    "camelCase": "",
    "userID": "",
    "coalitionID": "",
    "roots_installed": "",
    "bug_type": "",
    "codeSigningID": "",
    "codeSigningTeamID": "",
    "CFBundleShortVersionString": "",
    "CFBundleVersion": "",
    "CFBundleIdentifier": "",
    "beforePC": "",
    "atPC": "",
    "type": "",
    "libsystem_c.dylib": "",
    "thread_create": "",
    "thread_set_state": "",
    "task_for_pid": ""
  },
  "zed/crates/collab/src/bin/dotenv.rs": {
    ".": "",
    "POWERSHELL": "",
    "$env:{}=\\\"{}\\\"": "",
    "export {}=\\\"{}\\\"": ""
  },
  "zed/crates/collab/src/db/queries/access_tokens.rs": {
    "no such access token": ""
  },
  "zed/crates/collab/src/db/queries/billing_preferences.rs": {
    "billing preferences not found": ""
  },
  "zed/crates/collab/src/db/queries/buffers.rs": {
    "user is not a member of channel": "",
    "can't rejoin buffer, epoch has changed": "",
    "can't rejoin buffer, no previous collaborator found": "",
    "not a collaborator on this project": "",
    "no such buffer": "",
    "missing buffer snapshot": "",
    "no such snapshot": "",
    "{error}": "",
    "2": "",
    "3": "",
    "4": "",
    "5": "",
    "6": "",
    "1": ""
  },
  "zed/crates/collab/src/db/queries/channels.rs": {
    "Creating channel '{}' with parent_path='{}', max_order={}, new_order={}": "",
    "channel-{}": "",
    "direction": "",
    "parent": "",
    "children": "",
    "channel name can't be blank": "",
    "no such invitation": "",
    "no such member": "",
    "sqlite": "",
    "UPPER(github_login) LIKE ?": "",
    "github_login ILIKE $1": "",
    "not role = 'admin', not role = 'member', not role = 'guest', not accepted, github_login": "",
    "https://github.com/{}.png?size=128": "",
    "user is not a channel admin or channel does not exist": "",
    "user is not a channel member or channel does not exist": "",
    "user is not a channel participant or channel does not exist": "",
    "parent_path || id || '/'": "",
    "{}{}/": "",
    "\n                    UPDATE channels SET parent_path = REPLACE(parent_path, $1, $2)\n                    WHERE parent_path LIKE $3 || '%'\n                    RETURNING id\n                ": "",
    "Skipping reorder of root channel {}": "",
    "Reordering channel {} (parent_path: '{}', order: {})": "",
    "Looking for sibling with parent_path='{}' and order < {}": "",
    "Looking for sibling with parent_path='{}' and order > {}": "",
    "Found sibling {} (parent_path: '{}', order: {})": "",
    "No sibling found to swap with": "",
    "Reorder complete. Swapped channels {} and {}": "",
    "max_order": ""
  },
  "zed/crates/collab/src/db/queries/contacts.rs": {
    "user_a_participant": "",
    "user_b_participant": "",
    "user_a_busy": "",
    "user_b_busy": "",
    "contact already requested": "",
    "no such contact": "",
    "no such contact request": ""
  },
  "zed/crates/collab/src/db/queries/extensions.rs": {
    "name ILIKE $1": "",
    "no such extension: {extension_id}": "",
    "failed to insert extension": "",
    ", ": ""
  },
  "zed/crates/collab/src/db/queries/messages.rs": {
    "not a chat participant": "",
    "failed to insert message": "",
    ", ": "",
    "({})": "",
    "\n            SELECT\n                *\n            FROM (\n                SELECT\n                    *,\n                    row_number() OVER (\n                        PARTITION BY channel_id\n                        ORDER BY id DESC\n                    ) as row_number\n                FROM channel_messages\n                WHERE\n                    channel_id in ({values})\n            ) AS messages\n            WHERE\n                row_number = 1\n            ": "",
    "no such message": "",
    "operation could not be completed": "",
    "ChannelMessageMention": "",
    "Channel message not found": "",
    "Attempted to edit a message (id: {message_id}) which does not exist anymore.": ""
  },
  "zed/crates/collab/src/db/queries/notifications.rs": {
    "Unknown notification kind": "",
    "invalid notification kind {:?}": ""
  },
  "zed/crates/collab/src/db/queries/projects.rs": {
    "could not find participant": "",
    "shared project on unexpected room": "",
    "guests cannot share projects": "",
    "project not found": "",
    "cannot unshare a project hosted by another user": "",
    "no such project": "",
    "invalid worktree update. removed entries: {}, updated entries: {}": "",
    "no such project: {project_id}": "",
    "[]": "",
    "invalid summary": "",
    "can't update a project hosted by someone else": "",
    "invalid language server": "",
    "unknown worktree settings kind: {kind}": "",
    "failed to deserialize repository's entry ids": "",
    "not a collaborator on this project": "",
    "failed to read project host": "",
    "not authorized to edit projects": "",
    "not authorized to read projects": "",
    "can only send project updates to a project you're in": "",
    "not room participants": ""
  },
  "zed/crates/collab/src/db/queries/rooms.rs": {
    "user is not in the room": "",
    "banned users cannot invite": "",
    "failed to build incoming call": "",
    "could not find call to decline": "",
    "no call to cancel": "",
    "no such room": "",
    "tried to join channel call directly": "",
    "room does not exist or was already joined": "",
    "no channel for room": "",
    "project does not exist": "",
    "no such project": "",
    "host not found among collaborators": "",
    "failed to deserialize repository's entry ids": "",
    "invalid location": "",
    "could not update room participant location": "",
    "only admins can set participant role": "",
    "could not update room participant role": "",
    "could not find room": "",
    "user has not signed the Zed CLA": "",
    "not a room participant": ""
  },
  "zed/crates/collab/src/db/queries/users.rs": {
    "too many users": "",
    "could not find user": "",
    "connected_once": "",
    "accepted_tos_at": "",
    "\n                SELECT users.*\n                FROM users\n                WHERE github_login ILIKE $1\n                ORDER BY github_login <-> $2\n                LIMIT $3\n            ": "",
    "cir": "",
    "%c%i%r%": ""
  },
  "zed/crates/collab_ui/src/chat_panel/message_editor.rs": {
    "@[-_\\\\w]+": "",
    "@": "",
    "message editor must be singleton": "",
    "Markdown": "",
    "failed to load Markdown language": "",
    "Message #{channel_name}": "",
    "Message Channel": "",
    "@{}": "",
    ":{}: {}": ""
  },
  "zed/crates/collab_ui/src/collab_panel/channel_modal.rs": {
    "": "",
    "ChannelModal": "",
    "is-public": "",
    "Public": "",
    "copy-link": "",
    "Copy Link": "",
    "manage-members": "",
    "Manage Members": "",
    "invite-members": "",
    "Invite Members": "",
    "Search collaborator by username...": "",
    "Invited": "",
    "Admin": "",
    "Guest": "",
    "ellipsis": "",
    "You": "",
    "Member": "",
    "Failed to update role": "",
    "Failed to remove member": "",
    "Failed to invite member": "",
    "Demote to Guest": "",
    "Promote to Member": "",
    "Demote to Member": "",
    "Promote to Admin": "",
    "Remove from Channel": ""
  },
  "zed/crates/collab_ui/src/collab_panel/contact_finder.rs": {
    "Contacts": "",
    "Invite new contacts": "",
    "Search collaborator by username...": "",
    "icons/check.svg": "",
    "icons/x.svg": ""
  },
  "zed/crates/collab_ui/src/notifications/stories/collab_notification.rs": {
    "Incoming Call Notification": "",
    "https://avatars.githubusercontent.com/u/1486634?v=4": "",
    "accept": "",
    "Accept": "",
    "decline": "",
    "Decline": "",
    "maxdeviant is sharing a project in Zed": "",
    "Project Shared Notification": "",
    "https://avatars.githubusercontent.com/u/1714999?v=4": "",
    "open": "",
    "Open": "",
    "dismiss": "",
    "Dismiss": "",
    "iamnbutler": "",
    "is sharing a project in Zed:": "",
    "zed": ""
  },
  "zed/crates/collab_ui/src/notifications/incoming_call_notification.rs": {
    "accept": "",
    "Accept": "",
    "decline": "",
    "Decline": "",
    "{} is sharing a project in Zed": ""
  },
  "zed/crates/collab_ui/src/notifications/project_shared_notification.rs": {
    "open": "",
    "Open": "",
    "dismiss": "",
    "Dismiss": "",
    "is sharing a project in Zed{}": "",
    "": "",
    ":": "",
    ", ": ""
  },
  "zed/crates/collab_ui/src/channel_view.rs": {
    "Channel Notes Opened": "",
    "Markdown": "",
    "Copy link to section": "",
    "Link copied to clipboard": "",
    "read-only": "",
    "disconnected": "",
    "<unknown>": "",
    "{name} - {status}": ""
  },
  "zed/crates/collab_ui/src/chat_panel.rs": {
    "ChatPanel": "",
    "Message has been deleted...": "",
    "reply-to-saved-message-container": "",
    "reply-to-pending-message-container": "",
    "composing-reply-container": "",
    "@{}": "",
    " ": "",
    "Go to message": "",
    "saved-message": "",
    "pending-message": "",
    "": "",
    "body": "",
    "New messages": "",
    "reply": "",
    "Reply": "",
    "edit": "",
    "message editor must be singleton": "",
    "Edit": "",
    "menu": "",
    "trigger": "",
    "more": "",
    "More": "",
    "Copy message text": "",
    "Delete message": "",
    " (edited)": "",
    "chat_header": "",
    "#{}": "",
    "Chat": "",
    "Select a channel to chat in.": "",
    "toggle-collab": "",
    "Open": "",
    "Editing message": "",
    "cancel-edit-message": "",
    "Cancel edit message": "",
    "reply-preview": "",
    "Replying to ": "",
    "close-reply-preview": "",
    "Close reply": "",
    "Chat Panel": "",
    "*hi*, «@abc», let's **call** «@fgh»": "",
    "fgh": "",
    "avatar_fgh": "",
    "'": "",
    "«hi», «@abc», let’s «call» «@fgh»": "",
    "Here is a link https://zed.dev to zeds website": "",
    "Here is a link «https://zed.dev» to zeds website": "",
    "**Here is a link https://zed.dev to zeds website**": "",
    "«Here is a link »«https://zed.dev»« to zeds website»": ""
  },
  "zed/crates/collab_ui/src/collab_panel.rs": {
    "CollaborationPanel": "",
    "toggle_on_modifiers_press": "",
    "{project:?}": "",
    "{room:?}": "",
    "Filter...": "",
    "reading collaboration panel from key value store": "",
    "{}-{:?}": "",
    "Follow {}": "",
    "Calling": "",
    "leave-call": "",
    "Leave Call": "",
    "Guest": "",
    "Mic only": "",
    "untitled": "",
    ", ": "",
    "Failed to join project": "",
    "Open {}": "",
    "screen": "",
    "Screen": "",
    "Open shared screen": "",
    "": "",
    "channel-notes": "",
    "notes": "",
    "Open Channel Notes": "",
    "channel-chat": "",
    "chat": "",
    "Open Chat": "",
    "Grant Mic Access": "",
    "Failed to grant mic access": "",
    "Grant Write Access": "",
    "Failed to grant write access": "",
    "This user has not yet signed the CLA at https://zed.dev/cla.": "",
    "Mute": "",
    "Revoke Access": "",
    "Failed to revoke access": "",
    "Expand Subchannels": "",
    "Collapse Subchannels": "",
    "Open Notes": "",
    "Copy Channel Link": "",
    "New Subchannel": "",
    "Rename": "",
    "Move '#{}' here": "",
    "Manage Members": "",
    "Move this channel": "",
    "Make Channel Private": "",
    "Make Channel Public": "",
    "Delete": "",
    "Leave Channel": "",
    "Invite {} to join": "",
    "Call {}": "",
    "Remove Contact": "",
    " ": "",
    "Failed to create channel": "",
    "Failed to hang up": "",
    "Failed to set channel visibility": "",
    "direction": "",
    "parent": "",
    "To make a channel public, its parent channel must be public.": "",
    "To make a channel private, all of its subchannels must be private.": "",
    "Failed to move channel": "",
    "Public channels must have public parents": "",
    "You cannot move a channel into itself": "",
    "You cannot move a channel into a different root channel": "",
    "Failed to move channel up": "",
    "Failed to move channel down": "",
    "CollabPanel": "",
    "menu": "",
    "editing": "",
    "not_editing": "",
    "Are you sure you want to leave \\\"#{}\\\"?": "",
    "Leave": "",
    "Cancel": "",
    "Failed to leave channel": "",
    "Are you sure you want to remove the channel \\\"{}\\\"?": "",
    "Remove": "",
    "Are you sure you want to remove \\\"{}\\\" from your contacts?": "",
    "Failed to remove contact": "",
    "Failed to respond to contact request": "",
    "Call failed": "",
    "Failed to join channel": "",
    "Work with your team in realtime with collaborative editing, voice, shared notes and more.": "",
    "sign_in": "",
    "Sign in": "",
    "Sign in to enable collaboration.": "",
    "icons/public.svg": "",
    "Copy public channel link.": "",
    "icons/hash.svg": "",
    "Copy private channel link.": "",
    "Current Call": "",
    "Requests": "",
    "Contacts": "",
    "Channels": "",
    "Invites": "",
    "Online": "",
    "Offline": "",
    "channel-link": "",
    "section-header": "",
    "Copy channel link": "",
    "add-contact": "",
    "Search for new contact": "",
    "add-channel": "",
    "Create a channel": "",
    "contact context menu": "",
    " {} is offline": "",
    " {} is on a call": "",
    "Invite {} to join call": "",
    "decline-contact": "",
    "Decline invite": "",
    "accept-contact": "",
    "Accept invite": "",
    "remove_contact": "",
    "Cancel invite": "",
    "reject-invite": "",
    "accept-invite": "",
    "channel-invite": "",
    "contact-placeholder": "",
    "Add a Contact": "",
    "+{extra_count}": "",
    "channel_chat": "",
    "Open channel chat": "",
    "channel_notes": "",
    "Open channel notes": "",
    "channel-editor": "",
    "Collab Panel": "",
    "Join channel": ""
  },
  "zed/crates/collab_ui/src/collab_ui.rs": {},
  "zed/crates/collab_ui/src/notification_panel.rs": {
    "NotificationPanel": "",
    "notification_timestamp": "",
    "You accepted": "",
    "You declined": "",
    "decline": "",
    "Decline": "",
    "accept": "",
    "Accept": "",
    "icons/plus.svg": "",
    "{} wants to add you as a contact": "",
    "{} accepted your contact invite": "",
    "icons/hash.svg": "",
    "{} invited you to join the #{channel_name} channel": "",
    "icons/conversations.svg": "",
    "{} mentioned you in #{}:\\n{}": "",
    "Notifications": "",
    "sign_in_prompt_button": "",
    "Sign in": "",
    "Connection timeout": "",
    "Connection reset": "",
    "Sign in to view notifications.": "",
    "You have no notifications.": "",
    "Notification Panel": "",
    "suppress": "",
    "close": "",
    "notification_panel_toast": "",
    "Suppress.\\nClose with click.": "",
    "Close.\\nSuppress with shift-click": ""
  },
  "zed/crates/command_palette/src/command_palette.rs": {
    "": "",
    "Execute a command...": "",
    "Action Invoked": "",
    "command palette": "",
    "Command": "",
    "name": "",
    "editor::GoToDefinition": "",
    "editor: go to definition": "",
    "editor::Backspace": "",
    "editor: backspace": "",
    "go_to_line::Deploy": "",
    "go to line: deploy": "",
    "editor:  backspace": "",
    "editor:    backspace": "",
    "editor:GoToDefinition": "",
    "editor::::GoToDefinition": "",
    "editor: :GoToDefinition": "",
    "abc": "",
    "cmd-shift-p": "",
    "bcksp": "",
    "enter": "",
    "ab": "",
    "editor": "",
    "Editor::    Backspace": "",
    "cmd-n": "",
    "1\\n2\\n3\\n4\\n5\\n6\\n": "",
    "go to line: Toggle": "",
    "3 enter": "",
    "[\n                    {\n                        ": "",
    ": {\n                            ": "",
    ": ": "",
    ",\n                            ": "",
    "\n                        }\n                    }\n                ]": ""
  },
  "zed/crates/copilot/src/copilot_chat.rs": {
    "GH_COPILOT_TOKEN": "",
    "gpt-4.1": "",
    "lowercase": "",
    "deserialize_models_skip_errors": "",
    "GitHub Copilot Chat model failed to deserialize: {:?}": "",
    "Azure OpenAI": "",
    "type": "",
    "text": "",
    "image_url": "",
    "Vec::is_empty": "",
    "Option::is_none": "",
    "snake_case": "",
    "role": "",
    "invalid expires_at": "",
    "windows": "",
    "AppData": "",
    "Local": "",
    ".config": "",
    "github-copilot": "",
    "hosts.json": "",
    "apps.json": "",
    "OAuth token is missing while updating Copilot Chat models": "",
    "Copilot chat is not enabled": "",
    "No OAuth token available": "",
    "enabled": "",
    "Authorization": "",
    "Bearer {}": "",
    "Content-Type": "",
    "application/json": "",
    "Copilot-Integration-Id": "",
    "vscode-chat": "",
    "Failed to request models: {}": "",
    "token {}": "",
    "Accept": "",
    "Failed to request API token: {body_str}": "",
    "github.com": "",
    "oauth_token": "",
    "Editor-Version": "",
    "Zed/{}": "",
    "CARGO_PKG_VERSION": "",
    "unknown": "",
    "Copilot-Vision-Request": "",
    "Failed to connect to API: {} {}": "",
    "data: ": "",
    "[DONE]": "",
    "{\n              ": "",
    ": [\n                {\n                  ": "",
    ": {\n                    ": "",
    ": ": "",
    ",\n                    ": "",
    ": {\n                      ": "",
    ": 32768,\n                      ": "",
    ": 4096,\n                      ": "",
    ": 32768\n                    },\n                    ": "",
    ": { ": "",
    ": true, ": "",
    ": true },\n                    ": "",
    "\n                  },\n                  ": "",
    ",\n                  ": "",
    ": false,\n                  ": "",
    "\n                },\n                {\n                    ": "",
    ": 123\n                },\n                {\n                  ": "",
    ": 200000,\n                      ": "",
    ": 16384,\n                      ": "",
    ": 90000,\n                      ": "",
    ": {\n                        ": "",
    ": 3145728,\n                        ": "",
    ": 1,\n                        ": "",
    ": [": "",
    ", ": "",
    "]\n                      }\n                    },\n                    ": "",
    ": true,\n                      ": "",
    ": true\n                    },\n                    ": "",
    ": true,\n                  ": "",
    "\n                }\n              ],\n              ": "",
    "\n            }": "",
    "gpt-4": "",
    "claude-3.7-sonnet": ""
  },
  "zed/crates/copilot/src/copilot.rs": {
    "must sign in before using copilot": "",
    "copilot is still starting": "",
    "copilot is disabled": "",
    "copilot was not started because of an error: {error}": "",
    "http:": "",
    "HTTP_PROXY": "",
    "https:": "",
    "HTTPS_PROXY": "",
    "Unsupported protocol scheme for language server proxy (must be http or https)": "",
    "NODE_TLS_REJECT_UNAUTHORIZED": "",
    "0": "",
    "test-support": "",
    "path/to/copilot": "",
    "copilot": "",
    "--stdio": "",
    "windows": "",
    "C:/": "",
    "/": "",
    "zed": "",
    "CARGO_PKG_VERSION": "",
    "zed-copilot": "",
    "0.0.1": "",
    "copilot: check status": "",
    "copilot: set editor info": "",
    "copilot sign-in": "",
    "copilot: sign in confirm": "",
    "{err:?}": "",
    "copilot hasn't started yet": "",
    "copilot: notify accepted": "",
    "copilot: notify rejected": "",
    "copilot: get completions": "",
    "plaintext": "",
    "buffer://{}": "",
    "@github/copilot-language-server": "",
    "node_modules/@github/copilot-language-server/dist/language-server.js": "",
    "Hello": "",
    "Goodbye": "",
    " world": "",
    "/root/child/buffer-1": "",
    "child/buffer-1": "",
    "Hello world": "",
    "user-1": ""
  },
  "zed/crates/copilot/src/sign_in.rs": {
    "https://github.com/features/copilot": "",
    "Copilot is reinstalling...": "",
    "Copilot is starting...": "",
    "Copilot has started.": "",
    "Signing out of Copilot...": "",
    "Signed out of Copilot.": "",
    "Copied!": "",
    "Copy": "",
    "Waiting for connection...": "",
    "Connect to GitHub": "",
    "Use GitHub Copilot in Zed.": "",
    "Using Copilot requires an active subscription on GitHub.": "",
    "Paste this code into GitHub after clicking the button below.": "",
    "connect-button": "",
    "copilot-enable-cancel-button": "",
    "Cancel": "",
    "Copilot Enabled!": "",
    "You can update your settings or sign out from the Copilot menu in the status bar.": "",
    "copilot-enabled-done-button": "",
    "Done": "",
    "You must have an active GitHub Copilot subscription.": "",
    "You can enable Copilot by connecting your existing license once you have subscribed or renewed your subscription.": "",
    "copilot-subscribe-button": "",
    "Subscribe on GitHub": "",
    "copilot-subscribe-cancel-button": "",
    "icon_circle_arrow": "",
    "copilot code verification": ""
  },
  "zed/crates/db/src/db.rs": {
    "FALLBACK_MEMORY_DB": "",
    "db.sqlite": "",
    "ZED_STATELESS": "",
    "0-{}": "",
    "Could not create db directory": "",
    "Opening main db": "",
    "Opening fallback db": "",
    "Fallback in memory database failed. Likely initialization queries or migrations have fundamental errors": "",
    "test-support": "",
    "global": "",
    "db_tests": "",
    "DbTests": "",
    "SELECT * FROM test2": ""
  },
  "zed/crates/db/src/query.rs": {
    "Error in {}, exec failed to execute or parse for: {}": "",
    "Error in {}, exec_bound failed to execute or parse for: {}": "",
    "Error in {}, select_row failed to execute or parse for: {}": "",
    "Error in {}, select_row_bound failed to execute or parse for: {}": "",
    "Error in {}, select_row_bound expected single row result but found none for: {}": ""
  },
  "zed/crates/diagnostics/src/diagnostics_tests.rs": {
    "/test": "",
    "consts.rs": "",
    "\n                const a: i32 = 'a';\n                const b: i32 = c;\n            ": "",
    "main.rs": "",
    "\n                fn main() {\n                    let x = vec![];\n                    let y = vec![];\n                    a(x);\n                    b(y);\n                    // comment 1\n                    // comment 2\n                    c(y);\n                    d(x);\n                }\n            ": "",
    "/test/main.rs": "",
    "use of moved value\\nvalue used here after move": "",
    "move occurs because `y` has type `Vec<char>`, which does not implement the `Copy` trait": "",
    "value moved here": "",
    "move occurs because `x` has type `Vec<char>`, which does not implement the `Copy` trait": "",
    "§ main.rs\n             § -----\n             fn main() {\n                 let x = vec![];\n             § move occurs because `x` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 let y = vec![];\n             § move occurs because `y` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 a(x); § value moved here (back)\n                 b(y); § value moved here\n                 // comment 1\n                 // comment 2\n                 c(y);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `y` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n                 d(x);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `x` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n             § hint: value moved here\n             }": "",
    "/test/consts.rs": "",
    "mismatched types expected `usize`, found `char`": "",
    "§ consts.rs\n             § -----\n             const a: i32 = 'a'; § mismatched types expected `usize`, found `char`\n             const b: i32 = c;\n\n             § main.rs\n             § -----\n             fn main() {\n                 let x = vec![];\n             § move occurs because `x` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 let y = vec![];\n             § move occurs because `y` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 a(x); § value moved here (back)\n                 b(y); § value moved here\n                 // comment 1\n                 // comment 2\n                 c(y);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `y` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n                 d(x);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `x` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n             § hint: value moved here\n             }": "",
    "unresolved name `c`": "",
    "§ consts.rs\n             § -----\n             const a: i32 = 'a'; § mismatched types expected `usize`, found `char`\n             const b: i32 = c; § unresolved name `c`\n\n             § main.rs\n             § -----\n             fn main() {\n                 let x = vec![];\n             § move occurs because `x` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 let y = vec![];\n             § move occurs because `y` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 a(x); § value moved here (back)\n                 b(y); § value moved here\n                 // comment 1\n                 // comment 2\n                 c(y);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `y` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n                 d(x);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `x` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n             § hint: value moved here\n             }": "",
    "main.js": "",
    "\n            function test() {\n                return 1\n            };\n\n            tset();\n            ": "",
    "/test/main.js": "",
    "no method `tset`": "",
    "method `test` defined here": "",
    "§ main.js\n             § -----\n             ⋯\n\n             tset(); § no method `tset`": "",
    "§ main.js\n             § -----\n             function test() { § method `test` defined here\n                 return 1\n             };\n\n             tset(); § no method `tset`": "",
    "\n                a();\n                b();\n                c();\n                d();\n                e();\n            ": "",
    "error 1": "",
    "§ main.js\n             § -----\n             a(); § error 1\n             b();\n             c();": "",
    "warning 1": "",
    "§ main.js\n             § -----\n             a(); § error 1\n             b(); § warning 1\n             c();\n             d();": "",
    "warning 2": "",
    "§ main.js\n             § -----\n             a();\n             b(); § warning 1\n             c(); § warning 2\n             d();\n             e();": "",
    "§ main.js\n                 § -----\n                 a();\n                 b();\n                 c(); § warning 2\n                 d(); § warning 2\n                 e();": "",
    "OPERATIONS": "",
    "invalid `OPERATIONS` variable": "",
    "finishing diagnostic check for language server {server_id}": "",
    "/test/{}.rs": "",
    "updating diagnostics. language server {server_id} path {path:?}": "",
    "file:///test/fallback.rs": "",
    "updating mutated diagnostics view": "",
    "constructing reference diagnostics view": "",
    "§ -----": "",
    "adding inlay at {position}/{}: {:?}": "",
    "Test inlay {next_inlay_id}": "",
    "\n        ˇfn func(abc def: i32) -> u32 {\n        }\n    ": "",
    "Something's wrong!": "",
    "/root/file": "",
    "Should have a diagnostics group activated": "",
    "\n        fn func(abcˇ def: i32) -> u32 {\n        }\n    ": "",
    "\n        fn func(abc def: i32) -> ˇu32 {\n        }\n    ": "",
    "\n        fn func(abc ˇdef: i32) -> u32 {\n        }\n    ": "",
    "\n        fn func(abˇc def: i32) -> u32 {\n        }\n    ": "",
    "we've had problems with <https://link.one>, and <https://link.two> is broken": "",
    "\n        fn teˇst() { println!(); }\n    ": "",
    "\n        fn «test»() { println!(); }\n    ": "",
    "/root/dir/file.rs": "",
    "A test diagnostic message.": "",
    "\n            fn «test»() { println!(); }\n        ": "",
    "some new docs": "",
    "/root": "",
    "\n                function test() {\n                    const x = 10;\n                    const y = 20;\n                    return 1;\n                }\n                test();\n            ": "",
    "/root/main.js": "",
    "no-unused-vars": "",
    "eslint": "",
    "'x' is assigned a value but never used": "",
    "'y' is assigned a value but never used": "",
    "§ main.js\n             § -----\n             function test() {\n                 const x = 10; § 'x' is assigned a value but never used (eslint no-unused-vars)\n                 const y = 20; § 'y' is assigned a value but never used (eslint no-unused-vars)\n                 return 1;\n             }": "",
    "  removing diagnostic at index {idx}": "",
    "  inserting {} at index {ix}. {},{}..{},{}": "",
    "   {}. {},{}..{},{}": "",
    "diagnostic {unique_id}": "",
    "related info {i} for diagnostic {unique_id}": ""
  },
  "zed/crates/diagnostics/src/diagnostics.rs": {
    "No problems in workspace": "",
    "No errors in workspace": "",
    "EmptyPane": "",
    "s": "",
    "": "",
    "Show {} warning{}": "",
    "diagnostics-show-warning-label": "",
    "Diagnostics": "",
    "disk based diagnostics finished for server {language_server_id}": "",
    "diagnostics updated for server {language_server_id}, path {path:?}. recording change": "",
    "diagnostics updated for server {language_server_id}, path {path:?}. updating excerpts": "",
    "Finished fetching cargo diagnostics": "",
    "Cargo.toml": "",
    "rs": "",
    "Project Diagnostics": "",
    "No problems": "",
    "Project Diagnostics Opened": "",
    "Expanding to ancestor started on {} node exceeding row limit of {max_row_count}.": "",
    "block": "",
    "statement": "",
    "declaration": "",
    "Expanding to ancestor reached the top node, so using default context line count.": ""
  },
  "zed/crates/diagnostics/src/items.rs": {
    "diagnostic_message": "",
    "Next Diagnostic": "",
    "diagnostic-indicator": "",
    "Project Diagnostics": ""
  },
  "zed/crates/diagnostics/src/toolbar_controls.rs": {
    "Exclude Warnings": "",
    "Include Warnings": "",
    "stop-updating": "",
    "Stop diagnostics update": "",
    "refresh-diagnostics": "",
    "Refresh diagnostics": "",
    "toggle-warnings": ""
  },
  "zed/crates/docs_preprocessor/src/main.rs": {
    "keymaps/default-macos.json": "",
    "Failed to load MacOS keymap": "",
    "keymaps/default-linux.json": "",
    "Failed to load Linux keymap": "",
    "zed-docs-preprocessor": "",
    "Preprocesses Zed Docs content to provide rich action & keybinding support and more": "",
    "supports": "",
    "renderer": "",
    "Check whether a renderer is supported by this preprocessor": "",
    "Action not found: {}": "",
    "Deprecated action used: {} should be {}": "",
    "\\x1b[31m": "",
    "\\x1b[0m": "",
    "{ANSI_RED}ERROR{ANSI_RESET}: {}": "",
    "Found {} errors in docs": "",
    "Required argument": "",
    "not-supported": "",
    "\\{#kb (.*?)\\}": "",
    "macos": "",
    "linux": "",
    "<div>No default binding</div>": "",
    "<kbd class=\\\"keybinding\\\">{macos_binding}|{linux_binding}</kbd>": "",
    "\\{#action (.*?)\\}": "",
    "<code class=\\\"hljs\\\">{}</code>": "",
    "Not a valid OS: {}": "",
    "assistant::Assist": "",
    "\\\"editor::ToggleComments\\\", {\\\"advance_downwards\\\":false}": "",
    "editor::ToggleComments": "",
    ",": ""
  },
  "zed/crates/editor/src/git/blame.rs": {
    "Updated buffers. Regenerating blame data...": "",
    "Status of git repositories updated. Regenerating blame data...": "",
    "failed to get git blame data: {error:?}": "",
    "{:#}": "",
    "git-blame": "",
    "/my-repo": "",
    ".git": "",
    "file.txt": "",
    "\n                    irrelevant contents\n                ": "",
    "/my-repo/file.txt": "",
    "Failed to blame \\\"file.txt\\\": failed to get blame for \\\"file.txt\\\"": "",
    "\n                    AAA Line 1\n                    BBB Line 2 - Modified 1\n                    CCC Line 3 - Modified 2\n                    modified in memory 1\n                    modified in memory 1\n                    DDD Line 4 - Modified 2\n                    EEE Line 5 - Modified 1\n                    FFF Line 6 - Modified 2\n                ": "",
    "/my-repo/.git": "",
    "1b1b1b": "",
    "0d0d0d": "",
    "3a3a3a": "",
    "\n                    Line 1\n                    Line 2\n                    Line 3\n                ": "",
    "X": "",
    "\\n": "",
    "OPERATIONS": "",
    "invalid `OPERATIONS` variable": "",
    "MAX_EDITS_PER_OPERATION": "",
    "invalid `MAX_EDITS_PER_OPERATION` variable": "",
    "initial buffer text: {:?}": "",
    "initial blame entries: {:?}": "",
    "quiescing": "",
    "editing buffer": "",
    "buffer text: {:?}": "",
    "regenerating blame entries: {:?}": ""
  },
  "zed/crates/editor/src/clangd_ext.rs": {
    "C++": "",
    "C": "",
    "Unknown": "",
    "lsp ext switch source header proto request": "",
    "Switch source/header LSP request for path \\\"{source_file}\\\" failed": "",
    "Clangd returned an empty string when requesting to switch source/header from \\\"{source_file}\\\"": "",
    "Parsing URL \\\"{}\\\" returned from switch source/header failed": "",
    "URL conversion to file path failed for \\\"{goto}\\\"": "",
    "Switch source/header could not open \\\"{goto}\\\" in workspace": ""
  },
  "zed/crates/editor/src/code_context_menus.rs": {
    "bug: completion selected_item >= entries.len(): {} >= {}": "",
    "completions": "",
    "multiline_docs": "",
    "code_actions_menu": "",
    "\\n": "",
    "": "",
    "debug: ": "",
    "debug: {}": ""
  },
  "zed/crates/editor/src/display_map.rs": {
    "": "",
    "\\n": "",
    " ": "",
    "test-support": "",
    "DisplayPoint({}, {})": "",
    "OPERATIONS": "",
    "invalid `OPERATIONS` variable": "",
    "tab size: {}": "",
    "wrap width: {:?}": "",
    "buffer text: {:?}": "",
    "fold text: {:?}": "",
    "tab text: {:?}": "",
    "wrap text: {:?}": "",
    "block text: {:?}": "",
    "display text: {:?}": "",
    "setting wrap width to {:?}": "",
    "setting tab size to {:?}": "",
    "inserting block {:?} with height {}": "",
    "removing block ids {:?}": "",
    "unfolding ranges: {:?}": "",
    "folding ranges: {:?}": "",
    "row boundary before {:?}. reported buffer row boundary: {:?}": "",
    "display row boundary after {:?}. reported buffer row boundary: {:?}": "",
    "row boundary before {:?}. reported display row boundary: {:?}": "",
    "row boundary after {:?}. reported display row boundary: {:?}": "",
    "Moving from point {:?}": "",
    "Right {:?}": "",
    "Left {:?}": "",
    "one two three four five\\nsix seven eight": "",
    "Helvetica": "",
    "one two \\nthree four \\nfive\\nsix seven \\neight": "",
    "seven": "",
    "and ": "",
    "three four \\nfive\\nsix and \\nseven eight": "",
    "three \\nfour five\\nsix and \\nseven \\neight": "",
    "\\t": "",
    "    b   bbbbb": "",
    "c   ccccc": "",
    "a": "",
    "\\n\\na": "",
    "\\n\\n\\na": "",
    "b": "",
    "\\n\\n\\nab": "",
    "\n            fn outer() {}\n\n            mod module {\n                fn inner() {}\n            }": "",
    "mod.body": "",
    "fn.name": "",
    "Test": "",
    ".test": "",
    "\n                (mod_item name: (identifier) body: _ @mod.body)\n                (function_item name: (identifier) @fn.name)\n                ": "",
    "fn ": "",
    "outer": "",
    "() {}\\n\\nmod module ": "",
    "{\\n    fn ": "",
    "inner": "",
    "() {}\\n}": "",
    "    fn ": "",
    "out": "",
    "⋯": "",
    "  fn ": "",
    "\n            const A: &str = ": "",
    ";\n            const B: &str = ": "",
    ";\n        ": "",
    "string": "",
    "punctuation": "",
    "keyword": "",
    "Rust": "",
    "\n                (string_literal) @string\n                ": "",
    " @keyword\n                [": "",
    "] @punctuation\n                ": "",
    "Courier": "",
    "const": "",
    " A": "",
    ":": "",
    " &str = ": "",
    "\\\"\\n    one\\n": "",
    "    two\\n    three\\n\\\"": "",
    ";": "",
    " B": "",
    "\\\"four\\\"": "",
    "\n            struct A {\n                b: usize;\n            }\n            const c: usize = 1;\n        ": "",
    "hi": "",
    "struct A {\\n    b: usize;\\n": "",
    "}": "",
    "\\nconst c: ": "",
    "usize": "",
    " = ": "",
    "1": "",
    ";\\n": "",
    "abcde\\nfghij\\nklmno\\npqrst": "",
    "abcde\\n\\n\\n\\n\\npqrst": "",
    "point_to_display_point({:?}, Bias::Left)": "",
    "point_to_display_point({:?}, Bias::Right)": "",
    "display_point_to_point({:?}, Bias::Left)": "",
    "display_point_to_point({:?}, Bias::Right)": "",
    "fn \\n": "",
    "oute": "",
    "r": "",
    "() \\n{}\\n\\n": "",
    "{}\\n\\n": "",
    "⋯\\n": "",
    "  ": "",
    "i": "",
    "operator": "",
    "\n                ": "",
    " @operator\n                (string_literal) @string\n                ": "",
    "constˇ «a»: B = ": "",
    "const ": "",
    " B = ": "",
    "\\\"c ": "",
    "d": "",
    "\\\"": "",
    "ˇˇα": "",
    "ˇαˇ": "",
    "ˇˇ✋": "",
    "ˇ✋ˇ": "",
    "ˇˇ🍐": "",
    "ˇ🍐ˇ": "",
    "ˇˇ\\t": "",
    "ˇ\\tˇ": "",
    " ˇˇ\\t": "",
    " ˇ\\tˇ": "",
    "   ˇˇ\\t": "",
    "ˇˇ": "",
    "ˇaˇ": "",
    "aˇbˇ": "",
    "aˇαˇ": "",
    "aaa\\nbbb\\nccc\\nddd\\neee\\nfff\\nggg\\nhhh\\niii\\njjj\\nkkk\\nlll": "",
    "✅\\t\\tα\\nβ\\t\\n🏀β\\t\\tγ": "",
    "✅       α\\nβ   \\n🏀β      γ": "",
    "β   \\n🏀β      γ": "",
    "🏀β      γ": "",
    "✅\\t\\t": "",
    "✅       ": "",
    "β\\t": "",
    "β   ": "",
    "🏀β\\t\\t": "",
    "🏀β      ": "",
    "✅      ": "",
    "✅\\t": "",
    "✅ ": "",
    "✅": "",
    "aaa\\n\\t\\tbbb": ""
  },
  "zed/crates/editor/src/editor_settings_controls.rs": {
    "Font": "",
    "Editor": "",
    "Gutter": "",
    "Buffer Font Family": "",
    "buffer-font-family": "",
    "Buffer Font Size": "",
    "buffer-font-size": "",
    "Buffer Font Weight": "",
    "buffer-font-weight": "",
    "Buffer Font Ligatures": "",
    "calt": "",
    "buffer-font-ligatures": "",
    "Inline Git Blame": "",
    "inline-git-blame": "",
    "Line Numbers": "",
    "line-numbers": "",
    "Relative Line Numbers": "",
    "relative-line-numbers": "",
    "Relative": "",
    "Ascending": ""
  },
  "zed/crates/editor/src/editor_tests.rs": {
    "123456": "",
    "editor1": "",
    "edited": "",
    "buffer edited": "",
    "editor2": "",
    "X": "",
    "cd": "",
    "12cd56": "",
    "e": "",
    "12cde6": "",
    "a": "",
    "b": "",
    "ab2cde6": "",
    "abcde": "",
    "à": "",
    "á": "",
    "ä": "",
    "äbcde": "",
    "ā": "",
    "ābcde": "",
    "è": "",
    "ābcdè": "",
    "ę": "",
    "ābcdę": "",
    "XYZ": "",
    "XYZbXYZdXYZ": "",
    "1": "",
    "X1ZbX1ZdX1Z": "",
    "2": "",
    "X2ZbX2ZdX2Z": "",
    "aaaaaa\\nbbbbbb\\ncccccc\\nddddddd\\n": "",
    "aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n": "",
    "\n            one\n            two\n            threeˇ\n            four\n            fiveˇ\n        ": "",
    "\n                impl Foo {\n                    // Hello!\n\n                    fn a() {\n                        1\n                    }\n\n                    fn b() {\n                        2\n                    }\n\n                    fn c() {\n                        3\n                    }\n                }\n            ": "",
    "\n                impl Foo {\n                    // Hello!\n\n                    fn a() {\n                        1\n                    }\n\n                    fn b() {⋯\n                    }\n\n                    fn c() {⋯\n                    }\n                }\n            ": "",
    "\n                impl Foo {⋯\n                }\n            ": "",
    "\n                class Foo:\n                    # Hello!\n\n                    def a():\n                        print(1)\n\n                    def b():\n                        print(2)\n\n                    def c():\n                        print(3)\n            ": "",
    "\n                class Foo:\n                    # Hello!\n\n                    def a():\n                        print(1)\n\n                    def b():⋯\n\n                    def c():⋯\n            ": "",
    "\n                class Foo:⋯\n            ": "",
    "\n                class Foo:\n                    # Hello!\n\n                    def a():\n                        print(1)\n\n                    def b():\n                        print(2)\n\n\n                    def c():\n                        print(3)\n\n\n            ": "",
    "\n                class Foo:\n                    # Hello!\n\n                    def a():\n                        print(1)\n\n                    def b():⋯\n\n\n                    def c():⋯\n\n\n            ": "",
    "\n                class Foo:⋯\n\n\n            ": "",
    "\n                class Foo:\n                    # Hello!\n\n                    def a():\n                        print(1)\n\n                    def b():\n                        print(2)\n\n\n                class Bar:\n                    # World!\n\n                    def a():\n                        print(1)\n\n                    def b():\n                        print(2)\n\n\n            ": "",
    "\n                class Foo:\n                    # Hello!\n\n                    def a():⋯\n\n                    def b():⋯\n\n\n                class Bar:\n                    # World!\n\n                    def a():⋯\n\n                    def b():⋯\n\n\n            ": "",
    "\n                class Foo:⋯\n\n\n                class Bar:⋯\n\n\n            ": "",
    "\\t": "",
    "🟥🟧🟨🟩🟦🟪\\nabcde\\nαβγδε": "",
    "🟥🟧⋯🟦🟪\\nab⋯e\\nαβ⋯ε": "",
    "🟥": "",
    "🟥🟧": "",
    "🟥🟧⋯": "",
    "ab⋯e": "",
    "ab⋯": "",
    "ab": "",
    "α": "",
    "αβ": "",
    "αβ⋯": "",
    "αβ⋯ε": "",
    "": "",
    "ⓐⓑⓒⓓⓔ\\nabcd\\nαβγ\\nabcd\\nⓐⓑⓒⓓⓔ\\n": "",
    "ⓐⓑⓒⓓⓔ": "",
    "abcd": "",
    "αβγ": "",
    "abc\\n  def": "",
    "ab\\n  de": "",
    "\\n": "",
    "thequickbrownfox\\njumpedoverthelazydogs": "",
    "thequickbrownfox\\njumpedoverthelaz\\nydogs": "",
    "c\\n  f": "",
    "use std::str::{foo, bar}\\n\\n  {baz.qux()}": "",
    "use std::ˇstr::{foo, bar}\\n\\n  {ˇbaz.qux()}": "",
    "use stdˇ::str::{foo, bar}\\n\\nˇ  {baz.qux()}": "",
    "use ˇstd::str::{foo, bar}\\nˇ\\n  {baz.qux()}": "",
    "ˇuse std::str::{foo, barˇ}\\n\\n  {baz.qux()}": "",
    "ˇuse std::str::{foo, ˇbar}\\n\\n  {baz.qux()}": "",
    "useˇ std::str::{foo, barˇ}\\n\\n  {baz.qux()}": "",
    "use stdˇ::str::{foo, bar}ˇ\\n\\n  {baz.qux()}": "",
    "use std::ˇstr::{foo, bar}\\nˇ\\n  {baz.qux()}": "",
    "use std::«ˇs»tr::{foo, bar}\\n«ˇ\\n»  {baz.qux()}": "",
    "use std«ˇ::s»tr::{foo, bar«ˇ}\\n\\n»  {baz.qux()}": "",
    "use std::«ˇs»tr::{foo, bar}«ˇ\\n\\n»  {baz.qux()}": "",
    "use one::{\\n    two::three::four::five\\n};": "",
    "use one::{\\n    two::three::\\n    four::five\\n};": "",
    "ˇone\n        two\n\n        three\n        fourˇ\n        five\n\n        six": "",
    "one\n        two\n        ˇ\n        three\n        four\n        five\n        ˇ\n        six": "",
    "one\n        two\n\n        three\n        four\n        five\n        ˇ\n        sixˇ": "",
    "one\n        two\n\n        three\n        four\n        five\n\n        sixˇ": "",
    "one\n        two\n\n        three\n        four\n        five\n        ˇ\n        six": "",
    "one\n        two\n        ˇ\n        three\n        four\n        five\n\n        six": "",
    "ˇone\n        two\n\n        three\n        four\n        five\n\n        six": "",
    "ˇone\n        two\n        three\n        four\n        five\n        six\n        seven\n        eight\n        nine\n        ten\n        ": "",
    "ˇone\n            two\n            three\n            four\n            five\n            six\n            seven\n            eight\n            nine\n            ten\n        ": "",
    "\n        ˇone\n        two\n        threeˇ\n        four\n        five\n        six\n        seven\n        eight\n        nine\n        ten\n        ": "",
    "\n        one\n        two\n        three\n        ˇfour\n        five\n        sixˇ\n        seven\n        eight\n        nine\n        ten\n        ": "",
    "\n        one\n        two\n        three\n        four\n        five\n        six\n        ˇseven\n        eight\n        nineˇ\n        ten\n        ": "",
    "\n        one\n        two\n        three\n        four\n        five\n        six\n        seven\n        eight\n        nine\n        ˇten\n        ˇ": "",
    "one «two threeˇ» four": "",
    " four": "",
    "one two three four": "",
    "e two te four": "",
    "e t te our": "",
    "one\\n2\\nthree\\n4": "",
    "one\\n2\\nthree\\n": "",
    "one\\n2\\nthree": "",
    "one\\n2\\n": "",
    "one\\n2": "",
    "one\\n": "",
    "\\none\\n   two\\nthree\\n   four": "",
    "one\\n   two\\nthree\\n   four": "",
    "\\n   two\\nthree\\n   four": "",
    "two\\nthree\\n   four": "",
    "\\nthree\\n   four": "",
    "\\n   four": "",
    "aaaa\\n    bbbb\\n": "",
    "aa\\naa\\n  \\n    bb\\n    bb\\n": "",
    "\n                a\n                b(\n                    X\n                )\n                c(\n                    X\n                )\n            ": "",
    "\n                    a\n                    b()\n                    c()\n                ": "",
    "\n                a\n                b(\n                )\n                c(\n                )\n            ": "",
    "(_ ": "",
    " ": "",
    " @end) @indent": "",
    "\n        const a: ˇA = (\n            (ˇ\n                «const_functionˇ»(ˇ),\n                so«mˇ»et«hˇ»ing_ˇelse,ˇ\n            )ˇ\n        ˇ);ˇ\n    ": "",
    "\n        ˇ\n        const a: A = (\n            ˇ\n            (\n                ˇ\n                ˇ\n                const_function(),\n                ˇ\n                ˇ\n                ˇ\n                ˇ\n                something_else,\n                ˇ\n            )\n            ˇ\n            ˇ\n        );\n    ": "",
    "\n        const a: A = (\n            ˇ\n            (\n                ˇ\n                const_function(),\n                ˇ\n                ˇ\n                something_else,\n                ˇ\n                ˇ\n                ˇ\n                ˇ\n            )\n            ˇ\n        );\n        ˇ\n        ˇ\n    ": "",
    "// ": "",
    "\n        // Fooˇ\n    ": "",
    "\n        // Foo\n        // ˇ\n    ": "",
    "\n        // Foo\n        //s\n        // ˇ\n    ": "",
    "s": "",
    "\n        // Foo\n        //ˇ\n    ": "",
    "\n        // Foo\n        //\n        // ˇ\n    ": "",
    "\n        ˇ// Foo\n    ": "",
    "\n\n        ˇ// Foo\n    ": "",
    "\n        // Foo\n        ˇ\n    ": "",
    "/// ": "",
    "\n        //ˇ\n    ": "",
    "\n        //\n        // ˇ\n    ": "",
    "\n        ///ˇ\n    ": "",
    "\n        ///\n        /// ˇ\n    ": "",
    "/**": "",
    "*/": "",
    "* ": "",
    "[(line_comment)(block_comment)] @comment.inclusive": "",
    "\n        /**ˇ\n    ": "",
    "\n        /**\n         * ˇ\n    ": "",
    "\n        ˇ/**\n    ": "",
    "\n\n        ˇ/**\n    ": "",
    "\n        /*ˇ*\n    ": "",
    "\n        /*\n        ˇ*\n    ": "",
    "\n        /**ˇ*/\n    ": "",
    "\n        /**\n         * ˇ\n         */\n    ": "",
    "\n        /**ˇ */\n    ": "",
    "\n        /** ˇ*/\n    ": "",
    "\n        /**s\n         * ˇ\n         */\n    ": "",
    "\n        /**s\n         *s\n         * ˇ\n         */\n    ": "",
    "\n        /**\n         *ˇ\n         */\n    ": "",
    "\n        /**\n         *\n         * ˇ\n         */\n    ": "",
    "\n        /**\n        ˇ*/\n    ": "",
    "\n        /**\n\n        ˇ*/\n    ": "",
    "\n        /**ˇ/\n    ": "",
    "\n        /**\n        ˇ/\n    ": "",
    "\n        /** */ˇ\n    ": "",
    "\n        /** */\n        ˇ\n    ": "",
    "\n        /**\n         *\n         */ˇ\n    ": "",
    "\n        /**\n         *\n         */\n         ˇ\n    ": "",
    "\n        /** */ textˇ\n    ": "",
    "\n        /** */ text\n        ˇ\n    ": "",
    "\n        /**\n         *\n         */ˇtext\n    ": "",
    "\n        /**\n         *\n         */\n         ˇtext\n    ": "",
    "\n        * textˇ\n    ": "",
    "\n        * text\n        ˇ\n    ": "",
    "\n        /**\n        ˇ\n    ": "",
    "a( X ), b( Y ), c( Z )": "",
    "a(), b(), c()": "",
    "Z": "",
    "a(Z), b(Z), c(Z)": "",
    "\n        ˇabˇc\n        ˇ🏀ˇ🏀ˇefg\n        dˇ\n    ": "",
    "\n           ˇab ˇc\n           ˇ🏀  ˇ🏀  ˇefg\n        d  ˇ\n    ": "",
    "\n        a\n        «🏀ˇ»🏀«🏀ˇ»🏀«🏀ˇ»\n    ": "",
    "\n        a\n           «🏀ˇ»🏀«🏀ˇ»🏀«🏀ˇ»\n    ": "",
    "\n        const a: B = (\n            c(\n        ˇ\n        ˇ    )\n        );\n    ": "",
    "\n        const a: B = (\n            c(\n                ˇ\n            ˇ)\n        );\n    ": "",
    "\n        ˇ\n        const a: B = (\n            c(\n                d(\n        ˇ\n                )\n        ˇ\n        ˇ    )\n        );\n    ": "",
    "\n        ˇ\n        const a: B = (\n            c(\n                d(\n                    ˇ\n                )\n                ˇ\n            ˇ)\n        );\n    ": "",
    "\n            ˇ\n        const a: B = (\n            c(\n                d(\n                        ˇ\n                )\n                    ˇ\n                ˇ)\n        );\n    ": "",
    "\n        const a: B = (\n            c(\n                d(\n        ˇ\n        ˇ   )\n        ˇ   )\n        );\n    ": "",
    "\n        const a: B = (\n            c(\n                d(\n                    ˇ\n                ˇ)\n            ˇ)\n        );\n    ": "",
    "\n        const a: B = (\n            c(\n                d(\n        ˇ\n        ˇ   )\n           ˇ)\n        );\n    ": "",
    "\n        const a: B = (\n            c(\n                d(\n        ˇ\n        ˇ                )\n        ˇ   )\n        );\n    ": "",
    "\n        const a: B = (\n            c(\n                d(\n                    ˇ\n                        ˇ)\n            ˇ)\n        );\n    ": "",
    "\n        const a: B = (\n            c(\n                d(\n                        ˇ\n                            ˇ)\n                ˇ)\n        );\n    ": "",
    "\n        const a: B = (\n            c(\n                d(\n        ˇ\n        ˇ                )\n            ˇ)\n        );\n    ": "",
    "\n        const a: B = (\n            c(\n        ˇ    ˇ\n        ˇ    )\n        );\n    ": "",
    "\n         ˇ\n        \\t ˇ\n        \\t  ˇ\n        \\t   ˇ\n         \\t  \\t\\t \\t      \\t\\t   \\t\\t    \\t \\t ˇ\n    ": "",
    "\n           ˇ\n        \\t   ˇ\n        \\t   ˇ\n        \\t      ˇ\n         \\t  \\t\\t \\t      \\t\\t   \\t\\t    \\t \\t   ˇ\n    ": "",
    "\n        fn a() {\n            if b {\n        \\t ˇc\n            }\n        }\n    ": "",
    "\n        fn a() {\n            if b {\n                ˇc\n            }\n        }\n    ": "",
    "\n          «oneˇ» «twoˇ»\n        three\n         four\n    ": "",
    "\n            «oneˇ» «twoˇ»\n        three\n         four\n    ": "",
    "\n        «oneˇ» «twoˇ»\n        three\n         four\n    ": "",
    "\n        one two\n        t«hree\n        ˇ» four\n    ": "",
    "\n        one two\n            t«hree\n        ˇ» four\n    ": "",
    "\n        one two\n        ˇthree\n            four\n    ": "",
    "\n        one two\n            ˇthree\n            four\n    ": "",
    "\n        one two\n        ˇ    three\n            four\n    ": "",
    "\n        «oneˇ» «twoˇ»\n        three\n        four\n    ": "",
    "\n        \\t«oneˇ» «twoˇ»\n        three\n        four\n    ": "",
    "\n        \\t\\t«oneˇ» «twoˇ»\n        three\n        four\n    ": "",
    "\n        one two\n        t«hree\n        ˇ»four\n    ": "",
    "\n        one two\n        \\tt«hree\n        ˇ»four\n    ": "",
    "\n        one two\n        \\t\\tt«hree\n        ˇ»four\n    ": "",
    "\n        one two\n        ˇthree\n        four\n    ": "",
    "\n        one two\n        \\tˇthree\n        four\n    ": "",
    "TOML": "",
    "Rust": "",
    "a = 1\\nb = 2\\n": "",
    "const c: usize = 3;\\n": "",
    "\n                a = 1\n                b = 2\n\n                const c: usize = 3;\n            ": "",
    "\n                «aˇ» = 1\n                b = 2\n\n                «const c:ˇ» usize = 3;\n            ": "",
    "\n                  «aˇ» = 1\n                b = 2\n\n                    «const c:ˇ» usize = 3;\n            ": "",
    "\n        onˇe two three\n        fou«rˇ» five six\n        seven «ˇeight nine\n        »ten\n    ": "",
    "\n        oˇe two three\n        fouˇ five six\n        seven ˇten\n    ": "",
    "\n        zero\n            ˇone\n                ˇtwo\n            ˇ ˇ ˇ  three\n        ˇ  ˇ  four\n    ": "",
    "\n        zero\n        ˇone\n            ˇtwo\n        ˇ  threeˇ  four\n    ": "",
    "\n        onˇ two three\n        fouˇ five six\n        seven ˇten\n    ": "",
    "abc\\ndef\\nghi\\n": "",
    "ghi": "",
    "ghi\\n": "",
    "aaa\\nbbb\\nccc\\nddd\\n\\n": "",
    "aaa bbb\\nccc\\nddd\\n\\n": "",
    "aaa bbb ccc ddd\\n\\n": "",
    "aaa bbb\\nccc\\nddd\\n": "",
    "aaa bbb\\nccc\\nddd": "",
    "  ": "",
    "  \\n\\td": "",
    "aaa bbb\\n  c\\n  \\n\\td": "",
    "aaa bbb c\\n  \\n\\td": "",
    "aaa bbb c\\n\\td": "",
    "aaa bbb c d": "",
    "aaa bbb ccc\\nddd\\n": "",
    "\n        Line 0\n        Line 1\n        Line 2\n        Line 3\n        ": "",
    "\n        ˇLine 0\n        Line 1\n        Line 2\n        Line 3\n        ": "",
    "\n        Line 0ˇ Line 1\n        Line 2\n        Line 3\n        ": "",
    "\n        Line 0 Line 1ˇ Line 2\n        Line 3\n        ": "",
    "Line 0\\r\\nLine 1\\rˇ\\nLine 2\\r\\nLine 3": "",
    "Line 0\\r\\nLine 1\\r\\nLine 2\\r\\nLine 3": "",
    "Should not have any diffs for files with custom newlines": "",
    "\n        «z\n        y\n        x\n        Z\n        Y\n        Xˇ»\n    ": "",
    "\n        «x\n        X\n        y\n        Y\n        z\n        Zˇ»\n    ": "",
    "\n        «5\n        4\n        3\n        2\n        1ˇ»\n    ": "",
    "\n        «1\n        2\n        3\n        4\n        5ˇ»\n    ": "",
    "\n        ddˇdd\n        ccc\n        bb\n        a\n    ": "",
    "\n        «ddddˇ»\n        ccc\n        bb\n        a\n    ": "",
    "\n        dd«d\n        ccc\n        bb\n        aaaaaˇ»\n    ": "",
    "\n        «aaaaa\n        bb\n        ccc\n        dddˇ»\n    ": "",
    "\n        dd«d\n        ccc\n\n        bb\n        aaaaa\n\n        ˇ»\n    ": "",
    "\n        «\n\n        aaaaa\n        bb\n        ccc\n        dddˇ»\n\n    ": "",
    "\n        aa«a\n        bbˇ»b\n    ": "",
    "added_line": "",
    "\n        «aaa\n        bbb\n        added_lineˇ»\n    ": "",
    "\n        aa«a\n        bbbˇ»\n    ": "",
    "\n        «aaaˇ»\n    ": "",
    "\n        ˇ\n    ": "",
    "\n        Aaa«aa\n        cˇ»c«c\n        bb\n        aaaˇ»aa\n    ": "",
    "\n        «Aaaaa\n        ccc\n        bb\n        aaaaaˇ»\n    ": "",
    "\n        «Aaaaa\n        ccc\n        bbˇ»\n    ": "",
    "\n        «aaaaa\n        bb\n        aaaaa\n        aaaaaˇ»\n\n        aaa«aaˇ»\n    ": "",
    "\n        «aaaaa\n        bbˇ»\n\n        «aaaaaˇ»\n    ": "",
    "\n        «Aaa\n        aAa\n        Aaaˇ»\n    ": "",
    "\n        «Aaa\n        aAaˇ»\n    ": "",
    "\n        «Aaa\n        aAa\n        aaAˇ»\n    ": "",
    "\n        «Aaaˇ»\n    ": "",
    "\n        dd«dd\n        cˇ»c«c\n        bb\n        aaaˇ»aa\n    ": "",
    "\n        «aaaaa\n        bb\n        ccc\n        ddddˇ»\n    ": "",
    "\n        5«\n        4\n        3\n        2\n        1ˇ»\n\n        dd«dd\n        ccc\n        bb\n        aaaˇ»aa\n    ": "",
    "\n        «1\n        2\n        3\n        4\n        5ˇ»\n\n        «aaaaa\n        bb\n        ccc\n        ddddˇ»\n    ": "",
    "\n        2«\n        1ˇ»\n\n        bb«bb\n        aaaˇ»aa\n    ": "",
    "added line": "",
    "\n        «2\n        1\n        added lineˇ»\n\n        «bbbb\n        aaaaa\n        added lineˇ»\n    ": "",
    "\n        «2ˇ»\n\n        «bbbbˇ»\n    ": "",
    "\n        «hello worldˇ»\n    ": "",
    "\n        «HELLO WORLDˇ»\n    ": "",
    "\n        «hEllo worldˇ»\n    ": "",
    "\n        «The quick brown\n        fox jumps over\n        the lazy dogˇ»\n    ": "",
    "\n        «The Quick Brown\n        Fox Jumps Over\n        The Lazy Dogˇ»\n    ": "",
    "\n        «TheQuickBrown\n        FoxJumpsOver\n        TheLazyDogˇ»\n    ": "",
    "\n        ˇhello big beauˇtiful worldˇ\n    ": "",
    "\n        «HELLOˇ» big «BEAUTIFULˇ» «WORLDˇ»\n    ": "",
    "\n        «Theˇ» quick «brown\n        foxˇ» jumps «overˇ»\n        the «lazyˇ» dog\n    ": "",
    "\n        «THEˇ» quick «BROWN\n        FOXˇ» jumps «OVERˇ»\n        the «LAZYˇ» dog\n    ": "",
    "\n        «tschüßˇ»\n    ": "",
    "\n        «TSCHÜSSˇ»\n    ": "",
    "\n        aaa_bbbˇ\n    ": "",
    "\n        «aaaBbbˇ»\n    ": "",
    "\n        aaa_bˇbb bbˇb_ccc ˇccc_ddd\n    ": "",
    "\n        «aaaBbbˇ» «bbbCccˇ» «cccDddˇ»\n    ": "",
    "\n        «hElLo, WoRld!ˇ»\n    ": "",
    "\n        «HeLlO, wOrLD!ˇ»\n    ": "",
    "abc\\nabc\\ndef\\ndef\\nghi\\n\\n": "",
    "abc\\ndef\\nghi\\nabc\\ndef\\nghi\\n": "",
    "abc\\ndbc\\ndef\\ngf\\nghi\\n": "",
    "aa⋯bbb\\nccc⋯eeee\\nfffff\\nggggg\\n⋯i\\njjjjj": "",
    "aa⋯bbb\\nccc⋯eeee\\nggggg\\n⋯i\\njjjjj\\nfffff": "",
    "ccc⋯eeee\\naa⋯bbb\\nfffff\\nggggg\\n⋯i\\njjjjj": "",
    "ccc⋯eeee\\nfffff\\naa⋯bbb\\nggggg\\n⋯i\\njjjjj": "",
    "ccc⋯eeee\\naa⋯bbb\\nggggg\\n⋯i\\njjjjj\\nfffff": "",
    "\n            ˇzero\n            one\n            two\n            three\n            four\n            five\n        ": "",
    "\n            zero\n            «one\n            two\n            threeˇ»\n            four\n            five\n        ": "",
    "\n            zero\n            one\n            two\n            three\n            ˇfour\n            five\n        ": "",
    "abc": "",
    "bac": "",
    "bca": "",
    "abc\\nde": "",
    "acb\\nde": "",
    "acbd\\ne": "",
    "acbde\\n": "",
    "bacd\\ne": "",
    "bcade\\n": "",
    "bcda\\ne": "",
    "bcaed\\n": "",
    "🍐🏀✋": "",
    "🏀🍐✋": "",
    "🏀✋🍐": "",
    "Markdown": "",
    "Plain Text": "",
    "# ": "",
    "\n            // ˇLorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus mollis elit purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus auctor, eu lacinia sapien scelerisque. Vivamus sit amet neque et quam tincidunt hendrerit. Praesent semper egestas tellus id dignissim. Pellentesque odio lectus, iaculis ac volutpat et, blandit quis urna. Sed vestibulum nisi sit amet nisl venenatis tempus. Donec molestie blandit quam, et porta nunc laoreet in. Integer sit amet scelerisque nisi. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras egestas porta metus, eu viverra ipsum efficitur quis. Donec luctus eros turpis, id vulputate turpis porttitor id. Aliquam id accumsan eros.\n        ": "",
    "\n            // ˇLorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus mollis elit\n            // purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus\n            // auctor, eu lacinia sapien scelerisque. Vivamus sit amet neque et quam\n            // tincidunt hendrerit. Praesent semper egestas tellus id dignissim.\n            // Pellentesque odio lectus, iaculis ac volutpat et, blandit quis urna. Sed\n            // vestibulum nisi sit amet nisl venenatis tempus. Donec molestie blandit quam,\n            // et porta nunc laoreet in. Integer sit amet scelerisque nisi. Lorem ipsum\n            // dolor sit amet, consectetur adipiscing elit. Cras egestas porta metus, eu\n            // viverra ipsum efficitur quis. Donec luctus eros turpis, id vulputate turpis\n            // porttitor id. Aliquam id accumsan eros.\n        ": "",
    "\n            «// Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus mollis elit purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus auctor, eu lacinia sapien scelerisque. Vivamus sit amet neque et quam tincidunt hendrerit. Praesent semper egestas tellus id dignissim. Pellentesque odio lectus, iaculis ac volutpat et, blandit quis urna. Sed vestibulum nisi sit amet nisl venenatis tempus. Donec molestie blandit quam, et porta nunc laoreet in. Integer sit amet scelerisque nisi. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras egestas porta metus, eu viverra ipsum efficitur quis. Donec luctus eros turpis, id vulputate turpis porttitor id. Aliquam id accumsan eros.ˇ»\n        ": "",
    "\n            «// Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus mollis elit\n            // purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus\n            // auctor, eu lacinia sapien scelerisque. Vivamus sit amet neque et quam\n            // tincidunt hendrerit. Praesent semper egestas tellus id dignissim.\n            // Pellentesque odio lectus, iaculis ac volutpat et, blandit quis urna. Sed\n            // vestibulum nisi sit amet nisl venenatis tempus. Donec molestie blandit quam,\n            // et porta nunc laoreet in. Integer sit amet scelerisque nisi. Lorem ipsum\n            // dolor sit amet, consectetur adipiscing elit. Cras egestas porta metus, eu\n            // viverra ipsum efficitur quis. Donec luctus eros turpis, id vulputate turpis\n            // porttitor id. Aliquam id accumsan eros.ˇ»\n        ": "",
    "\n            // ˇLorem ipsum dolor sit amet, consectetur adipiscing elit.\n            // ˇVivamus mollis elit purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus auctor, eu lacinia sapien scelerisque.\n            // ˇVivamus sit amet neque et quam tincidunt hendrerit. Praesent semper egestas tellus id dignissim. Pellentesque odio lectus, iaculis ac volutpat et,\n            // ˇblandit quis urna. Sed vestibulum nisi sit amet nisl venenatis tempus. Donec molestie blandit quam, et porta nunc laoreet in. Integer sit amet scelerisque nisi. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras egestas porta metus, eu viverra ipsum efficitur quis. Donec luctus eros turpis, id vulputate turpis porttitor id. Aliquam id accumsan eros.\n        ": "",
    "\n            // ˇLorem ipsum dolor sit amet, consectetur adipiscing elit. ˇVivamus mollis elit\n            // purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus\n            // auctor, eu lacinia sapien scelerisque. ˇVivamus sit amet neque et quam\n            // tincidunt hendrerit. Praesent semper egestas tellus id dignissim.\n            // Pellentesque odio lectus, iaculis ac volutpat et, ˇblandit quis urna. Sed\n            // vestibulum nisi sit amet nisl venenatis tempus. Donec molestie blandit quam,\n            // et porta nunc laoreet in. Integer sit amet scelerisque nisi. Lorem ipsum\n            // dolor sit amet, consectetur adipiscing elit. Cras egestas porta metus, eu\n            // viverra ipsum efficitur quis. Donec luctus eros turpis, id vulputate turpis\n            // porttitor id. Aliquam id accumsan eros.\n        ": "",
    "\n            // ˇLorem ipsum dolor sit amet, consectetur adipiscing elit.\n            // ˇVivamus mollis elit purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus auctor, eu lacinia sapien scelerisque.\n            //\n            // ˇVivamus sit amet neque et quam tincidunt hendrerit. Praesent semper egestas tellus id dignissim. Pellentesque odio lectus, iaculis ac volutpat et,\n            // ˇblandit quis urna. Sed vestibulum nisi sit amet nisl venenatis tempus. Donec molestie blandit quam, et porta nunc laoreet in. Integer sit amet scelerisque nisi. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras egestas porta metus, eu viverra ipsum efficitur quis. Donec luctus eros turpis, id vulputate turpis porttitor id. Aliquam id accumsan eros.\n        ": "",
    "\n            // ˇLorem ipsum dolor sit amet, consectetur adipiscing elit. ˇVivamus mollis elit\n            // purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus\n            // auctor, eu lacinia sapien scelerisque.\n            //\n            // ˇVivamus sit amet neque et quam tincidunt hendrerit. Praesent semper egestas\n            // tellus id dignissim. Pellentesque odio lectus, iaculis ac volutpat et,\n            // ˇblandit quis urna. Sed vestibulum nisi sit amet nisl venenatis tempus. Donec\n            // molestie blandit quam, et porta nunc laoreet in. Integer sit amet scelerisque\n            // nisi. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras egestas\n            // porta metus, eu viverra ipsum efficitur quis. Donec luctus eros turpis, id\n            // vulputate turpis porttitor id. Aliquam id accumsan eros.\n        ": "",
    "\n            # ˇLorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus mollis elit purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus auctor, eu lacinia sapien scelerisque. Vivamus sit amet neque et quam tincidunt hendrerit. Praesent semper egestas tellus id dignissim. Pellentesque odio lectus, iaculis ac volutpat et, blandit quis urna. Sed vestibulum nisi sit amet nisl venenatis tempus. Donec molestie blandit quam, et porta nunc laoreet in. Integer sit amet scelerisque nisi. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras egestas porta metus, eu viverra ipsum efficitur quis. Donec luctus eros turpis, id vulputate turpis porttitor id. Aliquam id accumsan eros.\n        ": "",
    "\n            # ˇLorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus mollis elit\n            # purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus auctor,\n            # eu lacinia sapien scelerisque. Vivamus sit amet neque et quam tincidunt\n            # hendrerit. Praesent semper egestas tellus id dignissim. Pellentesque odio\n            # lectus, iaculis ac volutpat et, blandit quis urna. Sed vestibulum nisi sit\n            # amet nisl venenatis tempus. Donec molestie blandit quam, et porta nunc laoreet\n            # in. Integer sit amet scelerisque nisi. Lorem ipsum dolor sit amet, consectetur\n            # adipiscing elit. Cras egestas porta metus, eu viverra ipsum efficitur quis.\n            # Donec luctus eros turpis, id vulputate turpis porttitor id. Aliquam id\n            # accumsan eros.\n        ": "",
    "\n            /// Adds two numbers.\n            /// Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus mollis elit purus, a ornare lacus gravida vitae.ˇ\n            fn add(a: u32, b: u32) -> u32 {\n                a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + bˇ\n            }\n        ": "",
    "\n            /// Adds two numbers. Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n            /// Vivamus mollis elit purus, a ornare lacus gravida vitae.ˇ\n            fn add(a: u32, b: u32) -> u32 {\n                a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + b + a + bˇ\n            }\n        ": "",
    "\n            # Hello\n\n            Lorem ipsum dolor sit amet, ˇconsectetur adipiscing elit. Vivamus mollis elit purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus auctor, eu lacinia sapien scelerisque. Vivamus sit amet neque et quam tincidunt hendrerit. Praesent semper egestas tellus id dignissim. Pellentesque odio lectus, iaculis ac volutpat et, blandit quis urna. Sed vestibulum nisi sit amet nisl venenatis tempus. Donec molestie blandit quam, et porta nunc laoreet in. Integer sit amet scelerisque nisi.\n        ": "",
    "\n            # Hello\n\n            Lorem ipsum dolor sit amet, ˇconsectetur adipiscing elit. Vivamus mollis elit\n            purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus auctor,\n            eu lacinia sapien scelerisque. Vivamus sit amet neque et quam tincidunt\n            hendrerit. Praesent semper egestas tellus id dignissim. Pellentesque odio\n            lectus, iaculis ac volutpat et, blandit quis urna. Sed vestibulum nisi sit amet\n            nisl venenatis tempus. Donec molestie blandit quam, et porta nunc laoreet in.\n            Integer sit amet scelerisque nisi.\n        ": "",
    "\n            Lorem ipsum dolor sit amet, ˇconsectetur adipiscing elit. Vivamus mollis elit purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus auctor, eu lacinia sapien scelerisque. Vivamus sit amet neque et quam tincidunt hendrerit. Praesent semper egestas tellus id dignissim. Pellentesque odio lectus, iaculis ac volutpat et, blandit quis urna. Sed vestibulum nisi sit amet nisl venenatis tempus. Donec molestie blandit quam, et porta nunc laoreet in. Integer sit amet scelerisque nisi.\n        ": "",
    "\n            Lorem ipsum dolor sit amet, ˇconsectetur adipiscing elit. Vivamus mollis elit\n            purus, a ornare lacus gravida vitae. Proin consectetur felis vel purus auctor,\n            eu lacinia sapien scelerisque. Vivamus sit amet neque et quam tincidunt\n            hendrerit. Praesent semper egestas tellus id dignissim. Pellentesque odio\n            lectus, iaculis ac volutpat et, blandit quis urna. Sed vestibulum nisi sit amet\n            nisl venenatis tempus. Donec molestie blandit quam, et porta nunc laoreet in.\n            Integer sit amet scelerisque nisi.\n        ": "",
    "\n            fn foo() {\n                if true {\n            «        // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus mollis elit purus, a ornare lacus gravida vitae.\n            // Praesent semper egestas tellus id dignissim.ˇ»\n                    do_something();\n                } else {\n                    //\n                }\n            }\n        ": "",
    "\n            fn foo() {\n                if true {\n            «        // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus\n                    // mollis elit purus, a ornare lacus gravida vitae. Praesent semper\n                    // egestas tellus id dignissim.ˇ»\n                    do_something();\n                } else {\n                    //\n                }\n            }\n        ": "",
    "\n            fn foo() {\n                if true {\n            «ˇ        // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus mollis elit purus, a ornare lacus gravida vitae.\n            // Praesent semper egestas tellus id dignissim.»\n                    do_something();\n                } else {\n                    //\n                }\n\n            }\n        ": "",
    "\n            fn foo() {\n                if true {\n            «ˇ        // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus\n                    // mollis elit purus, a ornare lacus gravida vitae. Praesent semper\n                    // egestas tellus id dignissim.»\n                    do_something();\n                } else {\n                    //\n                }\n\n            }\n        ": "",
    "\n            «ˇone one one one one one one one one one one one one one one one one one one one one one one one one\n\n            two»\n\n            three\n\n            «ˇ\\t\n\n            four four four four four four four four four four four four four four four four four four four four»\n\n            «ˇfive five five five five five five five five five five five five five five five five five five five\n            \\t»\n            six six six six six six six six six six six six six six six six six six six six six six six six six\n        ": "",
    "\n            «ˇone one one one one one one one one one one one one one one one one one one one\n            one one one one one\n\n            two»\n\n            three\n\n            «ˇ\\t\n\n            four four four four four four four four four four four four four four four four\n            four four four four»\n\n            «ˇfive five five five five five five five five five five five five five five five\n            five five five five\n            \\t»\n            six six six six six six six six six six six six six six six six six six six six six six six six six\n        ": "",
    "\n            //ˇ long long long long long long long long long long long long long long long long long long long long long long long long long long long long\n            //ˇ\n            //ˇ long long long long long long long long long long long long long long long long long long long long long long long long long long long long\n            //ˇ short short short\n            int main(void) {\n                return 17;\n            }\n        ": "",
    "\n            //ˇ long long long long long long long long long long long long long long long\n            // long long long long long long long long long long long long long\n            //ˇ\n            //ˇ long long long long long long long long long long long long long long long\n            //ˇ long long long long long long long long long long long long long short short\n            // short\n            int main(void) {\n                return 17;\n            }\n        ": "",
    "\n        one two three ˇ\n        ": "",
    "four": "",
    "\n        one two three\n        fourˇ\n        ": "",
    "\n        one two three\n        four\n        ˇ\n        ": "",
    "five": "",
    "\n        one two three\n        four\n        fiveˇ\n        ": "",
    "\n        one two three\n        four\n        five\n        # ˇ\n        ": "",
    "\n        one two three\n        four\n        five\n        #\\x20\n        #ˇ\n        ": "",
    " 6": "",
    "\n        one two three\n        four\n        five\n        #\n        # 6ˇ\n        ": "",
    "«one✅ ˇ»two «three ˇ»four «five ˇ»six ": "",
    "ˇtwo ˇfour ˇsix ": "",
    "two ˇfour ˇsix ˇ": "",
    "two one✅ ˇfour three ˇsix five ˇ": "",
    "ˇtwo one✅ four three six five ˇ": "",
    "( ": "",
    ") ": "",
    "( one✅ ": "",
    "three ": "",
    "five ) ˇtwo one✅ four three six five ( one✅ ": "",
    "five ) ˇ": "",
    "\n        1«2ˇ»3\n        4ˇ567\n        «8ˇ»9": "",
    "\n        1ˇ3\n        ˇ9": "",
    "\n        1ˇ3\n        9ˇ\n        «oˇ»ne": "",
    "\n        12ˇ3\n        4567\n        9ˇ\n        8ˇne": "",
    "\n        The quick brown\n        fox juˇmps over\n        the lazy dog": "",
    "fox jumps over\\n": "",
    "\n        Tˇhe quick brown\n        «foˇ»x jumps over\n        tˇhe lazy dog": "",
    "\n        fox jumps over\n        Tˇhe quick brown\n        fox jumps over\n        ˇx jumps over\n        fox jumps over\n        tˇhe lazy dog": "",
    "            «for selection in selections.iter() {\n            let mut start = selection.start;\n            let mut end = selection.end;\n            let is_entire_line = selection.is_empty();\n            if is_entire_line {\n                start = Point::new(start.row, 0);ˇ»\n                end = cmp::min(max_point, Point::new(end.row + 1, 0));\n            }\n        ": "",
    "for selection in selections.iter() {\n            let mut start = selection.start;\n            let mut end = selection.end;\n            let is_entire_line = selection.is_empty();\n            if is_entire_line {\n                start = Point::new(start.row, 0);": "",
    "Regular copying preserves all indentation selected": "",
    "for selection in selections.iter() {\nlet mut start = selection.start;\nlet mut end = selection.end;\nlet is_entire_line = selection.is_empty();\nif is_entire_line {\n    start = Point::new(start.row, 0);": "",
    "Copying with stripping should strip all leading whitespaces": "",
    "       «     for selection in selections.iter() {\n            let mut start = selection.start;\n            let mut end = selection.end;\n            let is_entire_line = selection.is_empty();\n            if is_entire_line {\n                start = Point::new(start.row, 0);ˇ»\n                end = cmp::min(max_point, Point::new(end.row + 1, 0));\n            }\n        ": "",
    "     for selection in selections.iter() {\n            let mut start = selection.start;\n            let mut end = selection.end;\n            let is_entire_line = selection.is_empty();\n            if is_entire_line {\n                start = Point::new(start.row, 0);": "",
    "Copying with stripping should strip all leading whitespaces, even if some of it was selected": "",
    "       «ˇ     for selection in selections.iter() {\n            let mut start = selection.start;\n            let mut end = selection.end;\n            let is_entire_line = selection.is_empty();\n            if is_entire_line {\n                start = Point::new(start.row, 0);»\n                end = cmp::min(max_point, Point::new(end.row + 1, 0));\n            }\n        ": "",
    "Regular copying for reverse selection works the same": "",
    "Copying with stripping for reverse selection works the same": "",
    "            for selection «in selections.iter() {\n            let mut start = selection.start;\n            let mut end = selection.end;\n            let is_entire_line = selection.is_empty();\n            if is_entire_line {\n                start = Point::new(start.row, 0);ˇ»\n                end = cmp::min(max_point, Point::new(end.row + 1, 0));\n            }\n        ": "",
    "in selections.iter() {\n            let mut start = selection.start;\n            let mut end = selection.end;\n            let is_entire_line = selection.is_empty();\n            if is_entire_line {\n                start = Point::new(start.row, 0);": "",
    "When selecting past the indent, the copying works as usual": "",
    "When selecting past the indent, nothing is trimmed": "",
    "            «for selection in selections.iter() {\n            let mut start = selection.start;\n\n            let mut end = selection.end;\n            let is_entire_line = selection.is_empty();\n            if is_entire_line {\n                start = Point::new(start.row, 0);\nˇ»                end = cmp::min(max_point, Point::new(end.row + 1, 0));\n            }\n        ": "",
    "for selection in selections.iter() {\nlet mut start = selection.start;\n\nlet mut end = selection.end;\nlet is_entire_line = selection.is_empty();\nif is_entire_line {\n    start = Point::new(start.row, 0);\n": "",
    "Copying with stripping should ignore empty lines": "",
    "\n        const a: B = (\n            c(),\n            «d(\n                e,\n                f\n            )ˇ»\n        );\n    ": "",
    "\n        const a: B = (\n            c(),\n            ˇ\n        );\n    ": "",
    "\n        const a: B = (\n            c(),\n            d(\n                e,\n                f\n            )ˇ\n        );\n    ": "",
    "\n        ˇ\n        const a: B = (\n            c(),\n        );\n    ": "",
    "\n        d(\n            e,\n            f\n        )ˇ\n        const a: B = (\n            c(),\n        );\n    ": "",
    "\n        const a: B = (\n            c(),\n        «    d(\n                e,\n                f\n            )\n        ˇ»);\n    ": "",
    "\n        const a: B = (\n            c(),\n        ˇ);\n    ": "",
    "\n        const a: B = (\n            c(),\n            d(\n                e,\n                f\n            )\n        ˇ);\n    ": "",
    "\n        const a: B = (\n            c(),\n            d(\n                e,\n                fˇ\n            )\n        );\n    ": "",
    "\n        const a: B = (\n            c(),\n            d(\n                e,\n                f    d(\n                    e,\n                    f\n                )\n        ˇ\n            )\n        );\n    ": "",
    "\n        const a: B = (\n            c(),\n            somethin«g(\n                e,\n                f\n            )ˇ»\n        );\n    ": "",
    "\n        const a: B = (\n            c(),\n            something(\n                e,\n                f\n            )\n        );\n        g(\n            e,\n            f\n        )ˇ": "",
    "    d(\\n        e\\n    );\\n": "",
    "\n        fn a() {\n            b();\n            if c() {\n                ˇ\n            }\n        }\n    ": "",
    "\n        fn a() {\n            b();\n            if c() {\n                d(\n                    e\n                );\n        ˇ\n            }\n        }\n    ": "",
    "\n        fn a() {\n            b();\n            ˇ\n        }\n    ": "",
    "\n        fn a() {\n            b();\n            d(\n                e\n            );\n        ˇ\n        }\n    ": "",
    "abc\\nde\\nfgh": "",
    "aa\\nb«ˇb\\ncc\\ndd\\ne»e\\nff": "",
    "aa\\nbbˇ\\nccˇ\\nddˇ\\neˇe\\nff": "",
    "aa\\nb«b\\ncc\\ndd\\neˇ»e\\nff": "",
    "«ˇaa\\nbb\\ncc\\ndd\\nee\\nff»": "",
    "aaˇ\\nbbˇ\\nccˇ\\nddˇ\\neeˇ\\nffˇ": "",
    "«aa\\nbb\\ncc\\ndd\\nee\\nffˇ»": "",
    "«ˇaa\\nbb\\ncc\\ndd\\nee\\nff\\n»": "",
    "aaˇ\\nbbˇ\\nccˇ\\nddˇ\\neeˇ\\nffˇ\\n": "",
    "«aa\\nbb\\ncc\\ndd\\nee\\nff\\nˇ»": "",
    "aa\\nbb«ˇ\\ncc\\ndd\\nee\\n»ff\\n": "",
    "aa\\nbbˇ\\nccˇ\\nddˇ\\neeˇ\\nff\\n": "",
    "aa⋯bbb\\nccc⋯eeee\\nfffff\\nggggg\\n⋯i": "",
    "aaaaa\\nbbbbb\\nccc⋯eeee\\nfffff\\nggggg\\n⋯i": "",
    "aˇaˇaaa\\nbbbbb\\nˇccccc\\nddddd\\neeeee\\nfffff\\nggggg\\nhhhhh\\niiiiiˇ": "",
    "aaaaa\\nbbbbb\\nccccc\\nddddd\\neeeee\\nfffff\\nggggg\\nhhhhh\\niiiii": "",
    "aaaaaˇ\\nbbbbbˇ\\ncccccˇ\\ndddddˇ\\neeeeeˇ\\nfffffˇ\\ngggggˇ\\nhhhhh\\niiiii": "",
    "abc\n           defˇghi\n\n           jk\n           nlmo\n           ": "",
    "abcˇ\n           defˇghi\n\n           jk\n           nlmo\n           ": "",
    "abcˇ\n            defˇghi\n\n            jk\n            nlmo\n            ": "",
    "abc\n           defˇghi\n           ˇ\n           jk\n           nlmo\n           ": "",
    "abc\n           defˇghi\n           ˇ\n           jkˇ\n           nlmo\n           ": "",
    "abc\n           defˇghi\n           ˇ\n           jkˇ\n           nlmˇo\n           ": "",
    "abc\n           defˇghi\n           ˇ\n           jkˇ\n           nlmˇo\n           ˇ": "",
    "abc\n           def«ˇg»hi\n\n           jk\n           nlmo\n           ": "",
    "abc\n           def«ˇg»hi\n\n           jk\n           nlm«ˇo»\n           ": "",
    "a«bc\n           defgˇ»hi\n\n           jk\n           nlmo\n           ": "",
    "a«bcˇ»\n           d«efgˇ»hi\n\n           j«kˇ»\n           nlmo\n           ": "",
    "a«bcˇ»\n           d«efgˇ»hi\n\n           j«kˇ»\n           n«lmoˇ»\n           ": "",
    "abc\n           d«ˇefghi\n\n           jk\n           nlm»o\n           ": "",
    "a«ˇbc»\n           d«ˇef»ghi\n\n           j«ˇk»\n           n«ˇlm»o\n           ": "",
    "abc\n           d«ˇef»ghi\n\n           j«ˇk»\n           n«ˇlm»o\n           ": "",
    "line onˇe\n           liˇne two\n           line three\n           line four": "",
    "line onˇe\n           liˇne twˇo\n           liˇne three\n           line four": "",
    "line onˇe\n           liˇne twˇo\n           liˇne thˇree\n           liˇne foˇur": "",
    "line onˇe\n           liˇne twˇo\n           liˇne thˇree\n           line four": "",
    "liˇne onˇe\n           liˇne two\n           line three\n           line four": "",
    "line onˇe\n           liˇne twˇo\n           line three\n           line four": "",
    "abcd\n           ef«ghˇ»\n           ijkl\n           «mˇ»nop": "",
    "ab«cdˇ»\n           ef«ghˇ»\n           «iˇ»jkl\n           «mˇ»nop": "",
    "ab«cdˇ»\n           «eˇ»f«ghˇ»\n           «iˇ»jkl\n           «mˇ»nop": "",
    "abcd\n           ef«ghˇ»\n           «iˇ»jkl\n           «mˇ»nop": "",
    "abcd\n           ef«ghˇ»\n           ij«klˇ»\n           «mˇ»nop": "",
    "line onˇe\n           liˇne twˇo\n           liˇneˇ thˇree\n           liˇne foˇur": "",
    "line onˇe\n           liˇneˇ twˇo\n           liˇneˇ thˇree\n           line four": "",
    "lineˇ onˇe\n           liˇneˇ twˇo\n           lineˇ three\n           line four": "",
    "ab«cdˇ»\n           «eˇ»f«ghˇ»\n           «iˇ»jk«lˇ»\n           «mˇ»nop": "",
    "abcd\n           ef«ghˇ»\n           «iˇ»jk«lˇ»\n           «mˇ»no«pˇ»": "",
    "abc\\nˇabc abc\\ndefabc\\nabc": "",
    "abc\\n«abcˇ» abc\\ndefabc\\nabc": "",
    "abc\\n«abcˇ» «abcˇ»\\ndefabc\\nabc": "",
    "abc\\n«abcˇ» «abcˇ»\\ndefabc\\n«abcˇ»": "",
    "«abcˇ»\\n«abcˇ» «abcˇ»\\ndefabc\\n«abcˇ»": "",
    "abc\\n«ˇabc» abc\\ndefabc\\nabc": "",
    "abc\\n«ˇabc» «ˇabc»\\ndefabc\\nabc": "",
    "abc\\n«abcˇ»\\nabc": "",
    "«abcˇ»\\n«abcˇ»\\n«abcˇ»": "",
    "abc\\n«ˇabc»\\nabc": "",
    "«ˇabc»\\n«ˇabc»\\n«ˇabc»": "",
    "abc\\nˇ   abc\\nabc": "",
    "abc\\n«   ˇ»abc\\nabc": "",
    "abc\\n«ˇ  »abc\\nabc": "",
    "abc\\n«  ˇ»abc\\nabc": "",
    "\\nd": "",
    "\\ne": "",
    "abc\\nabc{large_body_1} «ˇa»bc{large_body_2}\\nefabc\\nabc": "",
    "Initial selection is between two large bodies and should have the editor scrolled to it": "",
    "«ˇa»bc\\n«ˇa»bc{large_body_1} «ˇa»bc{large_body_2}\\nef«ˇa»bc\\n«ˇa»bc": "",
    "Scroll position should not change after selecting all matches": "",
    "\n        line 1\n        line 2\n        linˇe 3\n        line 4\n        line 5\n    ": "",
    "\n        line 1\n        line 2\n        linXe 3\n        line 4\n        liˇne 5\n    ": "",
    "PREFIX ": "",
    "\n        PREFIX line 1\n        line 2\n        linXe 3\n        line 4\n        liˇne 5\n    ": "",
    "\n        line 1\n        line 2\n        linXˇe 3\n        line 4\n        line 5\n    ": "",
    "\n        line 1\n        line 2\n        linˇe 3\n        line 4\n        line 5\n        line 6\n        line 7\n        line 8\n        line 9\n        line 10\n    ": "",
    "\n        line 1\n        line 2\n        lineXˇ 3\n        line 4\n        line 5\n        line 6\n        line 7\n        line 8\n        line 9\n        line 10\n    ": "",
    "\n        line 1\n        line 2\n        lineX 3\n        line 4\n        line 5\n        line 6\n        line 7\n        line 8\n        line 9\n        liˇne 10\n    ": "",
    "\n        line 1\n        line 2\n        lineˇ 3\n        line 4\n        line 5\n        line 6\n        line 7\n        line 8\n        line 9\n        line 10\n    ": "",
    "let foo = 2;\nlˇet foo = 2;\nlet fooˇ = 2;\nlet foo = 2;\nlet foo = ˇ2;": "",
    "let foo = 2;\n«letˇ» foo = 2;\nlet «fooˇ» = 2;\nlet foo = 2;\nlet foo = «2ˇ»;": "",
    "let foo = 2;\nlet foo = 2;\nlet «fooˇ» = 2;\nlet «ˇfoo» = 2;\nlet foo = 2;": "",
    "let foo = 2;\nlet foo = 2;\nlet «fooˇ» = 2;\nlet «ˇfoo» = 2;\nlet «ˇfoo» = 2;": "",
    "aaa\\n«bbb\\nccc\\n»ddd": "",
    "\n        ˇbbb\n        ccc\n\n        bbb\n        ccc\n        ": "",
    "\n                «bbbˇ»\n                ccc\n\n                bbb\n                ccc\n                ": "",
    "\n                «bbbˇ»\n                ccc\n\n                «bbbˇ»\n                ccc\n                ": "",
    "«abcˇ»\\n«abcˇ» abc\\ndefabc\\nabc": "",
    "«abcˇ»\\n«abcˇ» abc\\ndefabc\\n«abcˇ»": "",
    "aˇ": "",
    "«aˇ»": "",
    "«ˇabc»\\n«ˇabc» abc\\ndefabc\\nabc": "",
    "«ˇabc»\\n«ˇabc» abc\\ndefabc\\n«ˇabc»": "",
    "«ˇabc»\\n«ˇabc» abc\\ndef«ˇabc»\\n«ˇabc»": "",
    "«ˇabc»\\n«ˇabc» «ˇabc»\\ndef«ˇabc»\\n«ˇabc»": "",
    "\n        use mod1::mod2::{mod3, mod4};\n\n        fn fn_1(param1: bool, param2: &str) {\n            let var1 = ": "",
    ";\n        }\n    ": "",
    "\n                use mod1::mod2::{mod3, «mod4ˇ»};\n\n                fn fn_1«ˇ(param1: bool, param2: &str)» {\n                    let var1 = ": "",
    ";\n                }\n            ": "",
    "\n                use mod1::mod2::«{mod3, mod4}ˇ»;\n\n                «ˇfn fn_1(param1: bool, param2: &str) {\n                    let var1 = ": "",
    ";\n                }»\n            ": "",
    "\n                use mod1::mod2::{mod3, mo«ˇ»d4};\n\n                fn fn_1(para«ˇm1: bool, pa»ram2: &str) {\n                    let var1 = ": "",
    "\n                use mod1::mod2::«{mod3, mod4}ˇ»;\n\n                fn fn_1«ˇ(param1: bool, param2: &str)» {\n                    let var1 = ": "",
    "let a = 2;": "",
    "let aˇ = 2;": "",
    "let «ˇa» = 2;": "",
    "«ˇlet a = 2;»": "",
    "let a = 2;ˇ": "",
    "\n                use mod1::mod2::{mod3, mod4};\n\n                fn fn_1(param1: bool, param2: &str) {\n                    let var1 = ": "",
    "\n                use mod1::mod2::{mod3, mod4};\n\n                fn fn_1(param1: bool, param2: &str) {\n                    «ˇlet var1 = ": "",
    ";»\n                }\n            ": "",
    "\n        impl A {\n            // this is an uncommitted comment\n\n            fn b() {\n                c();\n            }\n\n            // this is another uncommitted comment\n\n            fn d() {\n                // e\n                // f\n            }\n        }\n\n        fn g() {\n            // h\n        }\n    ": "",
    "\n        ˇimpl A {\n\n            fn b() {\n                c();\n            }\n\n            fn d() {\n                // e\n                // f\n            }\n        }\n\n        fn g() {\n            // h\n        }\n    ": "",
    "\n        ˇimpl A {\n      -     // this is an uncommitted comment\n\n            fn b() {\n                c();\n            }\n\n      -     // this is another uncommitted comment\n      -\n            fn d() {\n                // e\n                // f\n            }\n        }\n\n        fn g() {\n            // h\n        }\n    ": "",
    "\n        impl A {\n            // this is an uncommitted comment\n\n            fn b() {\n                ⋯\n            }\n\n            // this is another uncommitted comment\n\n            fn d() {\n                ⋯\n            }\n        }\n\n        fn g() {\n            ⋯\n        }\n        ": "",
    "{": "",
    "}": "",
    "(": "",
    ")": "",
    "\n                (_ ": "",
    " @end) @indent\n                (_ ": "",
    " @end) @indent\n            ": "",
    "fn a() {}": "",
    "fn a(\\n    \\n) {\\n    \\n}\\n": "",
    "\n            impl A {\n\n                fn b() {}\n\n            «fn c() {\n\n            }ˇ»\n            }\n        ": "",
    "\n            impl A {\n\n                fn b() {}\n\n                «fn c() {\n\n                }ˇ»\n            }\n        ": "",
    "\n                impl A {\n                «\n                // a\n                fn b(){}\n                »\n                «\n                    }\n                    fn c(){}\n                »\n            ": "",
    "\n                    impl A {\n\n                        // a\n                        fn b(){}\n\n\n                    }\n                    fn c(){}\n\n                ": "",
    "/*": "",
    " */": "",
    "[": "",
    "]": "",
    "\\\"": "",
    "<": "",
    ">": "",
    "})]": "",
    "\n            🏀ˇ\n            εˇ\n            ❤️ˇ\n        ": "",
    "\n            🏀{{{ˇ}}}\n            ε{{{ˇ}}}\n            ❤️{{{ˇ}}}\n        ": "",
    "\n            🏀{{{)ˇ}}}\n            ε{{{)ˇ}}}\n            ❤️{{{)ˇ}}}\n        ": "",
    "\n            🏀{{{)}}}}ˇ\n            ε{{{)}}}}ˇ\n            ❤️{{{)}}}}ˇ\n        ": "",
    "\n            ˇ\n            ˇ\n        ": "",
    "/": "",
    "*": "",
    "\n            /*ˇ */\n            /*ˇ */\n        ": "",
    "\n            /ˇ\n            ˇ\n        ": "",
    "\n            /*ˇ */\n            *ˇ\n        ": "",
    "autoclose_before": "",
    "ˇa b": "",
    "{ˇa b": "",
    "ˇ": "",
    "[ˇ": "",
    "«aˇ» b": "",
    "{«aˇ»} b": "",
    "a ˇ": "",
    "a \\\"ˇ\\\"": "",
    "a \\\"\\\"ˇ": "",
    "a\\\"ˇ": "",
    "{ˇ": "",
    "{\\\"ˇ\\\"": "",
    "a{ˇ}": "",
    "<ˇ": "",
    "<«aˇ»> b": "",
    "\n            ˇ\n            ˇ\n            ˇ\n        ": "",
    "\n            ˇ)}\n            ˇ)}\n            ˇ)}\n        ": "",
    "\n            )}ˇ\n            )}ˇ\n            )}ˇ\n        ": "",
    "\n            )}]ˇ]\n            )}]ˇ]\n            )}]ˇ]\n        ": "",
    "HTML": "",
    "})]>": "",
    "\n            (script_element\n                (raw_text) @injection.content\n                (#set! injection.language ": "",
    "))\n            ": "",
    "JavaScript": "",
    "\n            <body>ˇ\n                <script>\n                    var x = 1;ˇ\n                </script>\n            </body>ˇ\n        ": "",
    "\n            <body><aˇ>\n                <script>\n                    var x = 1;<aˇ\n                </script>\n            </body><aˇ>\n        ": "",
    " b=": "",
    "c": "",
    "\n            <body><a b={c(ˇ)}>\n                <script>\n                    var x = 1;<a b={c(ˇ)}\n                </script>\n            </body><a b={c(ˇ)}>\n        ": "",
    "d": "",
    "\n            <body><a b={c()d}ˇ>\n                <script>\n                    var x = 1;<a b={c()d}ˇ\n                </script>\n            </body><a b={c()d}ˇ>\n        ": "",
    "\n            <body><a b={c()d}>ˇ\n                <script>\n                    var x = 1;<a b={c()d}>ˇ\n                </script>\n            </body><a b={c()d}>ˇ\n        ": "",
    "\n            <body><ˇ>\n                <script>\n                    var x = 1;<ˇ\n                </script>\n            </body><ˇ>\n        ": "",
    "\n            <body>/*ˇ\n                <script>\n                    var x = 1;/*ˇ */\n                </script>\n            </body>/*ˇ\n        ": "",
    "start": "",
    "end": "",
    "close": "",
    "newline": "",
    "not_in": "",
    "string": "",
    "(string_literal) @string": "",
    "\n            let x = ˇ\n        ": "",
    "\n            let x = ": "",
    "\n        ": "",
    "ˇ\n        ": "",
    "\\\\": "",
    "ˇ ": "",
    "#\n        .unindent(),\n    );\n\n    // Inserting a closing quotation mark at the position of an automatically-inserted quotation\n    // mark. Nothing is inserted.\n    cx.update_editor(|editor, window, cx| {\n        editor.move_right(&Default::default(), window, cx);\n        editor.handle_input(": "",
    "#\n        .unindent(),\n    );\n}\n\n#[gpui::test]\nasync fn test_surround_with_pair(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let language = Arc::new(Language::new(\n        LanguageConfig {\n            brackets: BracketPairConfig {\n                pairs: vec![\n                    BracketPair {\n                        start: ": "",
    ".to_string(),\n                        end: ": "",
    ".to_string(),\n                        close: true,\n                        surround: true,\n                        newline: true,\n                    },\n                    BracketPair {\n                        start: ": "",
    ".to_string(),\n                        close: true,\n                        surround: true,\n                        ..Default::default()\n                    },\n                ],\n                ..Default::default()\n            },\n            ..Default::default()\n        },\n        Some(tree_sitter_rust::LANGUAGE.into()),\n    ));\n\n    let text = r#": "",
    "#\n    .unindent();\n\n    let buffer = cx.new(|cx| Buffer::local(text, cx).with_language(language, cx));\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n    editor\n        .condition::<crate::EditorEvent>(cx, |editor, cx| !editor.buffer.read(cx).is_parsing(cx))\n        .await;\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(None, window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(1), 0)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(2), 0)..DisplayPoint::new(DisplayRow(2), 1),\n            ])\n        });\n\n        editor.handle_input(": "",
    ", window, cx);\n        editor.handle_input(": "",
    ", window, cx);\n        assert_eq!(\n            editor.text(cx),\n            ": "",
    "\n            .unindent()\n        );\n        assert_eq!(\n            editor.selections.display_ranges(cx),\n            [\n                DisplayPoint::new(DisplayRow(0), 3)..DisplayPoint::new(DisplayRow(0), 4),\n                DisplayPoint::new(DisplayRow(1), 3)..DisplayPoint::new(DisplayRow(1), 4),\n                DisplayPoint::new(DisplayRow(2), 3)..DisplayPoint::new(DisplayRow(2), 4)\n            ]\n        );\n\n        editor.undo(&Undo, window, cx);\n        editor.undo(&Undo, window, cx);\n        editor.undo(&Undo, window, cx);\n        assert_eq!(\n            editor.text(cx),\n            ": "",
    "\n            .unindent()\n        );\n        assert_eq!(\n            editor.selections.display_ranges(cx),\n            [\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(1), 0)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(2), 0)..DisplayPoint::new(DisplayRow(2), 1)\n            ]\n        );\n\n        // Ensure inserting the first character of a multi-byte bracket pair\n        // doesn't surround the selections with the bracket.\n        editor.handle_input(": "",
    "\n            .unindent()\n        );\n        assert_eq!(\n            editor.selections.display_ranges(cx),\n            [\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(1), 1)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(2), 1)..DisplayPoint::new(DisplayRow(2), 1)\n            ]\n        );\n\n        editor.undo(&Undo, window, cx);\n        assert_eq!(\n            editor.text(cx),\n            ": "",
    "\n            .unindent()\n        );\n        assert_eq!(\n            editor.selections.display_ranges(cx),\n            [\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(1), 0)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(2), 0)..DisplayPoint::new(DisplayRow(2), 1)\n            ]\n        );\n\n        // Ensure inserting the last character of a multi-byte bracket pair\n        // doesn't surround the selections with the bracket.\n        editor.handle_input(": "",
    "\n            .unindent()\n        );\n        assert_eq!(\n            editor.selections.display_ranges(cx),\n            [\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(1), 1)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(2), 1)..DisplayPoint::new(DisplayRow(2), 1)\n            ]\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_delete_autoclose_pair(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let language = Arc::new(Language::new(\n        LanguageConfig {\n            brackets: BracketPairConfig {\n                pairs: vec![BracketPair {\n                    start: ": "",
    ".to_string(),\n                    end: ": "",
    ".to_string(),\n                    close: true,\n                    surround: true,\n                    newline: true,\n                }],\n                ..Default::default()\n            },\n            autoclose_before: ": "",
    ".to_string(),\n            ..Default::default()\n        },\n        Some(tree_sitter_rust::LANGUAGE.into()),\n    ));\n\n    let text = r#": "",
    "#\n    .unindent();\n\n    let buffer = cx.new(|cx| Buffer::local(text, cx).with_language(language, cx));\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n    editor\n        .condition::<crate::EditorEvent>(cx, |editor, cx| !editor.buffer.read(cx).is_parsing(cx))\n        .await;\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(None, window, cx, |s| {\n            s.select_ranges([\n                Point::new(0, 1)..Point::new(0, 1),\n                Point::new(1, 1)..Point::new(1, 1),\n                Point::new(2, 1)..Point::new(2, 1),\n            ])\n        });\n\n        editor.handle_input(": "",
    "\n            .unindent()\n        );\n        assert_eq!(\n            editor.selections.ranges::<Point>(cx),\n            [\n                Point::new(0, 4)..Point::new(0, 4),\n                Point::new(1, 4)..Point::new(1, 4),\n                Point::new(2, 4)..Point::new(2, 4)\n            ]\n        );\n\n        editor.backspace(&Default::default(), window, cx);\n        editor.backspace(&Default::default(), window, cx);\n        assert_eq!(\n            editor.text(cx),\n            ": "",
    "\n            .unindent()\n        );\n        assert_eq!(\n            editor.selections.ranges::<Point>(cx),\n            [\n                Point::new(0, 2)..Point::new(0, 2),\n                Point::new(1, 2)..Point::new(1, 2),\n                Point::new(2, 2)..Point::new(2, 2)\n            ]\n        );\n\n        editor.delete_to_previous_word_start(&Default::default(), window, cx);\n        assert_eq!(\n            editor.text(cx),\n            ": "",
    "\n            .unindent()\n        );\n        assert_eq!(\n            editor.selections.ranges::<Point>(cx),\n            [\n                Point::new(0, 1)..Point::new(0, 1),\n                Point::new(1, 1)..Point::new(1, 1),\n                Point::new(2, 1)..Point::new(2, 1)\n            ]\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_always_treat_brackets_as_autoclosed_delete(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.always_treat_brackets_as_autoclosed = Some(true);\n    });\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    let language = Arc::new(Language::new(\n        LanguageConfig {\n            brackets: BracketPairConfig {\n                pairs: vec![\n                    BracketPair {\n                        start: ": "",
    ".to_string(),\n                        close: false,\n                        surround: true,\n                        newline: true,\n                    },\n                ],\n                ..Default::default()\n            },\n            autoclose_before: ": "",
    ".to_string(),\n            ..Default::default()\n        },\n        Some(tree_sitter_rust::LANGUAGE.into()),\n    ));\n\n    cx.language_registry().add(language.clone());\n    cx.update_buffer(|buffer, cx| {\n        buffer.set_language(Some(language), cx);\n    });\n\n    cx.set_state(\n        &": "",
    "\n        .unindent(),\n    );\n\n    cx.update_editor(|editor, window, cx| {\n        editor.backspace(&Default::default(), window, cx);\n        editor.backspace(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(\n        &": "",
    "\n        .unindent(),\n    );\n\n    cx.update_editor(|editor, window, cx| {\n        editor.handle_input(": "",
    ", window, cx);\n        editor.move_right(&MoveRight, window, cx);\n        editor.move_right(&MoveRight, window, cx);\n        editor.move_left(&MoveLeft, window, cx);\n        editor.move_left(&MoveLeft, window, cx);\n        editor.backspace(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(\n        &": "",
    "\n        .unindent(),\n    );\n\n    cx.update_editor(|editor, window, cx| {\n        editor.backspace(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(\n        &": "",
    "\n        .unindent(),\n    );\n}\n\n#[gpui::test]\nasync fn test_auto_replace_emoji_shortcode(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let language = Arc::new(Language::new(\n        LanguageConfig::default(),\n        Some(tree_sitter_rust::LANGUAGE.into()),\n    ));\n\n    let buffer = cx.new(|cx| Buffer::local(": "",
    ", cx).with_language(language, cx));\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n    editor\n        .condition::<crate::EditorEvent>(cx, |editor, cx| !editor.buffer.read(cx).is_parsing(cx))\n        .await;\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.set_auto_replace_emoji_shortcode(true);\n\n        editor.handle_input(": "",
    ", window, cx);\n        assert_eq!(editor.text(cx), ": "",
    ".unindent());\n\n        editor.handle_input(": "",
    ".unindent());\n\n        // Ensure shortcode gets replaced when it is part of a word that only consists of emojis\n        editor.handle_input(": "",
    ".unindent());\n\n        // Ensure shortcode does not get replaced when it is part of a word\n        editor.handle_input(": "",
    ".unindent());\n\n        editor.set_auto_replace_emoji_shortcode(false);\n\n        // Ensure shortcode does not get replaced when auto replace is off\n        editor.handle_input(": "",
    ".unindent()\n        );\n\n        editor.handle_input(": "",
    ".unindent()\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_snippet_placeholder_choices(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let (text, insertion_ranges) = marked_text_ranges(\n        indoc! {": "",
    "},\n        false,\n    );\n\n    let buffer = cx.update(|cx| MultiBuffer::build_simple(&text, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n\n    _ = editor.update_in(cx, |editor, window, cx| {\n        let snippet = Snippet::parse(": "",
    ").unwrap();\n\n        editor\n            .insert_snippet(&insertion_ranges, snippet, window, cx)\n            .unwrap();\n\n        fn assert(editor: &mut Editor, cx: &mut Context<Editor>, marked_text: &str) {\n            let (expected_text, selection_ranges) = marked_text_ranges(marked_text, false);\n            assert_eq!(editor.text(cx), expected_text);\n            assert_eq!(editor.selections.ranges::<usize>(cx), selection_ranges);\n        }\n\n        assert(\n            editor,\n            cx,\n            indoc! {": "",
    "},\n        );\n\n        assert!(editor.context_menu_visible(), ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_snippets(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    cx.set_state(indoc! {": "",
    "});\n\n    cx.update_editor(|editor, window, cx| {\n        let snippet = Snippet::parse(": "",
    ").unwrap();\n        let insertion_ranges = editor\n            .selections\n            .all(cx)\n            .iter()\n            .map(|s| s.range().clone())\n            .collect::<Vec<_>>();\n        editor\n            .insert_snippet(&insertion_ranges, snippet, window, cx)\n            .unwrap();\n    });\n\n    cx.assert_editor_state(indoc! {": "",
    "});\n\n    // Can't move earlier than the first tab stop\n    cx.update_editor(|editor, window, cx| {\n        assert!(!editor.move_to_prev_snippet_tabstop(window, cx))\n    });\n    cx.assert_editor_state(indoc! {": "",
    "});\n\n    cx.update_editor(|editor, window, cx| assert!(editor.move_to_next_snippet_tabstop(window, cx)));\n    cx.assert_editor_state(indoc! {": "",
    "});\n\n    cx.update_editor(|editor, window, cx| assert!(editor.move_to_prev_snippet_tabstop(window, cx)));\n    cx.assert_editor_state(indoc! {": "",
    "});\n    cx.update_editor(|editor, window, cx| assert!(editor.move_to_next_snippet_tabstop(window, cx)));\n    cx.assert_editor_state(indoc! {": "",
    "});\n\n    // As soon as the last tab stop is reached, snippet state is gone\n    cx.update_editor(|editor, window, cx| {\n        assert!(!editor.move_to_prev_snippet_tabstop(window, cx))\n    });\n    cx.assert_editor_state(indoc! {": "",
    "});\n}\n\n#[gpui::test]\nasync fn test_snippet_indentation(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    cx.update_editor(|editor, window, cx| {\n        let snippet = Snippet::parse(indoc! {": "",
    "})\n        .unwrap();\n        let insertion_ranges = editor\n            .selections\n            .all(cx)\n            .iter()\n            .map(|s| s.range().clone())\n            .collect::<Vec<_>>();\n        editor\n            .insert_snippet(&insertion_ranges, snippet, window, cx)\n            .unwrap();\n    });\n\n    cx.assert_editor_state(indoc! {": "",
    "});\n}\n\n#[gpui::test]\nasync fn test_document_format_during_save(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_file(path!(": "",
    "), Default::default()).await;\n\n    let project = Project::test(fs, [path!(": "",
    ").as_ref()], cx).await;\n\n    let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n    language_registry.add(rust_lang());\n    let mut fake_servers = language_registry.register_fake_lsp(\n        ": "",
    ",\n        FakeLspAdapter {\n            capabilities: lsp::ServerCapabilities {\n                document_formatting_provider: Some(lsp::OneOf::Left(true)),\n                ..Default::default()\n            },\n            ..Default::default()\n        },\n    );\n\n    let buffer = project\n        .update(cx, |project, cx| {\n            project.open_local_buffer(path!(": "",
    "), cx)\n        })\n        .await\n        .unwrap();\n\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| {\n        build_editor_with_project(project.clone(), buffer, window, cx)\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.set_text(": "",
    ", window, cx)\n    });\n    assert!(cx.read(|cx| editor.is_dirty(cx)));\n\n    cx.executor().start_waiting();\n    let fake_server = fake_servers.next().await.unwrap();\n\n    {\n        fake_server.set_request_handler::<lsp::request::Formatting, _, _>(\n            move |params, _| async move {\n                assert_eq!(\n                    params.text_document.uri,\n                    lsp::Url::from_file_path(path!(": "",
    ")).unwrap()\n                );\n                assert_eq!(params.options.tab_size, 4);\n                Ok(Some(vec![lsp::TextEdit::new(\n                    lsp::Range::new(lsp::Position::new(0, 3), lsp::Position::new(1, 0)),\n                    ": "",
    ".to_string(),\n                )]))\n            },\n        );\n        let save = editor\n            .update_in(cx, |editor, window, cx| {\n                editor.save(\n                    SaveOptions {\n                        format: true,\n                        autosave: false,\n                    },\n                    project.clone(),\n                    window,\n                    cx,\n                )\n            })\n            .unwrap();\n        cx.executor().start_waiting();\n        save.await;\n\n        assert_eq!(\n            editor.update(cx, |editor, cx| editor.text(cx)),\n            ": "",
    "\n        );\n        assert!(!cx.read(|cx| editor.is_dirty(cx)));\n    }\n\n    {\n        editor.update_in(cx, |editor, window, cx| {\n            editor.set_text(": "",
    ", window, cx)\n        });\n        assert!(cx.read(|cx| editor.is_dirty(cx)));\n\n        // Ensure we can still save even if formatting hangs.\n        fake_server.set_request_handler::<lsp::request::Formatting, _, _>(\n            move |params, _| async move {\n                assert_eq!(\n                    params.text_document.uri,\n                    lsp::Url::from_file_path(path!(": "",
    ")).unwrap()\n                );\n                futures::future::pending::<()>().await;\n                unreachable!()\n            },\n        );\n        let save = editor\n            .update_in(cx, |editor, window, cx| {\n                editor.save(\n                    SaveOptions {\n                        format: true,\n                        autosave: false,\n                    },\n                    project.clone(),\n                    window,\n                    cx,\n                )\n            })\n            .unwrap();\n        cx.executor().advance_clock(super::FORMAT_TIMEOUT);\n        cx.executor().start_waiting();\n        save.await;\n        assert_eq!(\n            editor.update(cx, |editor, cx| editor.text(cx)),\n            ": "",
    "\n        );\n    }\n\n    // Set rust language override and assert overridden tabsize is sent to language server\n    update_test_language_settings(cx, |settings| {\n        settings.languages.insert(\n            ": "",
    ".into(),\n            LanguageSettingsContent {\n                tab_size: NonZeroU32::new(8),\n                ..Default::default()\n            },\n        );\n    });\n\n    {\n        editor.update_in(cx, |editor, window, cx| {\n            editor.set_text(": "",
    ", window, cx)\n        });\n        assert!(cx.read(|cx| editor.is_dirty(cx)));\n        let _formatting_request_signal = fake_server\n            .set_request_handler::<lsp::request::Formatting, _, _>(move |params, _| async move {\n                assert_eq!(\n                    params.text_document.uri,\n                    lsp::Url::from_file_path(path!(": "",
    ")).unwrap()\n                );\n                assert_eq!(params.options.tab_size, 8);\n                Ok(Some(vec![]))\n            });\n        let save = editor\n            .update_in(cx, |editor, window, cx| {\n                editor.save(\n                    SaveOptions {\n                        format: true,\n                        autosave: false,\n                    },\n                    project.clone(),\n                    window,\n                    cx,\n                )\n            })\n            .unwrap();\n        cx.executor().start_waiting();\n        save.await;\n    }\n}\n\n#[gpui::test]\nasync fn test_multibuffer_format_during_save(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let cols = 4;\n    let rows = 10;\n    let sample_text_1 = sample_text(rows, cols, 'a');\n    assert_eq!(\n        sample_text_1,\n        ": "",
    "\n    );\n    let sample_text_2 = sample_text(rows, cols, 'l');\n    assert_eq!(\n        sample_text_2,\n        ": "",
    "\n    );\n    let sample_text_3 = sample_text(rows, cols, 'v');\n    assert_eq!(\n        sample_text_3,\n        ": "",
    "\n    );\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_tree(\n        path!(": "",
    "),\n        json!({\n            ": "",
    ": sample_text_1,\n            ": "",
    ": sample_text_2,\n            ": "",
    ": sample_text_3,\n        }),\n    )\n    .await;\n\n    let project = Project::test(fs, [path!(": "",
    ").as_ref()], cx).await;\n    let workspace = cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let cx = &mut VisualTestContext::from_window(*workspace.deref(), cx);\n\n    let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n    language_registry.add(rust_lang());\n    let mut fake_servers = language_registry.register_fake_lsp(\n        ": "",
    ",\n        FakeLspAdapter {\n            capabilities: lsp::ServerCapabilities {\n                document_formatting_provider: Some(lsp::OneOf::Left(true)),\n                ..Default::default()\n            },\n            ..Default::default()\n        },\n    );\n\n    let worktree = project.update(cx, |project, cx| {\n        let mut worktrees = project.worktrees(cx).collect::<Vec<_>>();\n        assert_eq!(worktrees.len(), 1);\n        worktrees.pop().unwrap()\n    });\n    let worktree_id = worktree.update(cx, |worktree, _| worktree.id());\n\n    let buffer_1 = project\n        .update(cx, |project, cx| {\n            project.open_buffer((worktree_id, ": "",
    "), cx)\n        })\n        .await\n        .unwrap();\n    let buffer_2 = project\n        .update(cx, |project, cx| {\n            project.open_buffer((worktree_id, ": "",
    "), cx)\n        })\n        .await\n        .unwrap();\n    let buffer_3 = project\n        .update(cx, |project, cx| {\n            project.open_buffer((worktree_id, ": "",
    "), cx)\n        })\n        .await\n        .unwrap();\n\n    let multi_buffer = cx.new(|cx| {\n        let mut multi_buffer = MultiBuffer::new(ReadWrite);\n        multi_buffer.push_excerpts(\n            buffer_1.clone(),\n            [\n                ExcerptRange::new(Point::new(0, 0)..Point::new(3, 0)),\n                ExcerptRange::new(Point::new(5, 0)..Point::new(7, 0)),\n                ExcerptRange::new(Point::new(9, 0)..Point::new(10, 4)),\n            ],\n            cx,\n        );\n        multi_buffer.push_excerpts(\n            buffer_2.clone(),\n            [\n                ExcerptRange::new(Point::new(0, 0)..Point::new(3, 0)),\n                ExcerptRange::new(Point::new(5, 0)..Point::new(7, 0)),\n                ExcerptRange::new(Point::new(9, 0)..Point::new(10, 4)),\n            ],\n            cx,\n        );\n        multi_buffer.push_excerpts(\n            buffer_3.clone(),\n            [\n                ExcerptRange::new(Point::new(0, 0)..Point::new(3, 0)),\n                ExcerptRange::new(Point::new(5, 0)..Point::new(7, 0)),\n                ExcerptRange::new(Point::new(9, 0)..Point::new(10, 4)),\n            ],\n            cx,\n        );\n        multi_buffer\n    });\n    let multi_buffer_editor = cx.new_window_entity(|window, cx| {\n        Editor::new(\n            EditorMode::full(),\n            multi_buffer,\n            Some(project.clone()),\n            window,\n            cx,\n        )\n    });\n\n    multi_buffer_editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(Some(Autoscroll::Next), window, cx, |s| {\n            s.select_ranges(Some(1..2))\n        });\n        editor.insert(": "",
    ", window, cx);\n    });\n    assert!(cx.read(|cx| multi_buffer_editor.is_dirty(cx)));\n    multi_buffer_editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(Some(Autoscroll::Next), window, cx, |s| {\n            s.select_ranges(Some(60..70))\n        });\n        editor.insert(": "",
    ", window, cx);\n    });\n    assert!(cx.read(|cx| multi_buffer_editor.is_dirty(cx)));\n\n    // First two buffers should be edited, but not the third one.\n    assert_eq!(\n        multi_buffer_editor.update(cx, |editor, cx| editor.text(cx)),\n        ": "",
    ",\n    );\n    buffer_1.update(cx, |buffer, _| {\n        assert!(buffer.is_dirty());\n        assert_eq!(\n            buffer.text(),\n            ": "",
    ",\n        )\n    });\n    buffer_2.update(cx, |buffer, _| {\n        assert!(buffer.is_dirty());\n        assert_eq!(\n            buffer.text(),\n            ": "",
    ",\n        )\n    });\n    buffer_3.update(cx, |buffer, _| {\n        assert!(!buffer.is_dirty());\n        assert_eq!(buffer.text(), sample_text_3,)\n    });\n    cx.executor().run_until_parked();\n\n    cx.executor().start_waiting();\n    let save = multi_buffer_editor\n        .update_in(cx, |editor, window, cx| {\n            editor.save(\n                SaveOptions {\n                    format: true,\n                    autosave: false,\n                },\n                project.clone(),\n                window,\n                cx,\n            )\n        })\n        .unwrap();\n\n    let fake_server = fake_servers.next().await.unwrap();\n    fake_server\n        .server\n        .on_request::<lsp::request::Formatting, _, _>(move |params, _| async move {\n            Ok(Some(vec![lsp::TextEdit::new(\n                lsp::Range::new(lsp::Position::new(0, 3), lsp::Position::new(1, 0)),\n                format!(": "",
    ", params.text_document.uri),\n            )]))\n        })\n        .detach();\n    save.await;\n\n    // After multibuffer saving, only first two buffers should be reformatted, but not the third one (as it was not dirty).\n    assert!(cx.read(|cx| !multi_buffer_editor.is_dirty(cx)));\n    assert_eq!(\n        multi_buffer_editor.update(cx, |editor, cx| editor.text(cx)),\n        uri!(\n            ": "",
    "\n        ),\n    );\n    buffer_1.update(cx, |buffer, _| {\n        assert!(!buffer.is_dirty());\n        assert_eq!(\n            buffer.text(),\n            uri!(": "",
    "),\n        )\n    });\n    buffer_2.update(cx, |buffer, _| {\n        assert!(!buffer.is_dirty());\n        assert_eq!(\n            buffer.text(),\n            uri!(": "",
    "),\n        )\n    });\n    buffer_3.update(cx, |buffer, _| {\n        assert!(!buffer.is_dirty());\n        assert_eq!(buffer.text(), sample_text_3,)\n    });\n}\n\n#[gpui::test]\nasync fn test_autosave_with_dirty_buffers(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_tree(\n        path!(": "",
    ": ": "",
    "hello\\\"); }": "",
    "file2.rs": "",
    "fn test() { println!(\\\"test\\\"); }": "",
    "file3.rs": "",
    "fn other() { println!(\\\"other\\\"); }\\n": "",
    "/dir": "",
    "file1.rs": "",
    "// edited": "",
    "/dir/file1.rs": "",
    "/dir/file2.rs": "",
    "/dir/file3.rs": "",
    "Buffer 1 was dirty, so it should have been written once during autosave": "",
    "Buffer 2 was clean, so it should not have been written during autosave": "",
    "Buffer 3 was clean, so it should not have been written during autosave": "",
    "Buffer 1 should only have been written once total (during autosave, not manual save)": "",
    "Buffer 2 should not have been written at all": "",
    "Buffer 3 should not have been written at all": "",
    "/file.rs": "",
    "one\\ntwo\\nthree\\n": "",
    ", ": "",
    "one, two\\nthree\\n": "",
    "Should not be invoked": "",
    "somehting_new\\n": "",
    "rs": "",
    "code-action-1": "",
    "code-action-2": "",
    "one  \\ntwo   \\nthree": "",
    "the-command-for-code-action-1": "",
    "applied-formatting\\n": "",
    "applied-code-action-1-edit\\n": "",
    "applied-code-action-2-edit\\n": "",
    "applied-code-action-1-command\\n": "",
    "\n                applied-code-action-2-edit\n                applied-code-action-1-command\n                applied-code-action-1-edit\n                applied-formatting\n                one\n                two\n                three\n            ": "",
    "\n                applied-code-action-1-edit\n                applied-formatting\n                one\n                two\n                three\n            ": "",
    "edited\\n": "",
    "\n                applied-code-action-1-command\n                applied-code-action-1-edit\n                applied-formatting\n                one\n                two\n                three\n                edited\n            ": "",
    "\n                applied-code-action-1-command\n                applied-code-action-1-edit\n                applied-formatting\n                one\n                two\n                three\n            ": "",
    "/file.ts": "",
    "TypeScript": "",
    "ts": "",
    "import { a } from 'module';\\nimport { b } from 'module';\\n\\nconst x = a;\\n": "",
    "Organize Imports": "",
    "import { a } from 'module';\\n\\nconst x = a;\\n": "",
    "\n        one.twoˇ\n    ": "",
    "\\n    ": "",
    "\n        one\n            .twoˇ\n    ": "",
    "one ": "",
    "twoˇ": "",
    "one": "",
    "three": "",
    "\n            fn main() {\n                sampleˇ\n            }\n        ": "",
    "\n            fn main() {\n                sample(ˇ)\n            }\n        ": "",
    "fn sample(param1: u8, param2: u8)": "",
    "param1: u8": "",
    "param2: u8": "",
    "param1: u8, param2: u8": "",
    "\n        fn main() {\n            sample(ˇ);\n        }\n\n        fn sample(param1: u8, param2: u8) {}\n    ": "",
    "\n        fn main() {\n            sample(param1, param2ˇ);\n        }\n\n        fn sample(param1: u8, param2: u8) {}\n    ": "",
    "\n        fn main() {\n            sample(param1, «ˇparam2»);\n        }\n\n        fn sample(param1: u8, param2: u8) {}\n    ": "",
    "\n        fn main() {\n            sample(param1, ˇparam2);\n        }\n\n        fn sample(param1: u8, param2: u8) {}\n    ": "",
    "Start of word matches completion text": "",
    "before ediˇ after": "",
    "before <edi|> after": "",
    "editor": "",
    "before editorˇ after": "",
    "Accept same text at the middle of the word": "",
    "before ediˇtor after": "",
    "before <edi|tor> after": "",
    "before editorˇtor after": "",
    "End of word matches completion text -- cursor at end": "",
    "before torˇ after": "",
    "before <tor|> after": "",
    "End of word matches completion text -- cursor at start": "",
    "before ˇtor after": "",
    "before <|tor> after": "",
    "Prepend text containing whitespace": "",
    "pˇfield: bool": "",
    "<p|field>: bool": "",
    "pub ": "",
    "pub ˇfield: bool": "",
    "pub ˇ: bool": "",
    "Add element to start of list": "",
    "[element_ˇelement_2]": "",
    "[<element_|element_2>]": "",
    "element_1": "",
    "[element_1ˇelement_2]": "",
    "[element_1ˇ]": "",
    "Add element to start of list -- first and second elements are equal": "",
    "[elˇelement]": "",
    "[<el|element>]": "",
    "element": "",
    "[elementˇelement]": "",
    "[elementˇ]": "",
    "Ends with matching suffix": "",
    "SubˇError": "",
    "<Sub|Error>": "",
    "SubscriptionError": "",
    "SubscriptionErrorˇError": "",
    "SubscriptionErrorˇ": "",
    "Suffix is a subsequence -- contiguous": "",
    "SubˇErr": "",
    "<Sub|Err>": "",
    "SubscriptionErrorˇErr": "",
    "Suffix is a subsequence -- non-contiguous -- replace intended": "",
    "Suˇscrirr": "",
    "<Su|scrirr>": "",
    "SubscriptionErrorˇscrirr": "",
    "Suffix is a subsequence -- non-contiguous -- replace unintended": "",
    "foo(indˇix)": "",
    "foo(<ind|ix>)": "",
    "node_index": "",
    "foo(node_indexˇix)": "",
    "foo(node_indexˇ)": "",
    "Replace range ends before cursor - should extend to cursor": "",
    "before editˇo after": "",
    "before <{ed}>it|o after": "",
    "before editorˇo after": "",
    "Uses label for suffix matching": "",
    "editor()": "",
    "before editor()ˇtor after": "",
    "before editor()ˇ after": "",
    "Case insensitive subsequence and suffix matching": "",
    "before EDiˇtoR after": "",
    "before <EDi|toR> after": "",
    "before editorˇtoR after": "",
    "run = {:?}, mode = {lsp_insert_mode:.?}": "",
    "to_offset": "",
    "\n        1. buf.to_offˇsuffix\n        2. buf.to_offˇsuf\n        3. buf.to_offˇfix\n        4. buf.to_offˇ\n        5. into_offˇensive\n        6. ˇsuffix\n        7. let ˇ //\n        8. aaˇzz\n        9. buf.to_off«zzzzzˇ»suffix\n        10. buf.«ˇzzzzz»suffix\n        11. to_off«ˇzzzzz»\n\n        buf.to_offˇsuffix  // newest cursor\n    ": "",
    "\n        1. buf.to_offsuffix\n        2. buf.to_offsuf\n        3. buf.to_offfix\n        4. buf.to_off\n        5. into_offensive\n        6. suffix\n        7. let  //\n        8. aazz\n        9. buf.to_offzzzzzsuffix\n        10. buf.zzzzzsuffix\n        11. to_offzzzzz\n\n        buf.<to_off|suffix>  // newest cursor\n    ": "",
    "\n        1. buf.to_offsetˇ\n        2. buf.to_offsetˇsuf\n        3. buf.to_offsetˇfix\n        4. buf.to_offsetˇ\n        5. into_offsetˇensive\n        6. to_offsetˇsuffix\n        7. let to_offsetˇ //\n        8. aato_offsetˇzz\n        9. buf.to_offsetˇ\n        10. buf.to_offsetˇsuffix\n        11. to_offsetˇ\n\n        buf.to_offsetˇ  // newest cursor\n    ": "",
    "foo_and_bar": "",
    "\n        1. ooanbˇ\n        2. zooanbˇ\n        3. ooanbˇz\n        4. zooanbˇz\n        5. ooanˇ\n        6. oanbˇ\n\n        ooanbˇ\n    ": "",
    "\n        1. ooanb\n        2. zooanb\n        3. ooanbz\n        4. zooanbz\n        5. ooan\n        6. oanb\n\n        <ooanb|>\n    ": "",
    "\n        1. foo_and_barˇ\n        2. zfoo_and_barˇ\n        3. foo_and_barˇz\n        4. zfoo_and_barˇz\n        5. ooanfoo_and_barˇ\n        6. oanbfoo_and_barˇ\n\n        foo_and_barˇ\n    ": "",
    "\n        1. ooˇanb\n        2. zooˇanb\n        3. ooˇanbz\n        4. zooˇanbz\n\n        ooˇanb\n    ": "",
    "\n        1. ooanb\n        2. zooanb\n        3. ooanbz\n        4. zooanbz\n\n        <oo|anb>\n    ": "",
    "\n        1. foo_and_barˇ\n        2. zfoo_and_barˇ\n        3. foo_and_barˇz\n        4. zfoo_and_barˇz\n\n        foo_and_barˇ\n    ": "",
    "\n        fn main() {\n            10.satu;\n\n            //\n            // separate cursors so they open in different excerpts (manually reproducible)\n            //\n\n            10.satu20;\n        }\n    ": "",
    "\n        fn main() {\n            10.satuˇ;\n\n            //\n\n            //\n\n            10.satuˇ20;\n        }\n    ": "",
    "\n        fn main() {\n            10.saturating_sub()ˇ;\n\n            //\n\n            //\n\n            10.saturating_sub()ˇ;\n        }\n    ": "",
    "//": "",
    "/a": "",
    "main.rs": "",
    "/a/main.rs": "",
    "saturating_sub()": "",
    ".": "",
    ":": "",
    "\n        oneˇ\n        two\n        three\n    ": "",
    "\n            one.|<>\n            two\n            three\n        ": "",
    "first_completion": "",
    "second_completion": "",
    "test signature": "",
    "foo: u8": "",
    "No signature help was called for": "",
    "No signature help should be shown when completions menu is open": "",
    "\n        one.second_completionˇ\n        two\n        three\n    ": "",
    "\n                    one.second_ˇcompletion\n                    two\n                    threeˇ\n                ": "",
    "overlapping additional edit": "",
    "\n                    one.second_completion\n                    two\n                    threeˇ\n                ": "",
    "\\nadditional edit": "",
    "\n        one.second_completionˇ\n        two\n        three\n        additional edit\n    ": "",
    "\n        one.second_completion\n        twoˇ\n        threeˇ\n        additional edit\n    ": "",
    "\n        one.second_completion\n        two sˇ\n        three sˇ\n        additional edit\n    ": "",
    "\n            one.second_completion\n            two s\n            three <s|>\n            additional edit\n        ": "",
    "fourth_completion": "",
    "fifth_completion": "",
    "sixth_completion": "",
    "i": "",
    "\n            one.second_completion\n            two si\n            three <si|>\n            additional edit\n        ": "",
    "\n        one.second_completion\n        two sixth_completionˇ\n        three sixth_completionˇ\n        additional edit\n    ": "",
    "editorˇ": "",
    "c l o": "",
    "editor.cloˇ": "",
    "editor.<clo|>": "",
    "clobber": "",
    "editor.closeˇ": "",
    "objˇ": "",
    "obj.|<>": "",
    "obj.ˇ": "",
    "obj.aˇ": "",
    "obj.abˇ": "",
    "obj.abcˇ": "",
    "obj.aˇb": "",
    "obj.<ab|>a": "",
    "obj.abˇb": "",
    "obj.<a|>b": "",
    "obj.ˇb": "",
    "first": "",
    "last": "",
    "When LSP server is fast to reply, no fallback word completions are used": "",
    "expected completion menu to be open": "",
    "two": "",
    "When LSP server is slow, document words can be shown instead, if configured accordingly": "",
    "ˇ\n        first\n        last\n        second\n    ": "",
    "second": "",
    "Word completions that has the same edit as the any of the LSP ones, should not be proposed": "",
    "LSP completions should not be queried when dealing with word completions": "",
    "`ShowWordCompletions` action should show word completions": "",
    "l": "",
    "After showing word completions, further editing should filter them and not query the LSP": "",
    "ˇ\n        0_usize\n        let\n        33\n        4.5f32\n    ": "",
    "let": "",
    "With no digits in the completion query, no digits should be in the word completions": "",
    "3ˇ\n        0_usize\n        let\n        3\n        33.35f32\n    ": "",
    "33": "",
    "35f32": "",
    ");\n        } else {\n            panic!(": "",
    ");\n        }\n    });\n}\n\nfn gen_text_edit(params: &CompletionParams, text: &str) -> Option<lsp::CompletionTextEdit> {\n    let position = || lsp::Position {\n        line: params.text_document_position.position.line,\n        character: params.text_document_position.position.character,\n    };\n    Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n        range: lsp::Range {\n            start: position(),\n            end: position(),\n        },\n        new_text: text.to_string(),\n    }))\n}\n\n#[gpui::test]\nasync fn test_multiline_completion(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_tree(\n        path!(": "",
    ",\n        }),\n    )\n    .await;\n\n    let project = Project::test(fs, [path!(": "",
    ").as_ref()], cx).await;\n    let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n    let typescript_language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
    ".into(),\n            matcher: LanguageMatcher {\n                path_suffixes: vec![": "",
    ".to_string()],\n                ..LanguageMatcher::default()\n            },\n            line_comments: vec![": "",
    ".into()],\n            ..LanguageConfig::default()\n        },\n        Some(tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into()),\n    ));\n    language_registry.add(typescript_language.clone());\n    let mut fake_servers = language_registry.register_fake_lsp(\n        ": "",
    ",\n        FakeLspAdapter {\n            capabilities: lsp::ServerCapabilities {\n                completion_provider: Some(lsp::CompletionOptions {\n                    trigger_characters: Some(vec![": "",
    ".to_string(), ": "",
    ".to_string()]),\n                    ..lsp::CompletionOptions::default()\n                }),\n                signature_help_provider: Some(lsp::SignatureHelpOptions::default()),\n                ..lsp::ServerCapabilities::default()\n            },\n            // Emulate vtsls label generation\n            label_for_completion: Some(Box::new(|item, _| {\n                let text = if let Some(description) = item\n                    .label_details\n                    .as_ref()\n                    .and_then(|label_details| label_details.description.as_ref())\n                {\n                    format!(": "",
    ", item.label, description)\n                } else if let Some(detail) = &item.detail {\n                    format!(": "",
    ", item.label, detail)\n                } else {\n                    item.label.clone()\n                };\n                let len = text.len();\n                Some(language::CodeLabel {\n                    text,\n                    runs: Vec::new(),\n                    filter_range: 0..len,\n                })\n            })),\n            ..FakeLspAdapter::default()\n        },\n    );\n    let workspace = cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let cx = &mut VisualTestContext::from_window(*workspace, cx);\n    let worktree_id = workspace\n        .update(cx, |workspace, _window, cx| {\n            workspace.project().update(cx, |project, cx| {\n                project.worktrees(cx).next().unwrap().read(cx).id()\n            })\n        })\n        .unwrap();\n    let _buffer = project\n        .update(cx, |project, cx| {\n            project.open_local_buffer_with_lsp(path!(": "",
    "), cx)\n        })\n        .await\n        .unwrap();\n    let editor = workspace\n        .update(cx, |workspace, window, cx| {\n            workspace.open_path((worktree_id, ": "",
    "), None, true, window, cx)\n        })\n        .unwrap()\n        .await\n        .unwrap()\n        .downcast::<Editor>()\n        .unwrap();\n    let fake_server = fake_servers.next().await.unwrap();\n\n    let multiline_label = ": "",
    ";\n    let multiline_label_2 = ": "",
    ";\n    let multiline_detail = ": "",
    "issuer\\\"`\\n\\t\\tSubjectSerialNumber\\\"`\\n}}": "",
    "d\\ne\\nf\\n": "",
    "g\\nh\\ni\\n": "",
    "new_text_1": "",
    "single line label 1": "",
    "new_text_2": "",
    "single line label 2": "",
    "new_text_3": "",
    "Label with many     spaces and \\t but without newlines": "",
    "Details with many     spaces and \\t but without newlines": "",
    "new_text_4": "",
    "StickyHeaderExcerpt { excerpt, next_excerpt_controls_present, next_buffer_row, }: StickyHeaderExcerpt<'_>,": "",
    "single line label 1 []struct { SignerId struct { Issuer string `json:\\\"issuer\\\"` SubjectSerialNumber\\\"` }}": "",
    "single line label 2 d e f ": "",
    "a b c g h i ": "",
    "Label with many     spaces and \\t but without newlines Details with many     spaces and \\t but without newlines": "",
    "Completion items should have their labels without newlines, also replacing excessive whitespaces. Completion items without newlines should not be altered.": "",
    "Adjusted completion items should still keep their filter ranges for the entire label. Item: {completion:?}": "",
    "variableˇ": "",
    "expected PageDown to select the last item from the context menu": "",
    "expected completion menu to stay open after PageDown": "",
    "expected PageUp to select the first item from the context menu": "",
    "expected completion menu to stay open after PageUp": "",
    "unsafe": "",
    "fn a() {}\\n  nˇ": "",
    "fn a() {}\\n  unsafeˇ": "",
    "fn main() { let a = 2ˇ; }": "",
    "Some": "",
    "Wrap the expression in an `Option::Some`": "",
    "```rust\\nSome(2)\\n```": "",
    "Some(2)": "",
    "fn main() { let a = 2.ˇ; }": "",
    "S o m": "",
    "fn main() { let a = 2.Somˇ; }": "",
    "With the completions menu open, only one LSP request should happen per input": "",
    "//! ": "",
    "\n        fn a() {\n            «//b();\n            ˇ»// «c();\n            //ˇ»  d();\n        }\n    ": "",
    "\n        fn a() {\n            «b();\n            c();\n            ˇ» d();\n        }\n    ": "",
    "\n        fn a() {\n            // «b();\n            // c();\n            ˇ»//  d();\n        }\n    ": "",
    "\n        fn a() {\n            // b();\n            «// c();\n        ˇ»    //  d();\n        }\n    ": "",
    "\n        fn a() {\n            // b();\n            «c();\n        ˇ»    //  d();\n        }\n    ": "",
    "\n        fn a() {\n            a();\n            b();\n        ˇ\n        }\n    ": "",
    "\n        fn a() {\n            a();\n            b();\n        //•ˇ\n        }\n    ": "",
    "\n        fn a() {\n            «a();\n\n            c();ˇ»\n        }\n    ": "",
    "\n        fn a() {\n            // «a();\n\n            // c();ˇ»\n        }\n    ": "",
    "\n        fn a() {\n            «// a();\n            /// b();\n            //! c();ˇ»\n        }\n    ": "",
    "\n        fn a() {\n            «a();\n            b();\n            c();ˇ»\n        }\n    ": "",
    "\n        fn a() {\n        //    «b();\n        //    c();\n        //    ˇ» d();\n        }\n    ": "",
    "\n        fn a() {\n        //    b();\n        //    «c();\n        ˇ»//     d();\n        }\n    ": "",
    "\n        fn a() {\n        //    b();\n            «c();\n        ˇ»//     d();\n        }\n    ": "",
    "\n        fn a() {\n            a();\n            b();\n        //ˇ\n        }\n    ": "",
    "\n        fn a() {\n        //    «a();\n\n        //    c();ˇ»\n        }\n    ": "",
    "\n        fn a() {\n        //    «a();\n        ///    b();\n        //!    c();ˇ»\n        }\n    ": "",
    "fn a() {\n             ˇdog();\n             cat();\n        }": "",
    "fn a() {\n             // dog();\n             catˇ();\n        }": "",
    "fn a() {\n             «dog()ˇ»;\n             cat();\n        }": "",
    "fn a() {\n             // «dog()ˇ»;\n             cat();\n        }": "",
    "fn a() {\n             ˇdˇog();\n             cat();\n        }": "",
    "fn a() {\n             // dog();\n             catˇ(ˇ);\n        }": "",
    "fn a() {\n             ˇdˇog«()ˇ»;\n             cat();\n        }": "",
    "fn a() {\n             // ˇdˇog«()ˇ»;\n             cat();\n        }": "",
    "fn a() {\n             ˇdog();\n\n             cat();\n        }": "",
    "fn a() {\n             // dog();\n        ˇ\n             cat();\n        }": "",
    "fn a() {\n         ˇ    dog();\n             cat();\n        }": "",
    "fn a() {\n             // dog();\n         ˇ    cat();\n        }": "",
    "<!-- ": "",
    " -->": "",
    "\n            <p>A</p>ˇ\n            <p>B</p>ˇ\n            <p>C</p>ˇ\n        ": "",
    "\n            <!-- <p>A</p>ˇ -->\n            <!-- <p>B</p>ˇ -->\n            <!-- <p>C</p>ˇ -->\n        ": "",
    "\n            <p>A«</p>\n            <p>ˇ»B</p>ˇ\n            <p>C«</p>\n            <p>ˇ»D</p>ˇ\n        ": "",
    "\n            <!-- <p>A«</p>\n            <p>ˇ»B</p>ˇ -->\n            <!-- <p>C«</p>\n            <p>ˇ»D</p>ˇ -->\n        ": "",
    "\n            ˇ<script>\n                ˇvar x = new Y();\n            ˇ</script>\n        ": "",
    "\n            <!-- ˇ<script> -->\n                // ˇvar x = new Y();\n            <!-- ˇ</script> -->\n        ": "",
    "aaaa\\nbbbb": "",
    "Xaaaa\\nXbbbb": "",
    "Xa\\nbbb": "",
    "X\\nbb": "",
    "\n            [aaaa\n            (bbbb]\n            cccc)": "",
    "\n                aaaa\n                bˇbbb\n                bˇbbˇb\n                cccc": "",
    "\n                aaaa\n                bXˇbbXb\n                bXˇbbXˇb\n                cccc": "",
    "\n                aaaa\n                bX\n                ˇbbX\n                b\n                bX\n                ˇbbX\n                ˇb\n                cccc": "",
    "aaaa\\nbbbb\\nbbbb\\ncccc": "",
    "/* ": "",
    "{   }\\n": "",
    "  x\\n": "",
    "  /*   */\\n": "",
    "x\\n": "",
    "{{} }\\n": "",
    "{ \\n": "",
    "}\\n": "",
    "  /* \\n": "",
    "  \\n": "",
    "  */\\n": "",
    "{{} \\n": "",
    "abc\\ndef\\nghi\\njkl\\n": "",
    "mno\\npqr\\nstu\\nvwx\\n": "",
    "b.txt": "",
    "a.txt": "",
    "\n        ˇfn func(abc def: i32) -> u32 {\n        }\n    ": "",
    "/root/file": "",
    "\n        fn func(abc def: i32) -> ˇu32 {\n        }\n    ": "",
    "\n        fn func(abc ˇdef: i32) -> u32 {\n        }\n    ": "",
    "\n        fn func(abcˇ def: i32) -> u32 {\n        }\n    ": "",
    "\n        use some::mod;\n\n        const A: u32 = 42;\n\n        fn main() {\n            println!(": "",
    ");\n\n            println!(": "",
    ");\n        }\n        ": "",
    "\n        use some::modified;\n\n        ˇ\n        fn main() {\n            println!(": "",
    ");\n            println!(": "",
    "\n        ˇuse some::modified;\n\n\n        fn main() {\n            println!(": "",
    "\n        use some::modified;\n\n\n        fn main() {\n        ˇ    println!(": "",
    "HelloWorld": "",
    "Hello": "",
    "World": "",
    "hello_world": "",
    "hello_": "",
    "world": "",
    "_hello_world_": "",
    "_": "",
    "world_": "",
    "Hello_World": "",
    "Hello_": "",
    "helloWOrld": "",
    "hello": "",
    "WOrld": "",
    "helloworld": "",
    ":do_the_thing": "",
    "do_": "",
    "the_": "",
    "thing": "",
    "console.logˇ(var);": "",
    "console.log(var)ˇ;": "",
    "console.log(ˇvar);": "",
    "console.log(varˇ);": "",
    "console.log('foo', [1, 2, 3]ˇ);": "",
    "console.log(ˇ'foo', [1, 2, 3]);": "",
    "let result = curried_fun()ˇ();": "",
    "let result = curried_fun()()ˇ;": "",
    "\n            function test() {\n                console.log('test')ˇ\n            }": "",
    "\n            function test() {\n                console.logˇ('test')\n            }": "",
    "fn main() { let a = 5; }": "",
    "other.rs": "",
    "// Test file": "",
    "fn main() { let a = {5}; }": "",
    "No extra braces from on type formatting should appear in the buffer": "",
    "test language server": "",
    "testOptionValue": "",
    "Should not restart LSP server on an unrelated change": "",
    "Some other server name": "",
    "some other init value": "",
    "Should not restart LSP server on an unrelated LSP settings change": "",
    "anotherInitValue": "",
    "Should restart LSP server on a related LSP settings change": "",
    "Should not restart LSP server on a related LSP settings change that is the same": "",
    "Should restart LSP server on another related LSP settings change": "",
    "some": "",
    "fffffff2": "",
    "fn main() { let a = 2.Some(2)ˇ; }": "",
    "fn main() { let a = Some(2)ˇ; }": "",
    "method id()": "",
    "id": "",
    ".id": "",
    "other": "",
    ".other": "",
    "Should have the context menu deployed": "",
    "Should show the completions menu": "",
    "Now resolved!": "",
    "Docs": "",
    "method id() Now resolved!": "",
    "Should update first completion label, but not second as the filter text did not match.": "",
    "\n        struct TestStruct {\n            field: i32\n        }\n\n        fn mainˇ() {\n            let unused_var = 42;\n            let test_struct = TestStruct { field: 42 };\n        }\n    ": "",
    "\n        struct TestStruct {\n            field: i32\n        }\n\n        «fn main»() {\n            let unused_var = 42;\n            let test_struct = TestStruct { field: 42 };\n        }\n    ": "",
    "Function documentation": "",
    "Remove unused variable": "",
    "Hover popover should be hidden when code action menu is shown": "",
    "main": "",
    "() -> ()": "",
    "TestStruct": "",
    "struct TestStruct": "",
    "Hover popover should be hidden when completion menu is shown": "",
    "!!": "",
    "??": "",
    "Unexpected completion item {unresolved_request:?}": "",
    "No task returned": "",
    "Completion failed": "",
    "Should always resolve once despite multiple selections": "",
    "Should always resolve once after multiple selections and applying the completion": "",
    "fn main() { let a = ??.other; }": "",
    "Should use resolved data when applying the completion": "",
    "abs": "",
    "very": "",
    "special": "",
    "item_{}": "",
    "?": "",
    "default": "",
    "data": "",
    "should have the completions menu": "",
    "Expected to have the completions menu": "",
    "Items sent for resolve should be unchanged modulo resolve `data` filled with default if missing": "",
    "jsx": "",
    "(jsx_self_closing_element) @element": "",
    "bg-blue": "",
    "bg-red": "",
    "bg-yellow": "",
    "<p class=": "",
    " />": "",
    "-": "",
    "test_plugin": "",
    "Test prettier formatting was not applied to the original buffer text": "",
    "Autoformatting (via test prettier) was not applied to the original buffer text": "",
    "\n        struct Row;\n        struct Row1;\n        struct Row2;\n\n        struct Row4;\n        struct Row5;\n        struct Row6;\n\n        struct Row8;\n        struct Row9;\n        struct Row10;": "",
    "struct Row;\n                   struct Row1;\n                   struct Row1.1;\n                   struct Row1.2;\n                   struct Row2;ˇ\n\n                   struct Row4;\n                   struct Row5;\n                   struct Row6;\n\n                   struct Row8;\n                   ˇstruct Row9;\n                   struct Row9.1;\n                   struct Row9.2;\n                   struct Row9.3;\n                   struct Row10;": "",
    "struct Row;\n                   struct Row1;\n                   struct Row2;\n                   struct Row2.1;\n                   struct Row2.2;\n                   «ˇ\n                   struct Row4;\n                   struct» Row5;\n                   «struct Row6;\n                   ˇ»\n                   struct Row9.1;\n                   struct Row9.2;\n                   struct Row9.3;\n                   struct Row8;\n                   struct Row9;\n                   struct Row10;": "",
    "struct Row;\n                   ˇ// something on the top\n                   struct Row1;\n                   struct Row2;\n                   struct Roˇw3.1;\n                   struct Row2.2;\n                   struct Row2.3;ˇ\n\n                   struct Row4;\n                   struct ˇRow5.1;\n                   struct Row5.2;\n                   struct «Rowˇ»5.3;\n                   struct Row5;\n                   struct Row6;\n                   ˇ\n                   struct Row9.1;\n                   struct «Rowˇ»9.2;\n                   struct «ˇRow»9.3;\n                   struct Row8;\n                   struct Row9;\n                   «ˇ// something on bottom»\n                   struct Row10;": "",
    "struct Row;\n                   ˇstruct Row1;\n                   struct Row2;\n                   ˇ\n                   struct Row4;\n                   ˇstruct Row5;\n                   struct Row6;\n                   ˇ\n                   ˇstruct Row8;\n                   struct Row9;\n                   ˇstruct Row10;": "",
    "struct Row;\n                   struct Row1;\n                   struct Row33;\n                   ˇ\n                   struct Row4;\n                   struct Row5;\n                   struct Row6;\n                   ˇ\n                   struct Row99;\n                   struct Row9;\n                   struct Row10;": "",
    "struct Row;\n                   struct Row1;\n                   struct Row33;\n                   «ˇ\n                   struct Row4;\n                   struct» Row5;\n                   «struct Row6;\n                   ˇ»\n                   struct Row99;\n                   struct Row9;\n                   struct Row10;": "",
    "ˇstruct Row1.1;\n                   struct Row1;\n                   «ˇstr»uct Row22;\n\n                   struct ˇRow44;\n                   struct Row5;\n                   struct «Rˇ»ow66;ˇ\n\n                   «struˇ»ct Row88;\n                   struct Row9;\n                   struct Row1011;ˇ": "",
    "struct Row;\n                   ˇstruct Row1;\n                   struct Row2;\n                   ˇ\n                   struct Row4;\n                   ˇstruct Row5;\n                   struct Row6;\n                   ˇ\n                   struct Row8;\n                   ˇstruct Row9;\n                   struct Row10;ˇ": "",
    "\n        one\n\n        two\n        three\n        ": "",
    "\\nˇ\\n": "",
    "\n\n        - two\n        - threeˇ\n        +\n        ": "",
    "struct Row;\nstruct Row1;\nstruct Row2;\n\nstruct Row4;\nstruct Row5;\nstruct Row6;\n\nstruct Row8;\nstruct Row9;\nstruct Row10;": "",
    "struct Row;\n                   struct Row2;\n\n                   ˇstruct Row4;\n                   struct Row5;\n                   struct Row6;\n                   ˇ\n                   struct Row8;\n                   struct Row10;": "",
    "struct Row;\n                   struct Row2;\n\n                   «ˇstruct Row4;\n                   struct» Row5;\n                   «struct Row6;\n                   ˇ»\n                   struct Row8;\n                   struct Row10;": "",
    "struct Row;\n                   ˇstruct Row2;\n\n                   struct Row4;\n                   struct Row5;\n                   struct Row6;\n\n                   struct Row8;ˇ\n                   struct Row10;": "",
    "struct Row;\n                   struct Row1;\n                   ˇstruct Row2;\n\n                   struct Row4;\n                   struct Row5;\n                   struct Row6;\n\n                   struct Row8;ˇ\n                   struct Row9;\n                   struct Row10;": "",
    "struct Row;\n                   struct Row2«ˇ;\n                   struct Row4;\n                   struct» Row5;\n                   «struct Row6;\n\n                   struct Row8;ˇ»\n                   struct Row10;": "",
    "struct Row;\n                   struct Row1;\n                   struct Row2«ˇ;\n\n                   struct Row4;\n                   struct» Row5;\n                   «struct Row6;\n\n                   struct Row8;ˇ»\n                   struct Row9;\n                   struct Row10;": "",
    "aaaa\\nbbbb\\ncccc\\ndddd\\neeee\\nffff\\ngggg\\nhhhh\\niiii\\njjjj": "",
    "llll\\nmmmm\\nnnnn\\noooo\\npppp\\nqqqq\\nrrrr\\nssss\\ntttt\\nuuuu": "",
    "vvvv\\nwwww\\nxxxx\\nyyyy\\nzzzz\\n{{{{\\n||||\\n}}}}\\n~~~~\\n\\u{7f}\\u{7f}\\u{7f}\\u{7f}": "",
    "Xaaa\\nXbbb\\nXccc\\n\\nXfff\\nXggg\\n\\nXjjj\\nXlll\\nXmmm\\nXnnn\\n\\nXqqq\\nXrrr\\n\\nXuuu\\nXvvv\\nXwww\\nXxxx\\n\\nX{{{\\nX|||\\n\\nX\\u{7f}\\u{7f}\\u{7f}": "",
    "aaaa\\nbbbb\\ncccc\\ndddd\\neeee\\nffff\\ngggg\\nhhhh\\niiii\\njjjj\\n\\n\\nllll\\nmmmm\\nnnnn\\noooo\\npppp\\nqqqq\\nrrrr\\nssss\\ntttt\\nuuuu\\n\\n\\nvvvv\\nwwww\\nxxxx\\nyyyy\\nzzzz\\n{{{{\\n||||\\n}}}}\\n~~~~\\n\\u{7f}\\u{7f}\\u{7f}\\u{7f}\\n\\n": "",
    "aaaa\\nbbbb\\ncccc\\ndddd\\neeee\\nffff\\ngggg\\nhhhh\\niiii\\njjjj\\n\\n\\nXlll\\nXmmm\\nXnnn\\n\\nXqqq\\nXrrr\\n\\nXuuu\\nXvvv\\nXwww\\nXxxx\\n\\nX{{{\\nX|||\\n\\nX\\u{7f}\\u{7f}\\u{7f}": "",
    "Xlll\\nXmmm\\nXnnn\\nXooo\\nXppp\\nXqqq\\nXrrr\\nXsss\\nXttt\\nXuuu": "",
    "Xvvv\\nXwww\\nXxxx\\nXyyy\\nXzzz\\nX{{{\\nX|||\\nX}}}\\nX~~~\\nX\\u{7f}\\u{7f}\\u{7f}": "",
    "X{}": "",
    "lib.rs": "",
    "active item should be None before the first item is added": "",
    "should have an active item after adding the multi buffer": "",
    "A multi buffer was expected to active after adding": "",
    "should have an active item after navigating into the 1st buffer": "",
    "Should navigate into the 1st buffer and activate it": "",
    "New active item should be a singleton buffer": "",
    "should have navigated into an editor for the 1st buffer": "",
    "should have an active item after navigating back": "",
    "Should navigate back to the multi buffer": "",
    "should have an active item after navigating into the 2nd buffer": "",
    "Should navigate away from the multibuffer": "",
    "Should navigate into the 2nd buffer and activate it": "",
    "should have navigated into an editor": "",
    "should have an active item after navigating back from the 2nd buffer": "",
    "Should navigate back from the 2nd buffer to the multi buffer": "",
    "should have an active item after navigating into the 3rd buffer": "",
    "Should navigate into the 3rd buffer and activate it": "",
    "should have an active item after navigating back from the 3rd buffer": "",
    "Should navigate back from the 3rd buffer to the multi buffer": "",
    "\n          use some::modified;\n\n\n          fn main() {\n        -     println!(": "",
    ");\n        + ˇ    println!(": "",
    ");\n\n              println!(": "",
    ");\n              println!(": "",
    ");\n          }\n        ": "",
    "\n        - use some::mod;\n        + ˇuse some::modified;\n\n\n          fn main() {\n        -     println!(": "",
    ");\n        +     println!(": "",
    ");\n\n        +     println!(": "",
    "\n        - use some::mod;\n        + use some::modified;\n\n        - const A: u32 = 42;\n          ˇ\n          fn main() {\n        -     println!(": "",
    "\n          use some::modified;\n\n          ˇ\n          fn main() {\n              println!(": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n        const C: u32 = 42;\n\n        fn main() {\n            println!(": "",
    "\n        use some::mod2;\n\n        const A: u32 = 42;\n        const C: u32 = 42;\n\n        fn main(ˇ) {\n            //println!(": "",
    ");\n            //\n            //\n        }\n        ": "",
    "\n        - use some::mod1;\n          use some::mod2;\n\n          const A: u32 = 42;\n        - const B: u32 = 42;\n          const C: u32 = 42;\n\n          fn main(ˇ) {\n        -     println!(": "",
    ");\n        +     //println!(": "",
    ");\n        +     //\n        +     //\n          }\n        ": "",
    "new diff base!": "",
    "\n        - new diff base!\n        + use some::mod2;\n        +\n        + const A: u32 = 42;\n        + const C: u32 = 42;\n        +\n        + fn main(ˇ) {\n        +     //println!(": "",
    ");\n        +\n        +     println!(": "",
    ");\n        +     //\n        +     //\n        + }\n        ": "",
    "aaa\\nbbb\\nccc\\nddd\\neee\\nfff\\nggg\\nhhh\\niii\\njjj": "",
    "aaa\\nccc\\nddd\\neee\\nfff\\nggg\\nhhh\\niii\\njjj": "",
    "lll\\nmmm\\nnnn\\nooo\\nppp\\nqqq\\nrrr\\nsss\\nttt\\nuuu": "",
    "lll\\nmmm\\nNNN\\nooo\\nppp\\nqqq\\nrrr\\nsss\\nttt\\nuuu": "",
    "111\\n222\\n333\\n444\\n555\\n777\\n888\\n999\\n000\\n!!!": "",
    "111\\n222\\n333\\n444\\n555\\n666\\n777\\n888\\n999\\n000\\n!!!": "",
    "\n            ˇaaa\n            ccc\n            ddd\n\n            ggg\n            hhh\n\n\n            lll\n            mmm\n            NNN\n\n            qqq\n            rrr\n\n            uuu\n            111\n            222\n            333\n\n            666\n            777\n\n            000\n            !!!": "",
    "\n            «aaa\n          - bbb\n            ccc\n            ddd\n\n            ggg\n            hhh\n\n\n            lll\n            mmm\n          - nnn\n          + NNN\n\n            qqq\n            rrr\n\n            uuu\n            111\n            222\n            333\n\n          + 666\n            777\n\n            000\n            !!!ˇ»": "",
    "aaa\\nbbb\\nccc\\nddd\\neee\\nfff\\nggg\\n": "",
    "aaa\\nBBB\\nBB2\\nccc\\nDDD\\nEEE\\nfff\\nggg\\nhhh\\niii\\n": "",
    "\n            ˇaaa\n          - bbb\n          + BBB\n\n          - ddd\n          - eee\n          + DDD\n          + EEE\n            fff\n\n            iii\n        ": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n\n        fn main() {\n            println!(": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n        const C: u32 = 42;\n        ˇ\n\n        fn main() {\n            println!(": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n      + const B: u32 = 42;\n      + const C: u32 = 42;\n      + ˇ\n\n        fn main() {\n            println!(": "",
    ");\n        }\n      ": "",
    "const D: u32 = 42;\\n": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n      + const B: u32 = 42;\n      + const C: u32 = 42;\n      + const D: u32 = 42;\n      + ˇ\n\n        fn main() {\n            println!(": "",
    "const E: u32 = 42;\\n": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n      + const B: u32 = 42;\n      + const C: u32 = 42;\n      + const D: u32 = 42;\n      + const E: u32 = 42;\n      + ˇ\n\n        fn main() {\n            println!(": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n      + const B: u32 = 42;\n      + const C: u32 = 42;\n      + const D: u32 = 42;\n      + const E: u32 = 42;\n        ˇ\n        fn main() {\n            println!(": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n      + const B: u32 = 42;\n        ˇ\n        fn main() {\n            println!(": "",
    "\n        ˇ\n        fn main() {\n            println!(": "",
    "\n        one\n        two\n        three\n        four\n        five\n        ": "",
    "\n        one\n        ˇthree\n        five\n    ": "",
    "\n        one\n      - two\n        ˇthree\n      - four\n        five\n    ": "",
    "\n        one\n        ˇTWO\n        three\n        four\n        five\n    ": "",
    "\n            one\n          - two\n          + ˇTWO\n            three\n            four\n            five\n        ": "",
    "\n            one\n            ˇTWO\n            three\n            four\n            five\n        ": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n        const C: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
    ");\n        }\n    ": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        ˇconst B: u32 = 42;\n        const C: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n      - const A: u32 = 42;\n        ˇconst B: u32 = 42;\n        const C: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n      - const A: u32 = 42;\n      - const B: u32 = 42;\n        ˇconst C: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n      - const A: u32 = 42;\n      - const B: u32 = 42;\n      - const C: u32 = 42;\n        ˇ\n\n        fn main() {\n            println!(": "",
    "replacement": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n      - const A: u32 = 42;\n      - const B: u32 = 42;\n      - const C: u32 = 42;\n      -\n      + replacementˇ\n\n        fn main() {\n            println!(": "",
    "\n        one\n        two\n        three\n        four\n        five\n    ": "",
    "\n        one\n        two\n        fˇour\n        five\n        ": "",
    "\n          one\n          two\n        - three\n          fˇour\n          five\n        ": "",
    "\n          one\n          two\n        - threeˇ\n        - four\n        + our\n          five\n        ": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n        const C: u32 = 42;\n        const D: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
    ");\n        }": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n        const C: u32 = 43ˇ\n        const D: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n      - const C: u32 = 42;\n      + const C: u32 = 43ˇ\n        const D: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
    "\\nnew_line\\n": "",
    "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n      - const C: u32 = 42;\n      + const C: u32 = 43\n      + new_line\n      + ˇ\n        const D: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
    "\n            ˇfn main() {\n                println!(": "",
    ");\n            }\n        ": "",
    "\n            + ˇfn main() {\n            +     println!(": "",
    ");\n            + }\n        ": "",
    "Active indent guide indices do not match": "",
    "Indent guides do not match": "",
    "\n        fn main() {\n            let a = 1;\n        }": "",
    "\n        fn main() {\n            let a = 1;\n            let b = 2;\n        }": "",
    "\n        fn main() {\n            let a = 1;\n            if a == 3 {\n                let b = 2;\n            } else {\n                let c = 3;\n            }\n        }": "",
    "\n        fn main() {\n            let a = 1;\n                let b = 2;\n            let c = 3;\n        }": "",
    "\n        fn main() {\n            let a = 1;\n\n            let c = 3;\n        }": "",
    "\n        fn main() {\n            let a = 1;\n\n            let c = 3;\n\n            if a == 3 {\n                let b = 2;\n            } else {\n                let c = 3;\n            }\n        }": "",
    "\n        fn main() {\n            if a {\n                b(\n                    c,\n                    d,\n                )\n            } else {\n                e(\n                    f\n                )\n            }\n        }": "",
    "\n            fn main() {\n                if a {\n                    b(⋯\n                    )\n                } else {\n                    e(\n                        f\n                    )\n                }\n            }": "",
    "\n        block1\n            block2\n                block3\n                    block4\n            block2\n        block1\n        block1": "",
    "\n        block1\n            block2\n                block3\n\n        block1\n        block1": "",
    "\n        function component() {\n        \\treturn (\n        \\t\\t\\t\n        \\t\\t<div>\n        \\t\\t\\t<abc></abc>\n        \\t\\t</div>\n        \\t)\n        }": "",
    "\n        function component() {\n        \\treturn (\n        \\t\n        \\t\\t<div>\n        \\t\\t\\t<abc></abc>\n        \\t\\t</div>\n        \\t)\n        }": "",
    "\n        block1\n\n\n\n            block2\n        ": "",
    "\n        def a:\n        \\tb = 3\n        \\tif True:\n        \\t\\tc = 4\n        \\t\\td = 5\n        \\tprint(b)\n        ": "",
    "\n    fn main() {\n        let a = 1;\n    }": "",
    "\n    fn main() {\n        if 1 == 2 {\n            let a = 1;\n        }\n    }": "",
    "\n    fn main() {\n        let a = 1;\n\n        let b = 2;\n    }": "",
    "\n    def m:\n        a = 1\n        pass": "",
    "\n        impl A {\n            fn b() {\n                0;\n                3;\n                5;\n                6;\n                7;\n            }\n        }\n        ": "",
    "\n        impl A {\n            fn b() {\n                0;\n                1;\n                2;\n                3;\n                4;\n            }\n            fn c() {\n                5;\n                6;\n                7;\n            }\n        }\n        ": "",
    "\n          impl A {\n              fn b() {\n                  0;\n        -         1;\n        -         2;\n                  3;\n        -         4;\n        -     }\n        -     fn c() {\n                  5;\n                  6;\n                  7;\n              }\n          }\n          ˇ": "",
    "\n        a\n        b\n        c\n        ": "",
    "\n        ˇA\n        b\n        C\n        ": "",
    "\n        - a\n        + ˇA\n          b\n        - c\n        + C\n        ": "",
    "\n          ˇA\n          b\n        - c\n        + C\n        ": "",
    "\n        - a\n        + ˇA\n          b\n          C\n        ": "",
    "\n        ˇA\n        b\n        ": "",
    "\n        - ˇa\n        + A\n          b\n        ": "",
    "\n            - ˇa\n            + A\n              b\n            - c\n            ": "",
    "\n        ˇb\n        c\n        ": "",
    "\n        - a\n          ˇb\n          c\n        ": "",
    "\n          ˇb\n          c\n        ": "",
    "/test": "",
    ".git": "",
    "file-1": "",
    "ONE\\n": "",
    "file-2": "",
    "TWO\\n": "",
    "file-3": "",
    "THREE\\n": "",
    "/test/.git": "",
    "two\\n": "",
    "three\\n": "",
    "deadbeef": "",
    "/test/file-{}": "",
    "\n        one\n        TWO\n        ˇTHREE\n        FOUR\n        five\n    ": "",
    "\n        one\n        TWO\n        THREE\n        FOUR\n        five\n    ": "",
    "\n        one\n        TWO\n        ˇTHREE-HUNDRED\n        FOUR\n        five\n    ": "",
    "\n        one\n        TWO\n        THREE-HUNDRED\n        FOUR\n        five\n    ": "",
    "ˇone\n        two\n\n        three\n        fourˇ\n        five\n\n        siˇx": "",
    "AAAA": "",
    "AAAAˇone\n        two\n\n        three\n        fourAAAAˇ\n        five\n\n        siAAAAˇx": "",
    "let foo = 1;\nlet foo = 2;\nlet foo = 3;\nlet fooˇ = 4;\nlet foo = 5;\nlet foo = 6;\nlet foo = 7;\nlet foo = 8;\nlet foo = 9;\nlet foo = 10;\nlet foo = 11;\nlet foo = 12;\nlet foo = 13;\nlet foo = 14;\nlet foo = 15;": "",
    "Default next scroll direction is center": "",
    "After center, next scroll direction should be top": "",
    "After top, next scroll direction should be bottom": "",
    "After bottom, scrolling should start over": "",
    "Scrolling continues if retriggered fast enough": "",
    "If scrolling is not triggered fast enough, it should reset": "",
    "fn one() {\n            let mut a = ˇtwo();\n        }\n\n        fn two() {}": "",
    "Failed to navigate to definition": "",
    "Should have navigated to definition from the GetDefinition response": "",
    "fn one() {\n            let mut a = two();\n        }\n\n        fn «twoˇ»() {}": "",
    "Initially, only one, test, editor should be open in the workspace": "",
    "Asserted len is 1": "",
    "Failed to navigate to lookup references": "",
    "Should have navigated to references as a fallback after empty GoToDefinition response": "",
    "After falling back to references search, we open a new editor with the results": "",
    "Should have one non-test editor now": "",
    "fn one() {\\n    let mut a = two();\\n}": "",
    "Should use the range from the references response and not the GoToDefinition one": "",
    "fn one() {\n        let mut a = ˇtwo();\n    }\n\n    fn two() {}": "",
    "Should not call for references with no go to definition fallback": "",
    "Should have called the go_to_definition handler": "",
    "After unsuccessful fallback, no other editor should have been opened": "",
    "\n        #[cfg(test)]\n        mod tests() {\n            #[test]\n            fn runnable_1() {\n                let a = 1;\n            }\n\n            #[test]\n            fn runnable_2() {\n                let a = 1;\n                let b = 2;\n            }\n        }\n    ": "",
    "Should find task for cursor inside runnable_1": "",
    "Should find task when cursor is on function name": "",
    "vvvv\\nwwww\\nxxxx\\nyyyy\\nzzzz\\n1111\\n2222\\n3333\\n4444\\n5555": "",
    "first.rs": "",
    "second.rs": "",
    "third.rs": "",
    "\\n\\naaaa\\nbbbb\\ncccc\\n\\n\\nffff\\ngggg\\n\\n\\njjjj\\n\\n\\nllll\\nmmmm\\nnnnn\\n\\n\\nqqqq\\nrrrr\\n\\n\\nuuuu\\n\\n\\nvvvv\\nwwww\\nxxxx\\n\\n\\n1111\\n2222\\n\\n\\n5555": "",
    "\\n\\n\\n\\nllll\\nmmmm\\nnnnn\\n\\n\\nqqqq\\nrrrr\\n\\n\\nuuuu\\n\\n\\nvvvv\\nwwww\\nxxxx\\n\\n\\n1111\\n2222\\n\\n\\n5555": "",
    "After folding the first buffer, its text should not be displayed": "",
    "\\n\\n\\n\\n\\n\\nvvvv\\nwwww\\nxxxx\\n\\n\\n1111\\n2222\\n\\n\\n5555": "",
    "After folding the second buffer, its text should not be displayed": "",
    "\\n\\n\\n\\n\\n": "",
    "After folding the third buffer, its text should not be displayed": "",
    "\\n\\n\\n\\nllll\\nmmmm\\nnnnn\\n\\n\\nqqqq\\nrrrr\\n\\n\\nuuuu\\n\\n": "",
    "After unfolding the second buffer, its text should be displayed": "",
    "bbbb": "",
    "B": "",
    "\\n\\nB\\n\\n\\n\\n\\n\\n\\nllll\\nmmmm\\nnnnn\\n\\n\\nqqqq\\nrrrr\\n\\n\\nuuuu\\n\\n": "",
    "After unfolding the first buffer, its and 2nd buffer's text should be displayed": "",
    "\\n\\nB\\n\\n\\n\\n\\n\\n\\nllll\\nmmmm\\nnnnn\\n\\n\\nqqqq\\nrrrr\\n\\n\\nuuuu\\n\\n\\nvvvv\\nwwww\\nxxxx\\n\\n\\n1111\\n2222\\n\\n\\n5555": "",
    "After unfolding the all buffers, all original text should be displayed": "",
    "1111\\n2222\\n3333": "",
    "4444\\n5555\\n6666": "",
    "7777\\n8888\\n9999": "",
    "\\n\\n1111\\n2222\\n3333\\n\\n\\n4444\\n5555\\n6666\\n\\n\\n7777\\n8888\\n9999": "",
    "\\n\\n\\n\\n4444\\n5555\\n6666\\n\\n\\n7777\\n8888\\n9999": "",
    "\\n\\n\\n\\n\\n\\n7777\\n8888\\n9999": "",
    "\\n\\n\\n\\n4444\\n5555\\n6666\\n\\n": "",
    "\\n\\n1111\\n2222\\n3333\\n\\n\\n4444\\n5555\\n6666\\n\\n": "",
    "After unfolding the first buffer, its text should be displayed": "",
    "After unfolding all buffers, all original text should be displayed": "",
    "\\n\\n{sample_text}": "",
    "keymaps/default-linux.json": "",
    "a0\\nb0\\nc0\\nd0\\ne0\\n": "",
    "a1\\nb1\\nc1\\nd1\\ne1\\n": "",
    "a2\\nb2\\nc2\\nd2\\ne2\\n": "",
    "a3\\nb3\\nc3\\nd3\\ne3\\n": "",
    "\n        [EXCERPT]\n        ˇ[FOLDED]\n        [EXCERPT]\n        a1\n        b1\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        [FOLDED]\n        ": "",
    "down": "",
    "\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        ˇa1\n        b1\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        [FOLDED]\n        ": "",
    "\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        a1\n        ˇb1\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        [FOLDED]\n        ": "",
    "\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        a1\n        b1\n        ˇ[EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        [FOLDED]\n        ": "",
    "\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        a1\n        b1\n        [EXCERPT]\n        ˇ[FOLDED]\n        [EXCERPT]\n        [FOLDED]\n        ": "",
    "\n            [EXCERPT]\n            [FOLDED]\n            [EXCERPT]\n            a1\n            b1\n            [EXCERPT]\n            [FOLDED]\n            [EXCERPT]\n            ˇ[FOLDED]\n            ": "",
    "up": "",
    "\n            [EXCERPT]\n            ˇ[FOLDED]\n            [EXCERPT]\n            a1\n            b1\n            [EXCERPT]\n            [FOLDED]\n            [EXCERPT]\n            [FOLDED]\n            ": "",
    "Hello, world!": "",
    " beautiful": "",
    "Hello, beautiful world!": "",
    "This is a test.": "",
    "That": "",
    "That is a test.": "",
    "Greetings": "",
    " and universe": "",
    "Greetings, world and universe!": "",
    "First line\\nSecond line\\nThird line\\nFourth line": "",
    "modified": "",
    "New third line": "",
    " updated": "",
    "Second modified\\nNew third line\\nFourth updated line": "",
    " digital": "",
    "{}": "",
    "hello world": "",
    "hello Earth!!": "",
    "\n        struct Fˇoo {}\n    ": "",
    "Prepare rename was not started": "",
    "Prepare rename failed": "",
    "FooRenamed": "",
    "Confirm rename was not started": "",
    "Confirm rename failed": "",
    "\n        struct FooRenamedˇ {}\n    ": "",
    "\n            (": "",
    " @open ": "",
    " @close)\n            (": "",
    "#,\n        )\n        .unwrap(),\n    );\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n\n    cx.set_state(indoc! {": "",
    "});\n    cx.update_editor(|e, window, cx| e.newline(&Newline, window, cx));\n    cx.assert_editor_state(indoc! {": "",
    "});\n\n    cx.set_state(indoc! {": "",
    "});\n}\n\n#[gpui::test(iterations = 10)]\nasync fn test_apply_code_lens_actions_with_commands(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_tree(\n        path!(": "",
    ").as_ref()], cx).await;\n    let workspace = cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let cx = &mut VisualTestContext::from_window(*workspace.deref(), cx);\n\n    let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n    language_registry.add(Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
    ".to_string()],\n                ..Default::default()\n            },\n            ..Default::default()\n        },\n        Some(tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into()),\n    )));\n    let mut fake_language_servers = language_registry.register_fake_lsp(\n        ": "",
    ",\n        FakeLspAdapter {\n            capabilities: lsp::ServerCapabilities {\n                code_lens_provider: Some(lsp::CodeLensOptions {\n                    resolve_provider: Some(true),\n                }),\n                execute_command_provider: Some(lsp::ExecuteCommandOptions {\n                    commands: vec![": "",
    ".to_string()],\n                    ..lsp::ExecuteCommandOptions::default()\n                }),\n                ..lsp::ServerCapabilities::default()\n            },\n            ..FakeLspAdapter::default()\n        },\n    );\n\n    let (buffer, _handle) = project\n        .update(cx, |p, cx| {\n            p.open_local_buffer_with_lsp(path!(": "",
    "), cx)\n        })\n        .await\n        .unwrap();\n    cx.executor().run_until_parked();\n\n    let fake_server = fake_language_servers.next().await.unwrap();\n\n    let buffer_snapshot = buffer.update(cx, |buffer, _| buffer.snapshot());\n    let anchor = buffer_snapshot.anchor_at(0, text::Bias::Left);\n    drop(buffer_snapshot);\n    let actions = cx\n        .update_window(*workspace, |_, window, cx| {\n            project.code_actions(&buffer, anchor..anchor, window, cx)\n        })\n        .unwrap();\n\n    fake_server\n        .set_request_handler::<lsp::request::CodeLensRequest, _, _>(|_, _| async move {\n            Ok(Some(vec![\n                lsp::CodeLens {\n                    range: lsp::Range::default(),\n                    command: Some(lsp::Command {\n                        title: ": "",
    ".to_owned(),\n                        command: ": "",
    ".to_owned(),\n                        arguments: None,\n                    }),\n                    data: None,\n                },\n                lsp::CodeLens {\n                    range: lsp::Range::default(),\n                    command: Some(lsp::Command {\n                        title: ": "",
    ".to_owned(),\n                        arguments: None,\n                    }),\n                    data: None,\n                },\n                lsp::CodeLens {\n                    range: lsp::Range {\n                        start: lsp::Position {\n                            line: 1,\n                            character: 1,\n                        },\n                        end: lsp::Position {\n                            line: 1,\n                            character: 1,\n                        },\n                    },\n                    command: Some(lsp::Command {\n                        title: ": "",
    ".to_owned(),\n                        arguments: None,\n                    }),\n                    data: None,\n                },\n            ]))\n        })\n        .next()\n        .await;\n\n    let actions = actions.await.unwrap();\n    assert_eq!(\n        actions.len(),\n        1,\n        ": "",
    "\n    );\n    let action = actions[0].clone();\n    let apply = project.update(cx, |project, cx| {\n        project.apply_code_action(buffer.clone(), action, true, cx)\n    });\n\n    // Resolving the code action does not populate its edits. In absence of\n    // edits, we must execute the given command.\n    fake_server.set_request_handler::<lsp::request::CodeLensResolve, _, _>(\n        |mut lens, _| async move {\n            let lens_command = lens.command.as_mut().expect(": "",
    ");\n            assert_eq!(lens_command.title, ": "",
    ");\n            lens_command.arguments = Some(vec![json!(": "",
    ")]);\n            Ok(lens)\n        },\n    );\n\n    // While executing the command, the language server sends the editor\n    // a `workspaceEdit` request.\n    fake_server\n        .set_request_handler::<lsp::request::ExecuteCommand, _, _>({\n            let fake = fake_server.clone();\n            move |params, _| {\n                assert_eq!(params.command, ": "",
    ");\n                let fake = fake.clone();\n                async move {\n                    fake.server\n                        .request::<lsp::request::ApplyWorkspaceEdit>(\n                            lsp::ApplyWorkspaceEditParams {\n                                label: None,\n                                edit: lsp::WorkspaceEdit {\n                                    changes: Some(\n                                        [(\n                                            lsp::Url::from_file_path(path!(": "",
    ")).unwrap(),\n                                            vec![lsp::TextEdit {\n                                                range: lsp::Range::new(\n                                                    lsp::Position::new(0, 0),\n                                                    lsp::Position::new(0, 0),\n                                                ),\n                                                new_text: ": "",
    ".into(),\n                                            }],\n                                        )]\n                                        .into_iter()\n                                        .collect(),\n                                    ),\n                                    ..Default::default()\n                                },\n                            },\n                        )\n                        .await\n                        .into_response()\n                        .unwrap();\n                    Ok(Some(json!(null)))\n                }\n            }\n        })\n        .next()\n        .await;\n\n    // Applying the code lens command returns a project transaction containing the edits\n    // sent by the language server in its `workspaceEdit` request.\n    let transaction = apply.await.unwrap();\n    assert!(transaction.0.contains_key(&buffer));\n    buffer.update(cx, |buffer, cx| {\n        assert_eq!(buffer.text(), ": "",
    ");\n        buffer.undo(cx);\n        assert_eq!(buffer.text(), ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_editor_restore_data_different_in_panes(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    let main_text = r#": "",
    "3": "",
    "4": "",
    "5": "",
    "#;\n    let lib_text = ": "",
    ";\n    fs.insert_tree(\n        path!(": "",
    ": lib_text,\n            ": "",
    ": main_text,\n        }),\n    )\n    .await;\n\n    let project = Project::test(fs, [path!(": "",
    ").as_ref()], cx).await;\n    let (workspace, cx) =\n        cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let worktree_id = workspace.update(cx, |workspace, cx| {\n        workspace.project().update(cx, |project, cx| {\n            project.worktrees(cx).next().unwrap().read(cx).id()\n        })\n    });\n\n    let expected_ranges = vec![\n        Point::new(0, 0)..Point::new(0, 0),\n        Point::new(1, 0)..Point::new(1, 1),\n        Point::new(2, 0)..Point::new(2, 2),\n        Point::new(3, 0)..Point::new(3, 3),\n    ];\n\n    let pane_1 = workspace.update(cx, |workspace, _| workspace.active_pane().clone());\n    let editor_1 = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, ": "",
    "),\n                Some(pane_1.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane_1.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                main_text,\n                ": "",
    ",\n            );\n            assert_eq!(\n                editor\n                    .selections\n                    .all::<Point>(cx)\n                    .into_iter()\n                    .map(|s| s.range())\n                    .collect::<Vec<_>>(),\n                vec![Point::zero()..Point::zero()],\n                ": "",
    ",\n            );\n        })\n    });\n    editor_1.update_in(cx, |editor, window, cx| {\n        editor.change_selections(None, window, cx, |s| {\n            s.select_ranges(expected_ranges.clone());\n        });\n    });\n\n    let pane_2 = workspace.update_in(cx, |workspace, window, cx| {\n        workspace.split_pane(pane_1.clone(), SplitDirection::Right, window, cx)\n    });\n    let editor_2 = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, ": "",
    "),\n                Some(pane_2.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane_2.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                main_text,\n                ": "",
    ",\n            );\n        })\n    });\n\n    editor_2.update_in(cx, |editor, window, cx| {\n        editor.fold_ranges(expected_ranges.clone(), false, window, cx);\n    });\n\n    let _other_editor_1 = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, ": "",
    "),\n                Some(pane_1.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane_1\n        .update_in(cx, |pane, window, cx| {\n            pane.close_inactive_items(&CloseInactiveItems::default(), window, cx)\n        })\n        .await\n        .unwrap();\n    drop(editor_1);\n    pane_1.update(cx, |pane, cx| {\n        pane.active_item()\n            .unwrap()\n            .downcast::<Editor>()\n            .unwrap()\n            .update(cx, |editor, cx| {\n                assert_eq!(\n                    editor.display_text(cx),\n                    lib_text,\n                    ": "",
    ",\n                );\n            });\n        assert_eq!(pane.items().count(), 1, ": "",
    ");\n    });\n\n    let _other_editor_2 = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, ": "",
    "),\n                Some(pane_2.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane_2\n        .update_in(cx, |pane, window, cx| {\n            pane.close_inactive_items(&CloseInactiveItems::default(), window, cx)\n        })\n        .await\n        .unwrap();\n    drop(editor_2);\n    pane_2.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                lib_text,\n                ": "",
    ",\n            );\n        });\n        assert_eq!(\n            pane.items().count(),\n            1,\n            ": "",
    ",\n        );\n    });\n\n    let _editor_1_reopened = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, ": "",
    "),\n                Some(pane_1.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    let _editor_2_reopened = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, ": "",
    "),\n                Some(pane_2.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane_1.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                main_text,\n                ": "",
    ",\n            );\n            assert_eq!(\n                editor\n                    .selections\n                    .all::<Point>(cx)\n                    .into_iter()\n                    .map(|s| s.range())\n                    .collect::<Vec<_>>(),\n                expected_ranges,\n                ": "",
    ",\n            );\n        })\n    });\n    pane_2.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                r#": "",
    "#,\n                ": "",
    ",\n            );\n        })\n    });\n}\n\n#[gpui::test]\nasync fn test_editor_does_not_restore_data_when_turned_off(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    let main_text = r#": "",
    ").as_ref()], cx).await;\n    let (workspace, cx) =\n        cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let worktree_id = workspace.update(cx, |workspace, cx| {\n        workspace.project().update(cx, |project, cx| {\n            project.worktrees(cx).next().unwrap().read(cx).id()\n        })\n    });\n\n    let pane = workspace.update(cx, |workspace, _| workspace.active_pane().clone());\n    let editor = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, ": "",
    "),\n                Some(pane.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                main_text,\n                ": "",
    ",\n            );\n        })\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.fold_ranges(vec![Point::new(0, 0)..Point::new(0, 0)], false, window, cx);\n    });\n\n    cx.update_global(|store: &mut SettingsStore, cx| {\n        store.update_user_settings::<WorkspaceSettings>(cx, |s| {\n            s.restore_on_file_reopen = Some(false);\n        });\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.fold_ranges(\n            vec![\n                Point::new(1, 0)..Point::new(1, 1),\n                Point::new(2, 0)..Point::new(2, 2),\n                Point::new(3, 0)..Point::new(3, 3),\n            ],\n            false,\n            window,\n            cx,\n        );\n    });\n    pane.update_in(cx, |pane, window, cx| {\n        pane.close_all_items(&CloseAllItems::default(), window, cx)\n    })\n    .await\n    .unwrap();\n    pane.update(cx, |pane, _| {\n        assert!(pane.active_item().is_none());\n    });\n    cx.update_global(|store: &mut SettingsStore, cx| {\n        store.update_user_settings::<WorkspaceSettings>(cx, |s| {\n            s.restore_on_file_reopen = Some(true);\n        });\n    });\n\n    let _editor_reopened = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, ": "",
    "\n            );\n        })\n    });\n}\n\n#[gpui::test]\nasync fn test_hide_mouse_context_menu_on_modal_opened(cx: &mut TestAppContext) {\n    struct EmptyModalView {\n        focus_handle: gpui::FocusHandle,\n    }\n    impl EventEmitter<DismissEvent> for EmptyModalView {}\n    impl Render for EmptyModalView {\n        fn render(&mut self, _: &mut Window, _: &mut Context<'_, Self>) -> impl IntoElement {\n            div()\n        }\n    }\n    impl Focusable for EmptyModalView {\n        fn focus_handle(&self, _cx: &App) -> gpui::FocusHandle {\n            self.focus_handle.clone()\n        }\n    }\n    impl workspace::ModalView for EmptyModalView {}\n    fn new_empty_modal_view(cx: &App) -> EmptyModalView {\n        EmptyModalView {\n            focus_handle: cx.focus_handle(),\n        }\n    }\n\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    let project = Project::test(fs, [], cx).await;\n    let workspace = cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let buffer = cx.update(|cx| MultiBuffer::build_simple(": "",
    ", cx));\n    let cx = &mut VisualTestContext::from_window(*workspace.deref(), cx);\n    let editor = cx.new_window_entity(|window, cx| {\n        Editor::new(\n            EditorMode::full(),\n            buffer,\n            Some(project.clone()),\n            window,\n            cx,\n        )\n    });\n    workspace\n        .update(cx, |workspace, window, cx| {\n            workspace.add_item_to_active_pane(Box::new(editor.clone()), None, true, window, cx);\n        })\n        .unwrap();\n    editor.update_in(cx, |editor, window, cx| {\n        editor.open_context_menu(&OpenContextMenu, window, cx);\n        assert!(editor.mouse_context_menu.is_some());\n    });\n    workspace\n        .update(cx, |workspace, window, cx| {\n            workspace.toggle_modal(window, cx, |_, cx| new_empty_modal_view(cx));\n        })\n        .unwrap();\n    cx.read(|cx| {\n        assert!(editor.read(cx).mouse_context_menu.is_none());\n    });\n}\n\n#[gpui::test]\nasync fn test_html_linked_edits_on_completion(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_file(path!(": "",
    "), Default::default())\n        .await;\n\n    let project = Project::test(fs, [path!(": "",
    ").as_ref()], cx).await;\n\n    let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n    let html_language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
    ".to_string()],\n                ..LanguageMatcher::default()\n            },\n            brackets: BracketPairConfig {\n                pairs: vec![BracketPair {\n                    start: ": "",
    ".into(),\n                    end: ": "",
    ".into(),\n                    close: true,\n                    ..Default::default()\n                }],\n                ..Default::default()\n            },\n            ..Default::default()\n        },\n        Some(tree_sitter_html::LANGUAGE.into()),\n    ));\n    language_registry.add(html_language);\n    let mut fake_servers = language_registry.register_fake_lsp(\n        ": "",
    ",\n        FakeLspAdapter {\n            capabilities: lsp::ServerCapabilities {\n                completion_provider: Some(lsp::CompletionOptions {\n                    resolve_provider: Some(true),\n                    ..Default::default()\n                }),\n                ..Default::default()\n            },\n            ..Default::default()\n        },\n    );\n\n    let workspace = cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let cx = &mut VisualTestContext::from_window(*workspace, cx);\n\n    let worktree_id = workspace\n        .update(cx, |workspace, _window, cx| {\n            workspace.project().update(cx, |project, cx| {\n                project.worktrees(cx).next().unwrap().read(cx).id()\n            })\n        })\n        .unwrap();\n    project\n        .update(cx, |project, cx| {\n            project.open_local_buffer_with_lsp(path!(": "",
    "), None, true, window, cx)\n        })\n        .unwrap()\n        .await\n        .unwrap()\n        .downcast::<Editor>()\n        .unwrap();\n\n    let fake_server = fake_servers.next().await.unwrap();\n    editor.update_in(cx, |editor, window, cx| {\n        editor.set_text(": "",
    ", window, cx);\n        editor.change_selections(None, window, cx, |selections| {\n            selections.select_ranges([Point::new(0, 3)..Point::new(0, 3)]);\n        });\n        let Some((buffer, _)) = editor\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(editor.selections.newest_anchor().start, cx)\n        else {\n            panic!(": "",
    ");\n        };\n        let buffer = buffer.read(cx);\n        let buffer_id = buffer.remote_id();\n        let opening_range =\n            buffer.anchor_before(Point::new(0, 1))..buffer.anchor_after(Point::new(0, 3));\n        let closing_range =\n            buffer.anchor_before(Point::new(0, 6))..buffer.anchor_after(Point::new(0, 8));\n        let mut linked_ranges = HashMap::default();\n        linked_ranges.insert(\n            buffer_id,\n            vec![(opening_range.clone(), vec![closing_range.clone()])],\n        );\n        editor.linked_edit_ranges = LinkedEditingRanges(linked_ranges);\n    });\n    let mut completion_handle =\n        fake_server.set_request_handler::<lsp::request::Completion, _, _>(move |_, _| async move {\n            Ok(Some(lsp::CompletionResponse::Array(vec![\n                lsp::CompletionItem {\n                    label: ": "",
    ".to_string(),\n                    text_edit: Some(lsp::CompletionTextEdit::InsertAndReplace(\n                        lsp::InsertReplaceEdit {\n                            new_text: ": "",
    ".to_string(),\n                            insert: lsp::Range::new(\n                                lsp::Position::new(0, 1),\n                                lsp::Position::new(0, 3),\n                            ),\n                            replace: lsp::Range::new(\n                                lsp::Position::new(0, 1),\n                                lsp::Position::new(0, 3),\n                            ),\n                        },\n                    )),\n                    ..Default::default()\n                },\n            ])))\n        });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.show_completions(&ShowCompletions { trigger: None }, window, cx);\n    });\n    cx.run_until_parked();\n    completion_handle.next().await.unwrap();\n    editor.update(cx, |editor, _| {\n        assert!(\n            editor.context_menu_visible(),\n            ": "",
    "\n        );\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.confirm_completion(&ConfirmCompletion::default(), window, cx)\n    });\n    cx.executor().run_until_parked();\n    editor.update(cx, |editor, cx| {\n        assert_eq!(editor.text(cx), ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_invisible_worktree_servers(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_tree(\n        path!(": "",
    ": {\n                ": "",
    ",\n            },\n            ": "",
    ": {\n                    ": "",
    ",\n                }\n            }\n        }),\n    )\n    .await;\n\n    let project = Project::test(fs, [path!(": "",
    ").as_ref()], cx).await;\n    let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n    language_registry.add(rust_lang());\n    let _fake_servers = language_registry.register_fake_lsp(\n        ": "",
    ",\n        FakeLspAdapter {\n            ..FakeLspAdapter::default()\n        },\n    );\n    let (workspace, cx) =\n        cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let worktree_id = workspace.update(cx, |workspace, cx| {\n        workspace.project().update(cx, |project, cx| {\n            project.worktrees(cx).next().unwrap().read(cx).id()\n        })\n    });\n\n    let assert_language_servers_count =\n        |expected: usize, context: &str, cx: &mut VisualTestContext| {\n            project.update(cx, |project, cx| {\n                let current = project\n                    .lsp_store()\n                    .read(cx)\n                    .as_local()\n                    .unwrap()\n                    .language_servers\n                    .len();\n                assert_eq!(expected, current, ": "",
    ");\n            });\n        };\n\n    assert_language_servers_count(\n        0,\n        ": "",
    ",\n        cx,\n    );\n    let pane = workspace.update(cx, |workspace, _| workspace.active_pane().clone());\n    let main_editor = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, ": "",
    "),\n                Some(pane.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                ": "",
    ",\n                ": "",
    ",\n            );\n        });\n        assert_eq!(open_editor, main_editor);\n    });\n    assert_language_servers_count(1, ": "",
    ", cx);\n\n    let external_editor = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_abs_path(\n                PathBuf::from(": "",
    "),\n                OpenOptions::default(),\n                window,\n                cx,\n            )\n        })\n        .await\n        .expect(": "",
    ")\n        .downcast::<Editor>()\n        .expect(": "",
    ");\n    pane.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                ": "",
    ",\n            );\n        });\n        assert_eq!(open_editor, external_editor);\n    });\n    assert_language_servers_count(\n        1,\n        ": "",
    ",\n        cx,\n    );\n\n    pane.update_in(cx, |pane, window, cx| {\n        pane.close_active_item(&CloseActiveItem::default(), window, cx)\n    })\n    .await\n    .unwrap();\n    pane.update_in(cx, |pane, window, cx| {\n        pane.navigate_backward(window, cx);\n    });\n    cx.run_until_parked();\n    pane.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                ": "",
    ",\n            );\n        });\n    });\n    assert_language_servers_count(\n        1,\n        ": "",
    ",\n        cx,\n    );\n\n    cx.update(|_, cx| {\n        workspace::reload(&workspace::Reload::default(), cx);\n    });\n    assert_language_servers_count(\n        1,\n        ": "",
    ",\n        cx,\n    );\n}\n\n#[gpui::test]\nasync fn test_tab_in_leading_whitespace_auto_indents_for_python(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let language = languages::language(": "",
    ", tree_sitter_python::LANGUAGE.into());\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n\n    // test cursor move to start of each line on tab\n    // for `if`, `elif`, `else`, `while`, `with` and `for`\n    cx.set_state(indoc! {": "",
    "});\n    cx.update_editor(|e, window, cx| e.tab(&Tab, window, cx));\n    cx.assert_editor_state(indoc! {": "",
    "});\n    // test relative indent is preserved when tab\n    // for `if`, `elif`, `else`, `while`, `with` and `for`\n    cx.update_editor(|e, window, cx| e.tab(&Tab, window, cx));\n    cx.assert_editor_state(indoc! {": "",
    "});\n\n    // test cursor move to start of each line on tab\n    // for `try`, `except`, `else`, `finally`, `match` and `def`\n    cx.set_state(indoc! {": "",
    "});\n    // test relative indent is preserved when tab\n    // for `try`, `except`, `else`, `finally`, `match` and `def`\n    cx.update_editor(|e, window, cx| e.tab(&Tab, window, cx));\n    cx.assert_editor_state(indoc! {": "",
    "});\n}\n\n#[gpui::test]\nasync fn test_outdent_after_input_for_python(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let language = languages::language(": "",
    ", tree_sitter_python::LANGUAGE.into());\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n\n    // test `else` auto outdents when typed inside `if` block\n    cx.set_state(indoc! {": "",
    "});\n    cx.update_editor(|editor, window, cx| {\n        editor.handle_input(": "",
    ", window, cx);\n    });\n    cx.assert_editor_state(indoc! {": "",
    "});\n\n    // test `except` auto outdents when typed inside `try` block\n    cx.set_state(indoc! {": "",
    "});\n\n    // test `else` auto outdents when typed inside `except` block\n    cx.set_state(indoc! {": "",
    "});\n\n    // test `finally` auto outdents when typed inside `else` block\n    cx.set_state(indoc! {": "",
    "});\n\n    // TODO: test `except` auto outdents when typed inside `try` block right after for block\n    // cx.set_state(indoc! {": "",
    "});\n    // cx.update_editor(|editor, window, cx| {\n    //     editor.handle_input(": "",
    ", window, cx);\n    // });\n    // cx.assert_editor_state(indoc! {": "",
    "});\n\n    // TODO: test `else` auto outdents when typed inside `except` block right after for block\n    // cx.set_state(indoc! {": "",
    "});\n\n    // TODO: test `finally` auto outdents when typed inside `else` block right after for block\n    // cx.set_state(indoc! {": "",
    "});\n\n    // test `else` stays at correct indent when typed after `for` block\n    cx.set_state(indoc! {": "",
    "});\n\n    // test does not outdent on typing after line with square brackets\n    cx.set_state(indoc! {": "",
    "});\n}\n\n#[gpui::test]\nasync fn test_indent_on_newline_for_python(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n    update_test_language_settings(cx, |settings| {\n        settings.defaults.extend_comment_on_newline = Some(false);\n    });\n    let mut cx = EditorTestContext::new(cx).await;\n    let language = languages::language(": "",
    ", tree_sitter_python::LANGUAGE.into());\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n\n    // test correct indent after newline on comment\n    cx.set_state(indoc! {": "",
    "});\n    cx.update_editor(|editor, window, cx| {\n        editor.newline(&Newline, window, cx);\n    });\n    cx.assert_editor_state(indoc! {": "",
    "});\n\n    // test correct indent after newline in brackets\n    cx.set_state(indoc! {": "",
    "});\n    cx.update_editor(|editor, window, cx| {\n        editor.newline(&Newline, window, cx);\n    });\n    cx.run_until_parked();\n    cx.assert_editor_state(indoc! {": "",
    "});\n\n    // do not indent after empty lists or dictionaries\n    cx.set_state(indoc! {": "",
    "});\n}\n\nfn empty_range(row: usize, column: usize) -> Range<DisplayPoint> {\n    let point = DisplayPoint::new(DisplayRow(row as u32), column as u32);\n    point..point\n}\n\n#[track_caller]\nfn assert_selection_ranges(marked_text: &str, editor: &mut Editor, cx: &mut Context<Editor>) {\n    let (text, ranges) = marked_text_ranges(marked_text, true);\n    assert_eq!(editor.text(cx), text);\n    assert_eq!(\n        editor.selections.ranges(cx),\n        ranges,\n        ": "",
    ",\n        marked_text\n    );\n}\n\npub fn handle_signature_help_request(\n    cx: &mut EditorLspTestContext,\n    mocked_response: lsp::SignatureHelp,\n) -> impl Future<Output = ()> + use<> {\n    let mut request =\n        cx.set_request_handler::<lsp::request::SignatureHelpRequest, _, _>(move |_, _, _| {\n            let mocked_response = mocked_response.clone();\n            async move { Ok(Some(mocked_response)) }\n        });\n\n    async move {\n        request.next().await;\n    }\n}\n\n#[track_caller]\npub fn check_displayed_completions(expected: Vec<&'static str>, cx: &mut EditorLspTestContext) {\n    cx.update_editor(|editor, _, _| {\n        if let Some(CodeContextMenu::Completions(menu)) = editor.context_menu.borrow().as_ref() {\n            let entries = menu.entries.borrow();\n            let entries = entries\n                .iter()\n                .map(|entry| entry.string.as_str())\n                .collect::<Vec<_>>();\n            assert_eq!(entries, expected);\n        } else {\n            panic!(": "",
    ");\n        }\n    });\n}\n\n/// Handle completion request passing a marked string specifying where the completion\n/// should be triggered from using '|' character, what range should be replaced, and what completions\n/// should be returned using '<' and '>' to delimit the range.\n///\n/// Also see `handle_completion_request_with_insert_and_replace`.\n#[track_caller]\npub fn handle_completion_request(\n    marked_string: &str,\n    completions: Vec<&'static str>,\n    is_incomplete: bool,\n    counter: Arc<AtomicUsize>,\n    cx: &mut EditorLspTestContext,\n) -> impl Future<Output = ()> {\n    let complete_from_marker: TextRangeMarker = '|'.into();\n    let replace_range_marker: TextRangeMarker = ('<', '>').into();\n    let (_, mut marked_ranges) = marked_text_ranges_by(\n        marked_string,\n        vec![complete_from_marker.clone(), replace_range_marker.clone()],\n    );\n\n    let complete_from_position =\n        cx.to_lsp(marked_ranges.remove(&complete_from_marker).unwrap()[0].start);\n    let replace_range =\n        cx.to_lsp_range(marked_ranges.remove(&replace_range_marker).unwrap()[0].clone());\n\n    let mut request =\n        cx.set_request_handler::<lsp::request::Completion, _, _>(move |url, params, _| {\n            let completions = completions.clone();\n            counter.fetch_add(1, atomic::Ordering::Release);\n            async move {\n                assert_eq!(params.text_document_position.text_document.uri, url.clone());\n                assert_eq!(\n                    params.text_document_position.position,\n                    complete_from_position\n                );\n                Ok(Some(lsp::CompletionResponse::List(lsp::CompletionList {\n                    is_incomplete: is_incomplete,\n                    item_defaults: None,\n                    items: completions\n                        .iter()\n                        .map(|completion_text| lsp::CompletionItem {\n                            label: completion_text.to_string(),\n                            text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n                                range: replace_range,\n                                new_text: completion_text.to_string(),\n                            })),\n                            ..Default::default()\n                        })\n                        .collect(),\n                })))\n            }\n        });\n\n    async move {\n        request.next().await;\n    }\n}\n\n/// Similar to `handle_completion_request`, but a [`CompletionTextEdit::InsertAndReplace`] will be\n/// given instead, which also contains an `insert` range.\n///\n/// This function uses markers to define ranges:\n/// - `|` marks the cursor position\n/// - `<>` marks the replace range\n/// - `[]` marks the insert range (optional, defaults to `replace_range.start..cursor_pos`which is what Rust-Analyzer provides)\npub fn handle_completion_request_with_insert_and_replace(\n    cx: &mut EditorLspTestContext,\n    marked_string: &str,\n    completions: Vec<(&'static str, &'static str)>, // (label, new_text)\n    counter: Arc<AtomicUsize>,\n) -> impl Future<Output = ()> {\n    let complete_from_marker: TextRangeMarker = '|'.into();\n    let replace_range_marker: TextRangeMarker = ('<', '>').into();\n    let insert_range_marker: TextRangeMarker = ('{', '}').into();\n\n    let (_, mut marked_ranges) = marked_text_ranges_by(\n        marked_string,\n        vec![\n            complete_from_marker.clone(),\n            replace_range_marker.clone(),\n            insert_range_marker.clone(),\n        ],\n    );\n\n    let complete_from_position =\n        cx.to_lsp(marked_ranges.remove(&complete_from_marker).unwrap()[0].start);\n    let replace_range =\n        cx.to_lsp_range(marked_ranges.remove(&replace_range_marker).unwrap()[0].clone());\n\n    let insert_range = match marked_ranges.remove(&insert_range_marker) {\n        Some(ranges) if !ranges.is_empty() => cx.to_lsp_range(ranges[0].clone()),\n        _ => lsp::Range {\n            start: replace_range.start,\n            end: complete_from_position,\n        },\n    };\n\n    let mut request =\n        cx.set_request_handler::<lsp::request::Completion, _, _>(move |url, params, _| {\n            let completions = completions.clone();\n            counter.fetch_add(1, atomic::Ordering::Release);\n            async move {\n                assert_eq!(params.text_document_position.text_document.uri, url.clone());\n                assert_eq!(\n                    params.text_document_position.position, complete_from_position,\n                    ": "",
    ",\n                );\n                Ok(Some(lsp::CompletionResponse::Array(\n                    completions\n                        .iter()\n                        .map(|(label, new_text)| lsp::CompletionItem {\n                            label: label.to_string(),\n                            text_edit: Some(lsp::CompletionTextEdit::InsertAndReplace(\n                                lsp::InsertReplaceEdit {\n                                    insert: insert_range,\n                                    replace: replace_range,\n                                    new_text: new_text.to_string(),\n                                },\n                            )),\n                            ..Default::default()\n                        })\n                        .collect(),\n                )))\n            }\n        });\n\n    async move {\n        request.next().await;\n    }\n}\n\nfn handle_resolve_completion_request(\n    cx: &mut EditorLspTestContext,\n    edits: Option<Vec<(&'static str, &'static str)>>,\n) -> impl Future<Output = ()> {\n    let edits = edits.map(|edits| {\n        edits\n            .iter()\n            .map(|(marked_string, new_text)| {\n                let (_, marked_ranges) = marked_text_ranges(marked_string, false);\n                let replace_range = cx.to_lsp_range(marked_ranges[0].clone());\n                lsp::TextEdit::new(replace_range, new_text.to_string())\n            })\n            .collect::<Vec<_>>()\n    });\n\n    let mut request =\n        cx.set_request_handler::<lsp::request::ResolveCompletionItem, _, _>(move |_, _, _| {\n            let edits = edits.clone();\n            async move {\n                Ok(lsp::CompletionItem {\n                    additional_text_edits: edits,\n                    ..Default::default()\n                })\n            }\n        });\n\n    async move {\n        request.next().await;\n    }\n}\n\npub(crate) fn update_test_language_settings(\n    cx: &mut TestAppContext,\n    f: impl Fn(&mut AllLanguageSettingsContent),\n) {\n    cx.update(|cx| {\n        SettingsStore::update_global(cx, |store, cx| {\n            store.update_user_settings::<AllLanguageSettings>(cx, f);\n        });\n    });\n}\n\npub(crate) fn update_test_project_settings(\n    cx: &mut TestAppContext,\n    f: impl Fn(&mut ProjectSettings),\n) {\n    cx.update(|cx| {\n        SettingsStore::update_global(cx, |store, cx| {\n            store.update_user_settings::<ProjectSettings>(cx, f);\n        });\n    });\n}\n\npub(crate) fn init_test(cx: &mut TestAppContext, f: fn(&mut AllLanguageSettingsContent)) {\n    cx.update(|cx| {\n        assets::Assets.load_test_fonts(cx);\n        let store = SettingsStore::test(cx);\n        cx.set_global(store);\n        theme::init(theme::LoadThemes::JustBase, cx);\n        release_channel::init(SemanticVersion::default(), cx);\n        client::init_settings(cx);\n        language::init(cx);\n        Project::init_settings(cx);\n        workspace::init_settings(cx);\n        crate::init(cx);\n    });\n\n    update_test_language_settings(cx, f);\n}\n\n#[track_caller]\nfn assert_hunk_revert(\n    not_reverted_text_with_selections: &str,\n    expected_hunk_statuses_before: Vec<DiffHunkStatusKind>,\n    expected_reverted_text_with_selections: &str,\n    base_text: &str,\n    cx: &mut EditorLspTestContext,\n) {\n    cx.set_state(not_reverted_text_with_selections);\n    cx.set_head_text(base_text);\n    cx.executor().run_until_parked();\n\n    let actual_hunk_statuses_before = cx.update_editor(|editor, window, cx| {\n        let snapshot = editor.snapshot(window, cx);\n        let reverted_hunk_statuses = snapshot\n            .buffer_snapshot\n            .diff_hunks_in_range(0..snapshot.buffer_snapshot.len())\n            .map(|hunk| hunk.status().kind)\n            .collect::<Vec<_>>();\n\n        editor.git_restore(&Default::default(), window, cx);\n        reverted_hunk_statuses\n    });\n    cx.executor().run_until_parked();\n    cx.assert_editor_state(expected_reverted_text_with_selections);\n    assert_eq!(actual_hunk_statuses_before, expected_hunk_statuses_before);\n}\n\n#[gpui::test(iterations = 10)]\nasync fn test_pulling_diagnostics(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let diagnostic_requests = Arc::new(AtomicUsize::new(0));\n    let counter = diagnostic_requests.clone();\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_tree(\n        path!(": "",
    ",\n            ": "",
    ").as_ref()], cx).await;\n    let workspace = cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let cx = &mut VisualTestContext::from_window(*workspace, cx);\n\n    let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n    language_registry.add(rust_lang());\n    let mut fake_servers = language_registry.register_fake_lsp(\n        ": "",
    ",\n        FakeLspAdapter {\n            capabilities: lsp::ServerCapabilities {\n                diagnostic_provider: Some(lsp::DiagnosticServerCapabilities::Options(\n                    lsp::DiagnosticOptions {\n                        identifier: None,\n                        inter_file_dependencies: true,\n                        workspace_diagnostics: true,\n                        work_done_progress_options: Default::default(),\n                    },\n                )),\n                ..Default::default()\n            },\n            ..Default::default()\n        },\n    );\n\n    let editor = workspace\n        .update(cx, |workspace, window, cx| {\n            workspace.open_abs_path(\n                PathBuf::from(path!(": "",
    ")),\n                OpenOptions::default(),\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .unwrap()\n        .downcast::<Editor>()\n        .unwrap();\n    let fake_server = fake_servers.next().await.unwrap();\n    let server_id = fake_server.server.server_id();\n    let mut first_request = fake_server\n        .set_request_handler::<lsp::request::DocumentDiagnosticRequest, _, _>(move |params, _| {\n            let new_result_id = counter.fetch_add(1, atomic::Ordering::Release) + 1;\n            let result_id = Some(new_result_id.to_string());\n            assert_eq!(\n                params.text_document.uri,\n                lsp::Url::from_file_path(path!(": "",
    ")).unwrap()\n            );\n            async move {\n                Ok(lsp::DocumentDiagnosticReportResult::Report(\n                    lsp::DocumentDiagnosticReport::Full(lsp::RelatedFullDocumentDiagnosticReport {\n                        related_documents: None,\n                        full_document_diagnostic_report: lsp::FullDocumentDiagnosticReport {\n                            items: Vec::new(),\n                            result_id,\n                        },\n                    }),\n                ))\n            }\n        });\n\n    let ensure_result_id = |expected: Option<String>, cx: &mut TestAppContext| {\n        project.update(cx, |project, cx| {\n            let buffer_id = editor\n                .read(cx)\n                .buffer()\n                .read(cx)\n                .as_singleton()\n                .expect(": "",
    ")\n                .read(cx)\n                .remote_id();\n            let buffer_result_id = project\n                .lsp_store()\n                .read(cx)\n                .result_id(server_id, buffer_id, cx);\n            assert_eq!(expected, buffer_result_id);\n        });\n    };\n\n    ensure_result_id(None, cx);\n    cx.executor().advance_clock(Duration::from_millis(60));\n    cx.executor().run_until_parked();\n    assert_eq!(\n        diagnostic_requests.load(atomic::Ordering::Acquire),\n        1,\n        ": "",
    "\n    );\n    first_request\n        .next()\n        .await\n        .expect(": "",
    ");\n    ensure_result_id(Some(": "",
    ".to_string()), cx);\n\n    // Editing should trigger diagnostics\n    editor.update_in(cx, |editor, window, cx| {\n        editor.handle_input(": "",
    ", window, cx)\n    });\n    cx.executor().advance_clock(Duration::from_millis(60));\n    cx.executor().run_until_parked();\n    assert_eq!(\n        diagnostic_requests.load(atomic::Ordering::Acquire),\n        2,\n        ": "",
    "\n    );\n    ensure_result_id(Some(": "",
    ".to_string()), cx);\n\n    // Moving cursor should not trigger diagnostic request\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(None, window, cx, |s| {\n            s.select_ranges([Point::new(0, 0)..Point::new(0, 0)])\n        });\n    });\n    cx.executor().advance_clock(Duration::from_millis(60));\n    cx.executor().run_until_parked();\n    assert_eq!(\n        diagnostic_requests.load(atomic::Ordering::Acquire),\n        2,\n        ": "",
    ".to_string()), cx);\n    // Multiple rapid edits should be debounced\n    for _ in 0..5 {\n        editor.update_in(cx, |editor, window, cx| {\n            editor.handle_input(": "",
    ", window, cx)\n        });\n    }\n    cx.executor().advance_clock(Duration::from_millis(60));\n    cx.executor().run_until_parked();\n\n    let final_requests = diagnostic_requests.load(atomic::Ordering::Acquire);\n    assert!(\n        final_requests <= 4,\n        ": "",
    ",\n    );\n    ensure_result_id(Some(final_requests.to_string()), cx);\n}\n\n#[gpui::test]\nasync fn test_add_selection_after_moving_with_multiple_cursors(cx: &mut TestAppContext) {\n    // Regression test for issue #11671\n    // Previously, adding a cursor after moving multiple cursors would reset\n    // the cursor count instead of adding to the existing cursors.\n    init_test(cx, |_| {});\n    let mut cx = EditorTestContext::new(cx).await;\n\n    // Create a simple buffer with cursor at start\n    cx.set_state(indoc! {": "",
    "});\n\n    // Add 2 cursors below (so we have 3 total)\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_below(&Default::default(), window, cx);\n        editor.add_selection_below(&Default::default(), window, cx);\n    });\n\n    // Verify we have 3 cursors\n    let initial_count = cx.update_editor(|editor, _, _| editor.selections.count());\n    assert_eq!(\n        initial_count, 3,\n        ": "",
    "\n    );\n\n    // Move down one line\n    cx.update_editor(|editor, window, cx| {\n        editor.move_down(&MoveDown, window, cx);\n    });\n\n    // Add another cursor below\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_below(&Default::default(), window, cx);\n    });\n\n    // Should now have 4 cursors (3 original + 1 new)\n    let final_count = cx.update_editor(|editor, _, _| editor.selections.count());\n    assert_eq!(\n        final_count, 4,\n        ": ""
  },
  "zed/crates/editor/src/editor.rs": {
    "test-support": "",
    "edit_prediction": "",
    "edit_prediction_conflict": "",
    "selected": "",
    "SelectionHistory::insert_transaction called with empty selections. Caller: {}": "",
    "wordwise": "",
    "done": "",
    "modifiers changed": "",
    "toggle": "",
    "settings change": "",
    "new lines shown": "",
    "buffer edited": "",
    "refresh requested": "",
    "excerpts removed": "",
    "": "",
    "Providing a display map for a new editor is only intended for the minimap and might have unindended side effects otherwise!": "",
    "⋯": "",
    "Editor Opened": "",
    "Editor": "",
    "single_line": "",
    "auto_height": "",
    "minimap": "",
    "full": "",
    "jupyter": "",
    "mode": "",
    "renaming": "",
    "menu": "",
    "showing_completions": "",
    "showing_code_actions": "",
    "extension": "",
    "multibuffer": "",
    "copilot_suggestion": "",
    "selection_mode": "",
    "Failed to create buffer": "",
    "The remote instance of Zed does not support this yet. It must be upgraded to {}": "",
    "required": "",
    "the latest version": "",
    "linux": "",
    "freebsd": "",
    "persisting editor selections for editor {editor_id}, workspace {workspace_id:?}": "",
    "persisting editor folds for editor {editor_id}, workspace {workspace_id:?}": "",
    "extend_selection not called with pending selection": "",
    "update_selection dispatched with no pending selection": "",
    "{}{}": "",
    "comment": "",
    "\\n": "",
    " ": "",
    "\\t": "",
    "bug: SnippetChoices requested_source is not handled": "",
    "inline_code_actions": "",
    "Toggle Code Actions": "",
    "Edit Prediction Accepted": "",
    "Edit Prediction Discarded": "",
    "multiple different run targets found on a single line, only the last target will be rendered": "",
    "Edit Log Breakpoint": "",
    "Set Log Breakpoint": "",
    "Edit Condition Breakpoint": "",
    "Set Condition Breakpoint": "",
    "Edit Hit Condition Breakpoint": "",
    "Set Hit Condition Breakpoint": "",
    "Unset Breakpoint": "",
    "Set Breakpoint": "",
    "Disable": "",
    "Enable": "",
    "Run to cursor": "",
    "Enable breakpoint": "",
    "Set breakpoint": "",
    "Unset breakpoint": "",
    "No executable code is associated with this line.": "",
    "{alt_as_text}-click to disable,\\nright-click for more options.": "",
    "Right-click for more options.": "",
    "breakpoint_indicator": "",
    "run_indicator": "",
    "Accept": "",
    "Jump": "",
    "Scroll": "",
    "Jump to Edit": "",
    "edit_prediction_diff_popover_keybind": "",
    "ep-line-popover": "",
    "accept-terms": "",
    "Edit Prediction Provider ToS Clicked": "",
    "Accept Terms of Service": "",
    "Hold": "",
    "edit_prediction_cursor_popover_keybind": "",
    "...": "",
    "No Prediction": "",
    "loading-completion": "",
    "Preview": "",
    "…": "",
    "expected anchor range to have matching buffer IDs": "",
    "line did not start with prefix {line_prefix:?}: {line:?}": "",
    "\n                );\n            }\n            self.request_autoscroll(Autoscroll::fit(), cx);\n            self.unmark_text(window, cx);\n            self.refresh_inline_completion(true, false, window, cx);\n            cx.emit(EditorEvent::Edited { transaction_id });\n            cx.emit(EditorEvent::TransactionUndone { transaction_id });\n        }\n    }\n\n    pub fn redo(&mut self, _: &Redo, window: &mut Window, cx: &mut Context<Self>) {\n        if self.read_only(cx) {\n            return;\n        }\n\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n\n        if let Some(transaction_id) = self.buffer.update(cx, |buffer, cx| buffer.redo(cx)) {\n            if let Some((_, Some(selections))) =\n                self.selection_history.transaction(transaction_id).cloned()\n            {\n                self.change_selections(None, window, cx, |s| {\n                    s.select_anchors(selections.to_vec());\n                });\n            } else {\n                log::error!(\n                    ": "",
    "\n                );\n            }\n            self.request_autoscroll(Autoscroll::fit(), cx);\n            self.unmark_text(window, cx);\n            self.refresh_inline_completion(true, false, window, cx);\n            cx.emit(EditorEvent::Edited { transaction_id });\n        }\n    }\n\n    pub fn finalize_last_transaction(&mut self, cx: &mut Context<Self>) {\n        self.buffer\n            .update(cx, |buffer, cx| buffer.finalize_last_transaction(cx));\n    }\n\n    pub fn group_until_transaction(&mut self, tx_id: TransactionId, cx: &mut Context<Self>) {\n        self.buffer\n            .update(cx, |buffer, cx| buffer.group_until_transaction(tx_id, cx));\n    }\n\n    pub fn move_left(&mut self, _: &MoveLeft, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                let cursor = if selection.is_empty() {\n                    movement::left(map, selection.start)\n                } else {\n                    selection.start\n                };\n                selection.collapse_to(cursor, SelectionGoal::None);\n            });\n        })\n    }\n\n    pub fn select_left(&mut self, _: &SelectLeft, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| (movement::left(map, head), SelectionGoal::None));\n        })\n    }\n\n    pub fn move_right(&mut self, _: &MoveRight, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                let cursor = if selection.is_empty() {\n                    movement::right(map, selection.end)\n                } else {\n                    selection.end\n                };\n                selection.collapse_to(cursor, SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn select_right(&mut self, _: &SelectRight, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| (movement::right(map, head), SelectionGoal::None));\n        })\n    }\n\n    pub fn move_up(&mut self, _: &MoveUp, window: &mut Window, cx: &mut Context<Self>) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n\n        let text_layout_details = &self.text_layout_details(window);\n        let selection_count = self.selections.count();\n        let first_selection = self.selections.first_anchor();\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                if !selection.is_empty() {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::up(\n                    map,\n                    selection.start,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        });\n\n        if selection_count == 1 && first_selection.range() == self.selections.first_anchor().range()\n        {\n            cx.propagate();\n        }\n    }\n\n    pub fn move_up_by_lines(\n        &mut self,\n        action: &MoveUpByLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                if !selection.is_empty() {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::up_by_rows(\n                    map,\n                    selection.start,\n                    action.lines,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        })\n    }\n\n    pub fn move_down_by_lines(\n        &mut self,\n        action: &MoveDownByLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                if !selection.is_empty() {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::down_by_rows(\n                    map,\n                    selection.start,\n                    action.lines,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        })\n    }\n\n    pub fn select_down_by_lines(\n        &mut self,\n        action: &SelectDownByLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::down_by_rows(map, head, action.lines, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn select_up_by_lines(\n        &mut self,\n        action: &SelectUpByLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::up_by_rows(map, head, action.lines, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn select_page_up(\n        &mut self,\n        _: &SelectPageUp,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(row_count) = self.visible_row_count() else {\n            return;\n        };\n\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::up_by_rows(map, head, row_count, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn move_page_up(\n        &mut self,\n        action: &MovePageUp,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if self\n            .context_menu\n            .borrow_mut()\n            .as_mut()\n            .map(|menu| menu.select_first(self.completion_provider.as_deref(), window, cx))\n            .unwrap_or(false)\n        {\n            return;\n        }\n\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        let Some(row_count) = self.visible_row_count() else {\n            return;\n        };\n\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n\n        let autoscroll = if action.center_cursor {\n            Autoscroll::center()\n        } else {\n            Autoscroll::fit()\n        };\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Some(autoscroll), window, cx, |s| {\n            s.move_with(|map, selection| {\n                if !selection.is_empty() {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::up_by_rows(\n                    map,\n                    selection.end,\n                    row_count,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        });\n    }\n\n    pub fn select_up(&mut self, _: &SelectUp, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::up(map, head, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn move_down(&mut self, _: &MoveDown, window: &mut Window, cx: &mut Context<Self>) {\n        self.take_rename(true, window, cx);\n\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n\n        let text_layout_details = &self.text_layout_details(window);\n        let selection_count = self.selections.count();\n        let first_selection = self.selections.first_anchor();\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                if !selection.is_empty() {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::down(\n                    map,\n                    selection.end,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        });\n\n        if selection_count == 1 && first_selection.range() == self.selections.first_anchor().range()\n        {\n            cx.propagate();\n        }\n    }\n\n    pub fn select_page_down(\n        &mut self,\n        _: &SelectPageDown,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(row_count) = self.visible_row_count() else {\n            return;\n        };\n\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::down_by_rows(map, head, row_count, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn move_page_down(\n        &mut self,\n        action: &MovePageDown,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if self\n            .context_menu\n            .borrow_mut()\n            .as_mut()\n            .map(|menu| menu.select_last(self.completion_provider.as_deref(), window, cx))\n            .unwrap_or(false)\n        {\n            return;\n        }\n\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        let Some(row_count) = self.visible_row_count() else {\n            return;\n        };\n\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n\n        let autoscroll = if action.center_cursor {\n            Autoscroll::center()\n        } else {\n            Autoscroll::fit()\n        };\n\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Some(autoscroll), window, cx, |s| {\n            s.move_with(|map, selection| {\n                if !selection.is_empty() {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::down_by_rows(\n                    map,\n                    selection.end,\n                    row_count,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        });\n    }\n\n    pub fn select_down(&mut self, _: &SelectDown, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::down(map, head, goal, false, text_layout_details)\n            })\n        });\n    }\n\n    pub fn context_menu_first(\n        &mut self,\n        _: &ContextMenuFirst,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(context_menu) = self.context_menu.borrow_mut().as_mut() {\n            context_menu.select_first(self.completion_provider.as_deref(), window, cx);\n        }\n    }\n\n    pub fn context_menu_prev(\n        &mut self,\n        _: &ContextMenuPrevious,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(context_menu) = self.context_menu.borrow_mut().as_mut() {\n            context_menu.select_prev(self.completion_provider.as_deref(), window, cx);\n        }\n    }\n\n    pub fn context_menu_next(\n        &mut self,\n        _: &ContextMenuNext,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(context_menu) = self.context_menu.borrow_mut().as_mut() {\n            context_menu.select_next(self.completion_provider.as_deref(), window, cx);\n        }\n    }\n\n    pub fn context_menu_last(\n        &mut self,\n        _: &ContextMenuLast,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(context_menu) = self.context_menu.borrow_mut().as_mut() {\n            context_menu.select_last(self.completion_provider.as_deref(), window, cx);\n        }\n    }\n\n    pub fn move_to_previous_word_start(\n        &mut self,\n        _: &MoveToPreviousWordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (\n                    movement::previous_word_start(map, head),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_previous_subword_start(\n        &mut self,\n        _: &MoveToPreviousSubwordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (\n                    movement::previous_subword_start(map, head),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_previous_word_start(\n        &mut self,\n        _: &SelectToPreviousWordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::previous_word_start(map, head),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_previous_subword_start(\n        &mut self,\n        _: &SelectToPreviousSubwordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::previous_subword_start(map, head),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn delete_to_previous_word_start(\n        &mut self,\n        action: &DeleteToPreviousWordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n        self.transact(window, cx, |this, window, cx| {\n            this.select_autoclose_pair(window, cx);\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.move_with(|map, selection| {\n                    if selection.is_empty() {\n                        let cursor = if action.ignore_newlines {\n                            movement::previous_word_start(map, selection.head())\n                        } else {\n                            movement::previous_word_start_or_newline(map, selection.head())\n                        };\n                        selection.set_head(cursor, SelectionGoal::None);\n                    }\n                });\n            });\n            this.insert(": "",
    ", window, cx);\n        });\n    }\n\n    pub fn delete_to_previous_subword_start(\n        &mut self,\n        _: &DeleteToPreviousSubwordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n        self.transact(window, cx, |this, window, cx| {\n            this.select_autoclose_pair(window, cx);\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.move_with(|map, selection| {\n                    if selection.is_empty() {\n                        let cursor = movement::previous_subword_start(map, selection.head());\n                        selection.set_head(cursor, SelectionGoal::None);\n                    }\n                });\n            });\n            this.insert(": "",
    ", window, cx);\n        });\n    }\n\n    pub fn move_to_next_word_end(\n        &mut self,\n        _: &MoveToNextWordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (movement::next_word_end(map, head), SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn move_to_next_subword_end(\n        &mut self,\n        _: &MoveToNextSubwordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (movement::next_subword_end(map, head), SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn select_to_next_word_end(\n        &mut self,\n        _: &SelectToNextWordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (movement::next_word_end(map, head), SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn select_to_next_subword_end(\n        &mut self,\n        _: &SelectToNextSubwordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (movement::next_subword_end(map, head), SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn delete_to_next_word_end(\n        &mut self,\n        action: &DeleteToNextWordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n        self.transact(window, cx, |this, window, cx| {\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.move_with(|map, selection| {\n                    if selection.is_empty() {\n                        let cursor = if action.ignore_newlines {\n                            movement::next_word_end(map, selection.head())\n                        } else {\n                            movement::next_word_end_or_newline(map, selection.head())\n                        };\n                        selection.set_head(cursor, SelectionGoal::None);\n                    }\n                });\n            });\n            this.insert(": "",
    ", window, cx);\n        });\n    }\n\n    pub fn delete_to_next_subword_end(\n        &mut self,\n        _: &DeleteToNextSubwordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n        self.transact(window, cx, |this, window, cx| {\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.move_with(|map, selection| {\n                    if selection.is_empty() {\n                        let cursor = movement::next_subword_end(map, selection.head());\n                        selection.set_head(cursor, SelectionGoal::None);\n                    }\n                });\n            });\n            this.insert(": "",
    ", window, cx);\n        });\n    }\n\n    pub fn move_to_beginning_of_line(\n        &mut self,\n        action: &MoveToBeginningOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (\n                    movement::indented_line_beginning(\n                        map,\n                        head,\n                        action.stop_at_soft_wraps,\n                        action.stop_at_indent,\n                    ),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_beginning_of_line(\n        &mut self,\n        action: &SelectToBeginningOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::indented_line_beginning(\n                        map,\n                        head,\n                        action.stop_at_soft_wraps,\n                        action.stop_at_indent,\n                    ),\n                    SelectionGoal::None,\n                )\n            });\n        });\n    }\n\n    pub fn delete_to_beginning_of_line(\n        &mut self,\n        action: &DeleteToBeginningOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n        self.transact(window, cx, |this, window, cx| {\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.move_with(|_, selection| {\n                    selection.reversed = true;\n                });\n            });\n\n            this.select_to_beginning_of_line(\n                &SelectToBeginningOfLine {\n                    stop_at_soft_wraps: false,\n                    stop_at_indent: action.stop_at_indent,\n                },\n                window,\n                cx,\n            );\n            this.backspace(&Backspace, window, cx);\n        });\n    }\n\n    pub fn move_to_end_of_line(\n        &mut self,\n        action: &MoveToEndOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (\n                    movement::line_end(map, head, action.stop_at_soft_wraps),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_end_of_line(\n        &mut self,\n        action: &SelectToEndOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::line_end(map, head, action.stop_at_soft_wraps),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn delete_to_end_of_line(\n        &mut self,\n        _: &DeleteToEndOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n        self.transact(window, cx, |this, window, cx| {\n            this.select_to_end_of_line(\n                &SelectToEndOfLine {\n                    stop_at_soft_wraps: false,\n                },\n                window,\n                cx,\n            );\n            this.delete(&Delete, window, cx);\n        });\n    }\n\n    pub fn cut_to_end_of_line(\n        &mut self,\n        _: &CutToEndOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n        self.transact(window, cx, |this, window, cx| {\n            this.select_to_end_of_line(\n                &SelectToEndOfLine {\n                    stop_at_soft_wraps: false,\n                },\n                window,\n                cx,\n            );\n            this.cut(&Cut, window, cx);\n        });\n    }\n\n    pub fn move_to_start_of_paragraph(\n        &mut self,\n        _: &MoveToStartOfParagraph,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::start_of_paragraph(map, selection.head(), 1),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_end_of_paragraph(\n        &mut self,\n        _: &MoveToEndOfParagraph,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::end_of_paragraph(map, selection.head(), 1),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_start_of_paragraph(\n        &mut self,\n        _: &SelectToStartOfParagraph,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::start_of_paragraph(map, head, 1),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_end_of_paragraph(\n        &mut self,\n        _: &SelectToEndOfParagraph,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::end_of_paragraph(map, head, 1),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_start_of_excerpt(\n        &mut self,\n        _: &MoveToStartOfExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::start_of_excerpt(\n                        map,\n                        selection.head(),\n                        workspace::searchable::Direction::Prev,\n                    ),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_start_of_next_excerpt(\n        &mut self,\n        _: &MoveToStartOfNextExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::start_of_excerpt(\n                        map,\n                        selection.head(),\n                        workspace::searchable::Direction::Next,\n                    ),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_end_of_excerpt(\n        &mut self,\n        _: &MoveToEndOfExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::end_of_excerpt(\n                        map,\n                        selection.head(),\n                        workspace::searchable::Direction::Next,\n                    ),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_end_of_previous_excerpt(\n        &mut self,\n        _: &MoveToEndOfPreviousExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::end_of_excerpt(\n                        map,\n                        selection.head(),\n                        workspace::searchable::Direction::Prev,\n                    ),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_start_of_excerpt(\n        &mut self,\n        _: &SelectToStartOfExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::start_of_excerpt(map, head, workspace::searchable::Direction::Prev),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_start_of_next_excerpt(\n        &mut self,\n        _: &SelectToStartOfNextExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::start_of_excerpt(map, head, workspace::searchable::Direction::Next),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_end_of_excerpt(\n        &mut self,\n        _: &SelectToEndOfExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::end_of_excerpt(map, head, workspace::searchable::Direction::Next),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_end_of_previous_excerpt(\n        &mut self,\n        _: &SelectToEndOfPreviousExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::end_of_excerpt(map, head, workspace::searchable::Direction::Prev),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_beginning(\n        &mut self,\n        _: &MoveToBeginning,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select_ranges(vec![0..0]);\n        });\n    }\n\n    pub fn select_to_beginning(\n        &mut self,\n        _: &SelectToBeginning,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let mut selection = self.selections.last::<Point>(cx);\n        selection.set_head(Point::zero(), SelectionGoal::None);\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select(vec![selection]);\n        });\n    }\n\n    pub fn move_to_end(&mut self, _: &MoveToEnd, window: &mut Window, cx: &mut Context<Self>) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        let cursor = self.buffer.read(cx).read(cx).len();\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select_ranges(vec![cursor..cursor])\n        });\n    }\n\n    pub fn set_nav_history(&mut self, nav_history: Option<ItemNavHistory>) {\n        self.nav_history = nav_history;\n    }\n\n    pub fn nav_history(&self) -> Option<&ItemNavHistory> {\n        self.nav_history.as_ref()\n    }\n\n    pub fn create_nav_history_entry(&mut self, cx: &mut Context<Self>) {\n        self.push_to_nav_history(self.selections.newest_anchor().head(), None, false, cx);\n    }\n\n    fn push_to_nav_history(\n        &mut self,\n        cursor_anchor: Anchor,\n        new_position: Option<Point>,\n        is_deactivate: bool,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(nav_history) = self.nav_history.as_mut() {\n            let buffer = self.buffer.read(cx).read(cx);\n            let cursor_position = cursor_anchor.to_point(&buffer);\n            let scroll_state = self.scroll_manager.anchor();\n            let scroll_top_row = scroll_state.top_row(&buffer);\n            drop(buffer);\n\n            if let Some(new_position) = new_position {\n                let row_delta = (new_position.row as i64 - cursor_position.row as i64).abs();\n                if row_delta < MIN_NAVIGATION_HISTORY_ROW_DELTA {\n                    return;\n                }\n            }\n\n            nav_history.push(\n                Some(NavigationData {\n                    cursor_anchor,\n                    cursor_position,\n                    scroll_anchor: scroll_state,\n                    scroll_top_row,\n                }),\n                cx,\n            );\n            cx.emit(EditorEvent::PushedToNavHistory {\n                anchor: cursor_anchor,\n                is_deactivate,\n            })\n        }\n    }\n\n    pub fn select_to_end(&mut self, _: &SelectToEnd, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let mut selection = self.selections.first::<usize>(cx);\n        selection.set_head(buffer.len(), SelectionGoal::None);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select(vec![selection]);\n        });\n    }\n\n    pub fn select_all(&mut self, _: &SelectAll, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        let end = self.buffer.read(cx).read(cx).len();\n        self.change_selections(None, window, cx, |s| {\n            s.select_ranges(vec![0..end]);\n        });\n    }\n\n    pub fn select_line(&mut self, _: &SelectLine, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let mut selections = self.selections.all::<Point>(cx);\n        let max_point = display_map.buffer_snapshot.max_point();\n        for selection in &mut selections {\n            let rows = selection.spanned_rows(true, &display_map);\n            selection.start = Point::new(rows.start.0, 0);\n            selection.end = cmp::min(max_point, Point::new(rows.end.0, 0));\n            selection.reversed = false;\n        }\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select(selections);\n        });\n    }\n\n    pub fn split_selection_into_lines(\n        &mut self,\n        _: &SplitSelectionIntoLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let selections = self\n            .selections\n            .all::<Point>(cx)\n            .into_iter()\n            .map(|selection| selection.start..selection.end)\n            .collect::<Vec<_>>();\n        self.unfold_ranges(&selections, true, true, cx);\n\n        let mut new_selection_ranges = Vec::new();\n        {\n            let buffer = self.buffer.read(cx).read(cx);\n            for selection in selections {\n                for row in selection.start.row..selection.end.row {\n                    let cursor = Point::new(row, buffer.line_len(MultiBufferRow(row)));\n                    new_selection_ranges.push(cursor..cursor);\n                }\n\n                let is_multiline_selection = selection.start.row != selection.end.row;\n                // Don't insert last one if it's a multi-line selection ending at the start of a line,\n                // so this action feels more ergonomic when paired with other selection operations\n                let should_skip_last = is_multiline_selection && selection.end.column == 0;\n                if !should_skip_last {\n                    new_selection_ranges.push(selection.end..selection.end);\n                }\n            }\n        }\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select_ranges(new_selection_ranges);\n        });\n    }\n\n    pub fn add_selection_above(\n        &mut self,\n        _: &AddSelectionAbove,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.add_selection(true, window, cx);\n    }\n\n    pub fn add_selection_below(\n        &mut self,\n        _: &AddSelectionBelow,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.add_selection(false, window, cx);\n    }\n\n    fn add_selection(&mut self, above: bool, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let all_selections = self.selections.all::<Point>(cx);\n        let text_layout_details = self.text_layout_details(window);\n\n        let (mut columnar_selections, new_selections_to_columnarize) = {\n            if let Some(state) = self.add_selections_state.as_ref() {\n                let columnar_selection_ids: HashSet<_> = state\n                    .groups\n                    .iter()\n                    .flat_map(|group| group.stack.iter())\n                    .copied()\n                    .collect();\n\n                all_selections\n                    .into_iter()\n                    .partition(|s| columnar_selection_ids.contains(&s.id))\n            } else {\n                (Vec::new(), all_selections)\n            }\n        };\n\n        let mut state = self\n            .add_selections_state\n            .take()\n            .unwrap_or_else(|| AddSelectionsState { groups: Vec::new() });\n\n        for selection in new_selections_to_columnarize {\n            let range = selection.display_range(&display_map).sorted();\n            let start_x = display_map.x_for_display_point(range.start, &text_layout_details);\n            let end_x = display_map.x_for_display_point(range.end, &text_layout_details);\n            let positions = start_x.min(end_x)..start_x.max(end_x);\n            let mut stack = Vec::new();\n            for row in range.start.row().0..=range.end.row().0 {\n                if let Some(selection) = self.selections.build_columnar_selection(\n                    &display_map,\n                    DisplayRow(row),\n                    &positions,\n                    selection.reversed,\n                    &text_layout_details,\n                ) {\n                    stack.push(selection.id);\n                    columnar_selections.push(selection);\n                }\n            }\n            if !stack.is_empty() {\n                if above {\n                    stack.reverse();\n                }\n                state.groups.push(AddSelectionsGroup { above, stack });\n            }\n        }\n\n        let mut final_selections = Vec::new();\n        let end_row = if above {\n            DisplayRow(0)\n        } else {\n            display_map.max_point().row()\n        };\n\n        let mut last_added_item_per_group = HashMap::default();\n        for group in state.groups.iter_mut() {\n            if let Some(last_id) = group.stack.last() {\n                last_added_item_per_group.insert(*last_id, group);\n            }\n        }\n\n        for selection in columnar_selections {\n            if let Some(group) = last_added_item_per_group.get_mut(&selection.id) {\n                if above == group.above {\n                    let range = selection.display_range(&display_map).sorted();\n                    debug_assert_eq!(range.start.row(), range.end.row());\n                    let mut row = range.start.row();\n                    let positions =\n                        if let SelectionGoal::HorizontalRange { start, end } = selection.goal {\n                            px(start)..px(end)\n                        } else {\n                            let start_x =\n                                display_map.x_for_display_point(range.start, &text_layout_details);\n                            let end_x =\n                                display_map.x_for_display_point(range.end, &text_layout_details);\n                            start_x.min(end_x)..start_x.max(end_x)\n                        };\n\n                    let mut maybe_new_selection = None;\n                    while row != end_row {\n                        if above {\n                            row.0 -= 1;\n                        } else {\n                            row.0 += 1;\n                        }\n                        if let Some(new_selection) = self.selections.build_columnar_selection(\n                            &display_map,\n                            row,\n                            &positions,\n                            selection.reversed,\n                            &text_layout_details,\n                        ) {\n                            maybe_new_selection = Some(new_selection);\n                            break;\n                        }\n                    }\n\n                    if let Some(new_selection) = maybe_new_selection {\n                        group.stack.push(new_selection.id);\n                        if above {\n                            final_selections.push(new_selection);\n                            final_selections.push(selection);\n                        } else {\n                            final_selections.push(selection);\n                            final_selections.push(new_selection);\n                        }\n                    } else {\n                        final_selections.push(selection);\n                    }\n                } else {\n                    group.stack.pop();\n                }\n            } else {\n                final_selections.push(selection);\n            }\n        }\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select(final_selections);\n        });\n\n        let final_selection_ids: HashSet<_> = self\n            .selections\n            .all::<Point>(cx)\n            .iter()\n            .map(|s| s.id)\n            .collect();\n        state.groups.retain_mut(|group| {\n            // selections might get merged above so we remove invalid items from stacks\n            group.stack.retain(|id| final_selection_ids.contains(id));\n\n            // single selection in stack can be treated as initial state\n            group.stack.len() > 1\n        });\n\n        if !state.groups.is_empty() {\n            self.add_selections_state = Some(state);\n        }\n    }\n\n    fn select_match_ranges(\n        &mut self,\n        range: Range<usize>,\n        reversed: bool,\n        replace_newest: bool,\n        auto_scroll: Option<Autoscroll>,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        self.unfold_ranges(&[range.clone()], false, auto_scroll.is_some(), cx);\n        self.change_selections(auto_scroll, window, cx, |s| {\n            if replace_newest {\n                s.delete(s.newest_anchor().id);\n            }\n            if reversed {\n                s.insert_range(range.end..range.start);\n            } else {\n                s.insert_range(range);\n            }\n        });\n    }\n\n    pub fn select_next_match_internal(\n        &mut self,\n        display_map: &DisplaySnapshot,\n        replace_newest: bool,\n        autoscroll: Option<Autoscroll>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        let buffer = &display_map.buffer_snapshot;\n        let mut selections = self.selections.all::<usize>(cx);\n        if let Some(mut select_next_state) = self.select_next_state.take() {\n            let query = &select_next_state.query;\n            if !select_next_state.done {\n                let first_selection = selections.iter().min_by_key(|s| s.id).unwrap();\n                let last_selection = selections.iter().max_by_key(|s| s.id).unwrap();\n                let mut next_selected_range = None;\n\n                let bytes_after_last_selection =\n                    buffer.bytes_in_range(last_selection.end..buffer.len());\n                let bytes_before_first_selection = buffer.bytes_in_range(0..first_selection.start);\n                let query_matches = query\n                    .stream_find_iter(bytes_after_last_selection)\n                    .map(|result| (last_selection.end, result))\n                    .chain(\n                        query\n                            .stream_find_iter(bytes_before_first_selection)\n                            .map(|result| (0, result)),\n                    );\n\n                for (start_offset, query_match) in query_matches {\n                    let query_match = query_match.unwrap(); // can only fail due to I/O\n                    let offset_range =\n                        start_offset + query_match.start()..start_offset + query_match.end();\n                    let display_range = offset_range.start.to_display_point(display_map)\n                        ..offset_range.end.to_display_point(display_map);\n\n                    if !select_next_state.wordwise\n                        || (!movement::is_inside_word(display_map, display_range.start)\n                            && !movement::is_inside_word(display_map, display_range.end))\n                    {\n                        // TODO: This is n^2, because we might check all the selections\n                        if !selections\n                            .iter()\n                            .any(|selection| selection.range().overlaps(&offset_range))\n                        {\n                            next_selected_range = Some(offset_range);\n                            break;\n                        }\n                    }\n                }\n\n                if let Some(next_selected_range) = next_selected_range {\n                    self.select_match_ranges(\n                        next_selected_range,\n                        last_selection.reversed,\n                        replace_newest,\n                        autoscroll,\n                        window,\n                        cx,\n                    );\n                } else {\n                    select_next_state.done = true;\n                }\n            }\n\n            self.select_next_state = Some(select_next_state);\n        } else {\n            let mut only_carets = true;\n            let mut same_text_selected = true;\n            let mut selected_text = None;\n\n            let mut selections_iter = selections.iter().peekable();\n            while let Some(selection) = selections_iter.next() {\n                if selection.start != selection.end {\n                    only_carets = false;\n                }\n\n                if same_text_selected {\n                    if selected_text.is_none() {\n                        selected_text =\n                            Some(buffer.text_for_range(selection.range()).collect::<String>());\n                    }\n\n                    if let Some(next_selection) = selections_iter.peek() {\n                        if next_selection.range().len() == selection.range().len() {\n                            let next_selected_text = buffer\n                                .text_for_range(next_selection.range())\n                                .collect::<String>();\n                            if Some(next_selected_text) != selected_text {\n                                same_text_selected = false;\n                                selected_text = None;\n                            }\n                        } else {\n                            same_text_selected = false;\n                            selected_text = None;\n                        }\n                    }\n                }\n            }\n\n            if only_carets {\n                for selection in &mut selections {\n                    let word_range = movement::surrounding_word(\n                        display_map,\n                        selection.start.to_display_point(display_map),\n                    );\n                    selection.start = word_range.start.to_offset(display_map, Bias::Left);\n                    selection.end = word_range.end.to_offset(display_map, Bias::Left);\n                    selection.goal = SelectionGoal::None;\n                    selection.reversed = false;\n                    self.select_match_ranges(\n                        selection.start..selection.end,\n                        selection.reversed,\n                        replace_newest,\n                        autoscroll,\n                        window,\n                        cx,\n                    );\n                }\n\n                if selections.len() == 1 {\n                    let selection = selections\n                        .last()\n                        .expect(": "",
    ");\n                    let query = buffer\n                        .text_for_range(selection.start..selection.end)\n                        .collect::<String>();\n                    let is_empty = query.is_empty();\n                    let select_state = SelectNextState {\n                        query: AhoCorasick::new(&[query])?,\n                        wordwise: true,\n                        done: is_empty,\n                    };\n                    self.select_next_state = Some(select_state);\n                } else {\n                    self.select_next_state = None;\n                }\n            } else if let Some(selected_text) = selected_text {\n                self.select_next_state = Some(SelectNextState {\n                    query: AhoCorasick::new(&[selected_text])?,\n                    wordwise: false,\n                    done: false,\n                });\n                self.select_next_match_internal(\n                    display_map,\n                    replace_newest,\n                    autoscroll,\n                    window,\n                    cx,\n                )?;\n            }\n        }\n        Ok(())\n    }\n\n    pub fn select_all_matches(\n        &mut self,\n        _action: &SelectAllMatches,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        self.select_next_match_internal(&display_map, false, None, window, cx)?;\n        let Some(select_next_state) = self.select_next_state.as_mut() else {\n            return Ok(());\n        };\n        if select_next_state.done {\n            return Ok(());\n        }\n\n        let mut new_selections = Vec::new();\n\n        let reversed = self.selections.oldest::<usize>(cx).reversed;\n        let buffer = &display_map.buffer_snapshot;\n        let query_matches = select_next_state\n            .query\n            .stream_find_iter(buffer.bytes_in_range(0..buffer.len()));\n\n        for query_match in query_matches.into_iter() {\n            let query_match = query_match.context(": "",
    ")?; // can only fail due to I/O\n            let offset_range = if reversed {\n                query_match.end()..query_match.start()\n            } else {\n                query_match.start()..query_match.end()\n            };\n            let display_range = offset_range.start.to_display_point(&display_map)\n                ..offset_range.end.to_display_point(&display_map);\n\n            if !select_next_state.wordwise\n                || (!movement::is_inside_word(&display_map, display_range.start)\n                    && !movement::is_inside_word(&display_map, display_range.end))\n            {\n                new_selections.push(offset_range.start..offset_range.end);\n            }\n        }\n\n        select_next_state.done = true;\n        self.unfold_ranges(&new_selections.clone(), false, false, cx);\n        self.change_selections(None, window, cx, |selections| {\n            selections.select_ranges(new_selections)\n        });\n\n        Ok(())\n    }\n\n    pub fn select_next(\n        &mut self,\n        action: &SelectNext,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        self.select_next_match_internal(\n            &display_map,\n            action.replace_newest,\n            Some(Autoscroll::newest()),\n            window,\n            cx,\n        )?;\n        Ok(())\n    }\n\n    pub fn select_previous(\n        &mut self,\n        action: &SelectPrevious,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = &display_map.buffer_snapshot;\n        let mut selections = self.selections.all::<usize>(cx);\n        if let Some(mut select_prev_state) = self.select_prev_state.take() {\n            let query = &select_prev_state.query;\n            if !select_prev_state.done {\n                let first_selection = selections.iter().min_by_key(|s| s.id).unwrap();\n                let last_selection = selections.iter().max_by_key(|s| s.id).unwrap();\n                let mut next_selected_range = None;\n                // When we're iterating matches backwards, the oldest match will actually be the furthest one in the buffer.\n                let bytes_before_last_selection =\n                    buffer.reversed_bytes_in_range(0..last_selection.start);\n                let bytes_after_first_selection =\n                    buffer.reversed_bytes_in_range(first_selection.end..buffer.len());\n                let query_matches = query\n                    .stream_find_iter(bytes_before_last_selection)\n                    .map(|result| (last_selection.start, result))\n                    .chain(\n                        query\n                            .stream_find_iter(bytes_after_first_selection)\n                            .map(|result| (buffer.len(), result)),\n                    );\n                for (end_offset, query_match) in query_matches {\n                    let query_match = query_match.unwrap(); // can only fail due to I/O\n                    let offset_range =\n                        end_offset - query_match.end()..end_offset - query_match.start();\n                    let display_range = offset_range.start.to_display_point(&display_map)\n                        ..offset_range.end.to_display_point(&display_map);\n\n                    if !select_prev_state.wordwise\n                        || (!movement::is_inside_word(&display_map, display_range.start)\n                            && !movement::is_inside_word(&display_map, display_range.end))\n                    {\n                        next_selected_range = Some(offset_range);\n                        break;\n                    }\n                }\n\n                if let Some(next_selected_range) = next_selected_range {\n                    self.select_match_ranges(\n                        next_selected_range,\n                        last_selection.reversed,\n                        action.replace_newest,\n                        Some(Autoscroll::newest()),\n                        window,\n                        cx,\n                    );\n                } else {\n                    select_prev_state.done = true;\n                }\n            }\n\n            self.select_prev_state = Some(select_prev_state);\n        } else {\n            let mut only_carets = true;\n            let mut same_text_selected = true;\n            let mut selected_text = None;\n\n            let mut selections_iter = selections.iter().peekable();\n            while let Some(selection) = selections_iter.next() {\n                if selection.start != selection.end {\n                    only_carets = false;\n                }\n\n                if same_text_selected {\n                    if selected_text.is_none() {\n                        selected_text =\n                            Some(buffer.text_for_range(selection.range()).collect::<String>());\n                    }\n\n                    if let Some(next_selection) = selections_iter.peek() {\n                        if next_selection.range().len() == selection.range().len() {\n                            let next_selected_text = buffer\n                                .text_for_range(next_selection.range())\n                                .collect::<String>();\n                            if Some(next_selected_text) != selected_text {\n                                same_text_selected = false;\n                                selected_text = None;\n                            }\n                        } else {\n                            same_text_selected = false;\n                            selected_text = None;\n                        }\n                    }\n                }\n            }\n\n            if only_carets {\n                for selection in &mut selections {\n                    let word_range = movement::surrounding_word(\n                        &display_map,\n                        selection.start.to_display_point(&display_map),\n                    );\n                    selection.start = word_range.start.to_offset(&display_map, Bias::Left);\n                    selection.end = word_range.end.to_offset(&display_map, Bias::Left);\n                    selection.goal = SelectionGoal::None;\n                    selection.reversed = false;\n                    self.select_match_ranges(\n                        selection.start..selection.end,\n                        selection.reversed,\n                        action.replace_newest,\n                        Some(Autoscroll::newest()),\n                        window,\n                        cx,\n                    );\n                }\n                if selections.len() == 1 {\n                    let selection = selections\n                        .last()\n                        .expect(": "",
    ");\n                    let query = buffer\n                        .text_for_range(selection.start..selection.end)\n                        .collect::<String>();\n                    let is_empty = query.is_empty();\n                    let select_state = SelectNextState {\n                        query: AhoCorasick::new(&[query.chars().rev().collect::<String>()])?,\n                        wordwise: true,\n                        done: is_empty,\n                    };\n                    self.select_prev_state = Some(select_state);\n                } else {\n                    self.select_prev_state = None;\n                }\n            } else if let Some(selected_text) = selected_text {\n                self.select_prev_state = Some(SelectNextState {\n                    query: AhoCorasick::new(&[selected_text.chars().rev().collect::<String>()])?,\n                    wordwise: false,\n                    done: false,\n                });\n                self.select_previous(action, window, cx)?;\n            }\n        }\n        Ok(())\n    }\n\n    pub fn find_next_match(\n        &mut self,\n        _: &FindNextMatch,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        let selections = self.selections.disjoint_anchors();\n        match selections.first() {\n            Some(first) if selections.len() >= 2 => {\n                self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                    s.select_ranges([first.range()]);\n                });\n            }\n            _ => self.select_next(\n                &SelectNext {\n                    replace_newest: true,\n                },\n                window,\n                cx,\n            )?,\n        }\n        Ok(())\n    }\n\n    pub fn find_previous_match(\n        &mut self,\n        _: &FindPreviousMatch,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        let selections = self.selections.disjoint_anchors();\n        match selections.last() {\n            Some(last) if selections.len() >= 2 => {\n                self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                    s.select_ranges([last.range()]);\n                });\n            }\n            _ => self.select_previous(\n                &SelectPrevious {\n                    replace_newest: true,\n                },\n                window,\n                cx,\n            )?,\n        }\n        Ok(())\n    }\n\n    pub fn toggle_comments(\n        &mut self,\n        action: &ToggleComments,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.read_only(cx) {\n            return;\n        }\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n        let text_layout_details = &self.text_layout_details(window);\n        self.transact(window, cx, |this, window, cx| {\n            let mut selections = this.selections.all::<MultiBufferPoint>(cx);\n            let mut edits = Vec::new();\n            let mut selection_edit_ranges = Vec::new();\n            let mut last_toggled_row = None;\n            let snapshot = this.buffer.read(cx).read(cx);\n            let empty_str: Arc<str> = Arc::default();\n            let mut suffixes_inserted = Vec::new();\n            let ignore_indent = action.ignore_indent;\n\n            fn comment_prefix_range(\n                snapshot: &MultiBufferSnapshot,\n                row: MultiBufferRow,\n                comment_prefix: &str,\n                comment_prefix_whitespace: &str,\n                ignore_indent: bool,\n            ) -> Range<Point> {\n                let indent_size = if ignore_indent {\n                    0\n                } else {\n                    snapshot.indent_size_for_line(row).len\n                };\n\n                let start = Point::new(row.0, indent_size);\n\n                let mut line_bytes = snapshot\n                    .bytes_in_range(start..snapshot.max_point())\n                    .flatten()\n                    .copied();\n\n                // If this line currently begins with the line comment prefix, then record\n                // the range containing the prefix.\n                if line_bytes\n                    .by_ref()\n                    .take(comment_prefix.len())\n                    .eq(comment_prefix.bytes())\n                {\n                    // Include any whitespace that matches the comment prefix.\n                    let matching_whitespace_len = line_bytes\n                        .zip(comment_prefix_whitespace.bytes())\n                        .take_while(|(a, b)| a == b)\n                        .count() as u32;\n                    let end = Point::new(\n                        start.row,\n                        start.column + comment_prefix.len() as u32 + matching_whitespace_len,\n                    );\n                    start..end\n                } else {\n                    start..start\n                }\n            }\n\n            fn comment_suffix_range(\n                snapshot: &MultiBufferSnapshot,\n                row: MultiBufferRow,\n                comment_suffix: &str,\n                comment_suffix_has_leading_space: bool,\n            ) -> Range<Point> {\n                let end = Point::new(row.0, snapshot.line_len(row));\n                let suffix_start_column = end.column.saturating_sub(comment_suffix.len() as u32);\n\n                let mut line_end_bytes = snapshot\n                    .bytes_in_range(Point::new(end.row, suffix_start_column.saturating_sub(1))..end)\n                    .flatten()\n                    .copied();\n\n                let leading_space_len = if suffix_start_column > 0\n                    && line_end_bytes.next() == Some(b' ')\n                    && comment_suffix_has_leading_space\n                {\n                    1\n                } else {\n                    0\n                };\n\n                // If this line currently begins with the line comment prefix, then record\n                // the range containing the prefix.\n                if line_end_bytes.by_ref().eq(comment_suffix.bytes()) {\n                    let start = Point::new(end.row, suffix_start_column - leading_space_len);\n                    start..end\n                } else {\n                    end..end\n                }\n            }\n\n            // TODO: Handle selections that cross excerpts\n            for selection in &mut selections {\n                let start_column = snapshot\n                    .indent_size_for_line(MultiBufferRow(selection.start.row))\n                    .len;\n                let language = if let Some(language) =\n                    snapshot.language_scope_at(Point::new(selection.start.row, start_column))\n                {\n                    language\n                } else {\n                    continue;\n                };\n\n                selection_edit_ranges.clear();\n\n                // If multiple selections contain a given row, avoid processing that\n                // row more than once.\n                let mut start_row = MultiBufferRow(selection.start.row);\n                if last_toggled_row == Some(start_row) {\n                    start_row = start_row.next_row();\n                }\n                let end_row =\n                    if selection.end.row > selection.start.row && selection.end.column == 0 {\n                        MultiBufferRow(selection.end.row - 1)\n                    } else {\n                        MultiBufferRow(selection.end.row)\n                    };\n                last_toggled_row = Some(end_row);\n\n                if start_row > end_row {\n                    continue;\n                }\n\n                // If the language has line comments, toggle those.\n                let mut full_comment_prefixes = language.line_comment_prefixes().to_vec();\n\n                // If ignore_indent is set, trim spaces from the right side of all full_comment_prefixes\n                if ignore_indent {\n                    full_comment_prefixes = full_comment_prefixes\n                        .into_iter()\n                        .map(|s| Arc::from(s.trim_end()))\n                        .collect();\n                }\n\n                if !full_comment_prefixes.is_empty() {\n                    let first_prefix = full_comment_prefixes\n                        .first()\n                        .expect(": "",
    ");\n                    let prefix_trimmed_lengths = full_comment_prefixes\n                        .iter()\n                        .map(|p| p.trim_end_matches(' ').len())\n                        .collect::<SmallVec<[usize; 4]>>();\n\n                    let mut all_selection_lines_are_comments = true;\n\n                    for row in start_row.0..=end_row.0 {\n                        let row = MultiBufferRow(row);\n                        if start_row < end_row && snapshot.is_line_blank(row) {\n                            continue;\n                        }\n\n                        let prefix_range = full_comment_prefixes\n                            .iter()\n                            .zip(prefix_trimmed_lengths.iter().copied())\n                            .map(|(prefix, trimmed_prefix_len)| {\n                                comment_prefix_range(\n                                    snapshot.deref(),\n                                    row,\n                                    &prefix[..trimmed_prefix_len],\n                                    &prefix[trimmed_prefix_len..],\n                                    ignore_indent,\n                                )\n                            })\n                            .max_by_key(|range| range.end.column - range.start.column)\n                            .expect(": "",
    ");\n\n                        if prefix_range.is_empty() {\n                            all_selection_lines_are_comments = false;\n                        }\n\n                        selection_edit_ranges.push(prefix_range);\n                    }\n\n                    if all_selection_lines_are_comments {\n                        edits.extend(\n                            selection_edit_ranges\n                                .iter()\n                                .cloned()\n                                .map(|range| (range, empty_str.clone())),\n                        );\n                    } else {\n                        let min_column = selection_edit_ranges\n                            .iter()\n                            .map(|range| range.start.column)\n                            .min()\n                            .unwrap_or(0);\n                        edits.extend(selection_edit_ranges.iter().map(|range| {\n                            let position = Point::new(range.start.row, min_column);\n                            (position..position, first_prefix.clone())\n                        }));\n                    }\n                } else if let Some((full_comment_prefix, comment_suffix)) =\n                    language.block_comment_delimiters()\n                {\n                    let comment_prefix = full_comment_prefix.trim_end_matches(' ');\n                    let comment_prefix_whitespace = &full_comment_prefix[comment_prefix.len()..];\n                    let prefix_range = comment_prefix_range(\n                        snapshot.deref(),\n                        start_row,\n                        comment_prefix,\n                        comment_prefix_whitespace,\n                        ignore_indent,\n                    );\n                    let suffix_range = comment_suffix_range(\n                        snapshot.deref(),\n                        end_row,\n                        comment_suffix.trim_start_matches(' '),\n                        comment_suffix.starts_with(' '),\n                    );\n\n                    if prefix_range.is_empty() || suffix_range.is_empty() {\n                        edits.push((\n                            prefix_range.start..prefix_range.start,\n                            full_comment_prefix.clone(),\n                        ));\n                        edits.push((suffix_range.end..suffix_range.end, comment_suffix.clone()));\n                        suffixes_inserted.push((end_row, comment_suffix.len()));\n                    } else {\n                        edits.push((prefix_range, empty_str.clone()));\n                        edits.push((suffix_range, empty_str.clone()));\n                    }\n                } else {\n                    continue;\n                }\n            }\n\n            drop(snapshot);\n            this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(edits, None, cx);\n            });\n\n            // Adjust selections so that they end before any comment suffixes that\n            // were inserted.\n            let mut suffixes_inserted = suffixes_inserted.into_iter().peekable();\n            let mut selections = this.selections.all::<Point>(cx);\n            let snapshot = this.buffer.read(cx).read(cx);\n            for selection in &mut selections {\n                while let Some((row, suffix_len)) = suffixes_inserted.peek().copied() {\n                    match row.cmp(&MultiBufferRow(selection.end.row)) {\n                        Ordering::Less => {\n                            suffixes_inserted.next();\n                            continue;\n                        }\n                        Ordering::Greater => break,\n                        Ordering::Equal => {\n                            if selection.end.column == snapshot.line_len(row) {\n                                if selection.is_empty() {\n                                    selection.start.column -= suffix_len as u32;\n                                }\n                                selection.end.column -= suffix_len as u32;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n\n            drop(snapshot);\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(selections)\n            });\n\n            let selections = this.selections.all::<Point>(cx);\n            let selections_on_single_row = selections.windows(2).all(|selections| {\n                selections[0].start.row == selections[1].start.row\n                    && selections[0].end.row == selections[1].end.row\n                    && selections[0].start.row == selections[0].end.row\n            });\n            let selections_selecting = selections\n                .iter()\n                .any(|selection| selection.start != selection.end);\n            let advance_downwards = action.advance_downwards\n                && selections_on_single_row\n                && !selections_selecting\n                && !matches!(this.mode, EditorMode::SingleLine { .. });\n\n            if advance_downwards {\n                let snapshot = this.buffer.read(cx).snapshot(cx);\n\n                this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                    s.move_cursors_with(|display_snapshot, display_point, _| {\n                        let mut point = display_point.to_point(display_snapshot);\n                        point.row += 1;\n                        point = snapshot.clip_point(point, Bias::Left);\n                        let display_point = point.to_display_point(display_snapshot);\n                        let goal = SelectionGoal::HorizontalPosition(\n                            display_snapshot\n                                .x_for_display_point(display_point, text_layout_details)\n                                .into(),\n                        );\n                        (display_point, goal)\n                    })\n                });\n            }\n        });\n    }\n\n    pub fn select_enclosing_symbol(\n        &mut self,\n        _: &SelectEnclosingSymbol,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let old_selections = self.selections.all::<usize>(cx).into_boxed_slice();\n\n        fn update_selection(\n            selection: &Selection<usize>,\n            buffer_snap: &MultiBufferSnapshot,\n        ) -> Option<Selection<usize>> {\n            let cursor = selection.head();\n            let (_buffer_id, symbols) = buffer_snap.symbols_containing(cursor, None)?;\n            for symbol in symbols.iter().rev() {\n                let start = symbol.range.start.to_offset(buffer_snap);\n                let end = symbol.range.end.to_offset(buffer_snap);\n                let new_range = start..end;\n                if start < selection.start || end > selection.end {\n                    return Some(Selection {\n                        id: selection.id,\n                        start: new_range.start,\n                        end: new_range.end,\n                        goal: SelectionGoal::None,\n                        reversed: selection.reversed,\n                    });\n                }\n            }\n            None\n        }\n\n        let mut selected_larger_symbol = false;\n        let new_selections = old_selections\n            .iter()\n            .map(|selection| match update_selection(selection, &buffer) {\n                Some(new_selection) => {\n                    if new_selection.range() != selection.range() {\n                        selected_larger_symbol = true;\n                    }\n                    new_selection\n                }\n                None => selection.clone(),\n            })\n            .collect::<Vec<_>>();\n\n        if selected_larger_symbol {\n            self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(new_selections);\n            });\n        }\n    }\n\n    pub fn select_larger_syntax_node(\n        &mut self,\n        _: &SelectLargerSyntaxNode,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(visible_row_count) = self.visible_row_count() else {\n            return;\n        };\n        let old_selections: Box<[_]> = self.selections.all::<usize>(cx).into();\n        if old_selections.is_empty() {\n            return;\n        }\n\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = self.buffer.read(cx).snapshot(cx);\n\n        let mut selected_larger_node = false;\n        let mut new_selections = old_selections\n            .iter()\n            .map(|selection| {\n                let old_range = selection.start..selection.end;\n\n                if let Some((node, _)) = buffer.syntax_ancestor(old_range.clone()) {\n                    // manually select word at selection\n                    if [": "",
    ", ": "",
    "].contains(&node.kind()) {\n                        let word_range = {\n                            let display_point = buffer\n                                .offset_to_point(old_range.start)\n                                .to_display_point(&display_map);\n                            let Range { start, end } =\n                                movement::surrounding_word(&display_map, display_point);\n                            start.to_point(&display_map).to_offset(&buffer)\n                                ..end.to_point(&display_map).to_offset(&buffer)\n                        };\n                        // ignore if word is already selected\n                        if !word_range.is_empty() && old_range != word_range {\n                            let last_word_range = {\n                                let display_point = buffer\n                                    .offset_to_point(old_range.end)\n                                    .to_display_point(&display_map);\n                                let Range { start, end } =\n                                    movement::surrounding_word(&display_map, display_point);\n                                start.to_point(&display_map).to_offset(&buffer)\n                                    ..end.to_point(&display_map).to_offset(&buffer)\n                            };\n                            // only select word if start and end point belongs to same word\n                            if word_range == last_word_range {\n                                selected_larger_node = true;\n                                return Selection {\n                                    id: selection.id,\n                                    start: word_range.start,\n                                    end: word_range.end,\n                                    goal: SelectionGoal::None,\n                                    reversed: selection.reversed,\n                                };\n                            }\n                        }\n                    }\n                }\n\n                let mut new_range = old_range.clone();\n                while let Some((_node, containing_range)) =\n                    buffer.syntax_ancestor(new_range.clone())\n                {\n                    new_range = match containing_range {\n                        MultiOrSingleBufferOffsetRange::Single(_) => break,\n                        MultiOrSingleBufferOffsetRange::Multi(range) => range,\n                    };\n                    if !display_map.intersects_fold(new_range.start)\n                        && !display_map.intersects_fold(new_range.end)\n                    {\n                        break;\n                    }\n                }\n\n                selected_larger_node |= new_range != old_range;\n                Selection {\n                    id: selection.id,\n                    start: new_range.start,\n                    end: new_range.end,\n                    goal: SelectionGoal::None,\n                    reversed: selection.reversed,\n                }\n            })\n            .collect::<Vec<_>>();\n\n        if !selected_larger_node {\n            return; // don't put this call in the history\n        }\n\n        // scroll based on transformation done to the last selection created by the user\n        let (last_old, last_new) = old_selections\n            .last()\n            .zip(new_selections.last().cloned())\n            .expect(": "",
    ");\n\n        // revert selection\n        let is_selection_reversed = {\n            let should_newest_selection_be_reversed = last_old.start != last_new.start;\n            new_selections.last_mut().expect(": "",
    ").reversed =\n                should_newest_selection_be_reversed;\n            should_newest_selection_be_reversed\n        };\n\n        if selected_larger_node {\n            self.select_syntax_node_history.disable_clearing = true;\n            self.change_selections(None, window, cx, |s| {\n                s.select(new_selections.clone());\n            });\n            self.select_syntax_node_history.disable_clearing = false;\n        }\n\n        let start_row = last_new.start.to_display_point(&display_map).row().0;\n        let end_row = last_new.end.to_display_point(&display_map).row().0;\n        let selection_height = end_row - start_row + 1;\n        let scroll_margin_rows = self.vertical_scroll_margin() as u32;\n\n        let fits_on_the_screen = visible_row_count >= selection_height + scroll_margin_rows * 2;\n        let scroll_behavior = if fits_on_the_screen {\n            self.request_autoscroll(Autoscroll::fit(), cx);\n            SelectSyntaxNodeScrollBehavior::FitSelection\n        } else if is_selection_reversed {\n            self.scroll_cursor_top(&ScrollCursorTop, window, cx);\n            SelectSyntaxNodeScrollBehavior::CursorTop\n        } else {\n            self.scroll_cursor_bottom(&ScrollCursorBottom, window, cx);\n            SelectSyntaxNodeScrollBehavior::CursorBottom\n        };\n\n        self.select_syntax_node_history.push((\n            old_selections,\n            scroll_behavior,\n            is_selection_reversed,\n        ));\n    }\n\n    pub fn select_smaller_syntax_node(\n        &mut self,\n        _: &SelectSmallerSyntaxNode,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n\n        if let Some((mut selections, scroll_behavior, is_selection_reversed)) =\n            self.select_syntax_node_history.pop()\n        {\n            if let Some(selection) = selections.last_mut() {\n                selection.reversed = is_selection_reversed;\n            }\n\n            self.select_syntax_node_history.disable_clearing = true;\n            self.change_selections(None, window, cx, |s| {\n                s.select(selections.to_vec());\n            });\n            self.select_syntax_node_history.disable_clearing = false;\n\n            match scroll_behavior {\n                SelectSyntaxNodeScrollBehavior::CursorTop => {\n                    self.scroll_cursor_top(&ScrollCursorTop, window, cx);\n                }\n                SelectSyntaxNodeScrollBehavior::FitSelection => {\n                    self.request_autoscroll(Autoscroll::fit(), cx);\n                }\n                SelectSyntaxNodeScrollBehavior::CursorBottom => {\n                    self.scroll_cursor_bottom(&ScrollCursorBottom, window, cx);\n                }\n            }\n        }\n    }\n\n    fn refresh_runnables(&mut self, window: &mut Window, cx: &mut Context<Self>) -> Task<()> {\n        if !EditorSettings::get_global(cx).gutter.runnables {\n            self.clear_tasks();\n            return Task::ready(());\n        }\n        let project = self.project.as_ref().map(Entity::downgrade);\n        let task_sources = self.lsp_task_sources(cx);\n        let multi_buffer = self.buffer.downgrade();\n        cx.spawn_in(window, async move |editor, cx| {\n            cx.background_executor().timer(UPDATE_DEBOUNCE).await;\n            let Some(project) = project.and_then(|p| p.upgrade()) else {\n                return;\n            };\n            let Ok(display_snapshot) = editor.update(cx, |this, cx| {\n                this.display_map.update(cx, |map, cx| map.snapshot(cx))\n            }) else {\n                return;\n            };\n\n            let hide_runnables = project\n                .update(cx, |project, cx| {\n                    // Do not display any test indicators in non-dev server remote projects.\n                    project.is_via_collab() && project.ssh_connection_string(cx).is_none()\n                })\n                .unwrap_or(true);\n            if hide_runnables {\n                return;\n            }\n            let new_rows =\n                cx.background_spawn({\n                    let snapshot = display_snapshot.clone();\n                    async move {\n                        Self::fetch_runnable_ranges(&snapshot, Anchor::min()..Anchor::max())\n                    }\n                })\n                    .await;\n            let Ok(lsp_tasks) =\n                cx.update(|_, cx| crate::lsp_tasks(project.clone(), &task_sources, None, cx))\n            else {\n                return;\n            };\n            let lsp_tasks = lsp_tasks.await;\n\n            let Ok(mut lsp_tasks_by_rows) = cx.update(|_, cx| {\n                lsp_tasks\n                    .into_iter()\n                    .flat_map(|(kind, tasks)| {\n                        tasks.into_iter().filter_map(move |(location, task)| {\n                            Some((kind.clone(), location?, task))\n                        })\n                    })\n                    .fold(HashMap::default(), |mut acc, (kind, location, task)| {\n                        let buffer = location.target.buffer;\n                        let buffer_snapshot = buffer.read(cx).snapshot();\n                        let offset = display_snapshot.buffer_snapshot.excerpts().find_map(\n                            |(excerpt_id, snapshot, _)| {\n                                if snapshot.remote_id() == buffer_snapshot.remote_id() {\n                                    display_snapshot\n                                        .buffer_snapshot\n                                        .anchor_in_excerpt(excerpt_id, location.target.range.start)\n                                } else {\n                                    None\n                                }\n                            },\n                        );\n                        if let Some(offset) = offset {\n                            let task_buffer_range =\n                                location.target.range.to_point(&buffer_snapshot);\n                            let context_buffer_range =\n                                task_buffer_range.to_offset(&buffer_snapshot);\n                            let context_range = BufferOffset(context_buffer_range.start)\n                                ..BufferOffset(context_buffer_range.end);\n\n                            acc.entry((buffer_snapshot.remote_id(), task_buffer_range.start.row))\n                                .or_insert_with(|| RunnableTasks {\n                                    templates: Vec::new(),\n                                    offset,\n                                    column: task_buffer_range.start.column,\n                                    extra_variables: HashMap::default(),\n                                    context_range,\n                                })\n                                .templates\n                                .push((kind, task.original_task().clone()));\n                        }\n\n                        acc\n                    })\n            }) else {\n                return;\n            };\n\n            let Ok(prefer_lsp) = multi_buffer.update(cx, |buffer, cx| {\n                buffer.language_settings(cx).tasks.prefer_lsp\n            }) else {\n                return;\n            };\n\n            let rows = Self::runnable_rows(\n                project,\n                display_snapshot,\n                prefer_lsp && !lsp_tasks_by_rows.is_empty(),\n                new_rows,\n                cx.clone(),\n            )\n            .await;\n            editor\n                .update(cx, |editor, _| {\n                    editor.clear_tasks();\n                    for (key, mut value) in rows {\n                        if let Some(lsp_tasks) = lsp_tasks_by_rows.remove(&key) {\n                            value.templates.extend(lsp_tasks.templates);\n                        }\n\n                        editor.insert_tasks(key, value);\n                    }\n                    for (key, value) in lsp_tasks_by_rows {\n                        editor.insert_tasks(key, value);\n                    }\n                })\n                .ok();\n        })\n    }\n    fn fetch_runnable_ranges(\n        snapshot: &DisplaySnapshot,\n        range: Range<Anchor>,\n    ) -> Vec<language::RunnableRange> {\n        snapshot.buffer_snapshot.runnable_ranges(range).collect()\n    }\n\n    fn runnable_rows(\n        project: Entity<Project>,\n        snapshot: DisplaySnapshot,\n        prefer_lsp: bool,\n        runnable_ranges: Vec<RunnableRange>,\n        cx: AsyncWindowContext,\n    ) -> Task<Vec<((BufferId, BufferRow), RunnableTasks)>> {\n        cx.spawn(async move |cx| {\n            let mut runnable_rows = Vec::with_capacity(runnable_ranges.len());\n            for mut runnable in runnable_ranges {\n                let Some(tasks) = cx\n                    .update(|_, cx| Self::templates_with_tags(&project, &mut runnable.runnable, cx))\n                    .ok()\n                else {\n                    continue;\n                };\n                let mut tasks = tasks.await;\n\n                if prefer_lsp {\n                    tasks.retain(|(task_kind, _)| {\n                        !matches!(task_kind, TaskSourceKind::Language { .. })\n                    });\n                }\n                if tasks.is_empty() {\n                    continue;\n                }\n\n                let point = runnable.run_range.start.to_point(&snapshot.buffer_snapshot);\n                let Some(row) = snapshot\n                    .buffer_snapshot\n                    .buffer_line_for_row(MultiBufferRow(point.row))\n                    .map(|(_, range)| range.start.row)\n                else {\n                    continue;\n                };\n\n                let context_range =\n                    BufferOffset(runnable.full_range.start)..BufferOffset(runnable.full_range.end);\n                runnable_rows.push((\n                    (runnable.buffer_id, row),\n                    RunnableTasks {\n                        templates: tasks,\n                        offset: snapshot\n                            .buffer_snapshot\n                            .anchor_before(runnable.run_range.start),\n                        context_range,\n                        column: point.column,\n                        extra_variables: runnable.extra_captures,\n                    },\n                ));\n            }\n            runnable_rows\n        })\n    }\n\n    fn templates_with_tags(\n        project: &Entity<Project>,\n        runnable: &mut Runnable,\n        cx: &mut App,\n    ) -> Task<Vec<(TaskSourceKind, TaskTemplate)>> {\n        let (inventory, worktree_id, file) = project.read_with(cx, |project, cx| {\n            let (worktree_id, file) = project\n                .buffer_for_id(runnable.buffer, cx)\n                .and_then(|buffer| buffer.read(cx).file())\n                .map(|file| (file.worktree_id(cx), file.clone()))\n                .unzip();\n\n            (\n                project.task_store().read(cx).task_inventory().cloned(),\n                worktree_id,\n                file,\n            )\n        });\n\n        let tags = mem::take(&mut runnable.tags);\n        let language = runnable.language.clone();\n        cx.spawn(async move |cx| {\n            let mut templates_with_tags = Vec::new();\n            if let Some(inventory) = inventory {\n                for RunnableTag(tag) in tags {\n                    let Ok(new_tasks) = inventory.update(cx, |inventory, cx| {\n                        inventory.list_tasks(file.clone(), Some(language.clone()), worktree_id, cx)\n                    }) else {\n                        return templates_with_tags;\n                    };\n                    templates_with_tags.extend(new_tasks.await.into_iter().filter(\n                        move |(_, template)| {\n                            template.tags.iter().any(|source_tag| source_tag == &tag)\n                        },\n                    ));\n                }\n            }\n            templates_with_tags.sort_by_key(|(kind, _)| kind.to_owned());\n\n            if let Some((leading_tag_source, _)) = templates_with_tags.first() {\n                // Strongest source wins; if we have worktree tag binding, prefer that to\n                // global and language bindings;\n                // if we have a global binding, prefer that to language binding.\n                let first_mismatch = templates_with_tags\n                    .iter()\n                    .position(|(tag_source, _)| tag_source != leading_tag_source);\n                if let Some(index) = first_mismatch {\n                    templates_with_tags.truncate(index);\n                }\n            }\n\n            templates_with_tags\n        })\n    }\n\n    pub fn move_to_enclosing_bracket(\n        &mut self,\n        _: &MoveToEnclosingBracket,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_offsets_with(|snapshot, selection| {\n                let Some(enclosing_bracket_ranges) =\n                    snapshot.enclosing_bracket_ranges(selection.start..selection.end)\n                else {\n                    return;\n                };\n\n                let mut best_length = usize::MAX;\n                let mut best_inside = false;\n                let mut best_in_bracket_range = false;\n                let mut best_destination = None;\n                for (open, close) in enclosing_bracket_ranges {\n                    let close = close.to_inclusive();\n                    let length = close.end() - open.start;\n                    let inside = selection.start >= open.end && selection.end <= *close.start();\n                    let in_bracket_range = open.to_inclusive().contains(&selection.head())\n                        || close.contains(&selection.head());\n\n                    // If best is next to a bracket and current isn't, skip\n                    if !in_bracket_range && best_in_bracket_range {\n                        continue;\n                    }\n\n                    // Prefer smaller lengths unless best is inside and current isn't\n                    if length > best_length && (best_inside || !inside) {\n                        continue;\n                    }\n\n                    best_length = length;\n                    best_inside = inside;\n                    best_in_bracket_range = in_bracket_range;\n                    best_destination = Some(\n                        if close.contains(&selection.start) && close.contains(&selection.end) {\n                            if inside { open.end } else { open.start }\n                        } else if inside {\n                            *close.start()\n                        } else {\n                            *close.end()\n                        },\n                    );\n                }\n\n                if let Some(destination) = best_destination {\n                    selection.collapse_to(destination, SelectionGoal::None);\n                }\n            })\n        });\n    }\n\n    pub fn undo_selection(\n        &mut self,\n        _: &UndoSelection,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        if let Some(entry) = self.selection_history.undo_stack.pop_back() {\n            self.selection_history.mode = SelectionHistoryMode::Undoing;\n            self.with_selection_effects_deferred(window, cx, |this, window, cx| {\n                this.end_selection(window, cx);\n                this.change_selections(Some(Autoscroll::newest()), window, cx, |s| {\n                    s.select_anchors(entry.selections.to_vec())\n                });\n            });\n            self.selection_history.mode = SelectionHistoryMode::Normal;\n\n            self.select_next_state = entry.select_next_state;\n            self.select_prev_state = entry.select_prev_state;\n            self.add_selections_state = entry.add_selections_state;\n        }\n    }\n\n    pub fn redo_selection(\n        &mut self,\n        _: &RedoSelection,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        if let Some(entry) = self.selection_history.redo_stack.pop_back() {\n            self.selection_history.mode = SelectionHistoryMode::Redoing;\n            self.with_selection_effects_deferred(window, cx, |this, window, cx| {\n                this.end_selection(window, cx);\n                this.change_selections(Some(Autoscroll::newest()), window, cx, |s| {\n                    s.select_anchors(entry.selections.to_vec())\n                });\n            });\n            self.selection_history.mode = SelectionHistoryMode::Normal;\n\n            self.select_next_state = entry.select_next_state;\n            self.select_prev_state = entry.select_prev_state;\n            self.add_selections_state = entry.add_selections_state;\n        }\n    }\n\n    pub fn expand_excerpts(\n        &mut self,\n        action: &ExpandExcerpts,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.expand_excerpts_for_direction(action.lines, ExpandExcerptDirection::UpAndDown, cx)\n    }\n\n    pub fn expand_excerpts_down(\n        &mut self,\n        action: &ExpandExcerptsDown,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.expand_excerpts_for_direction(action.lines, ExpandExcerptDirection::Down, cx)\n    }\n\n    pub fn expand_excerpts_up(\n        &mut self,\n        action: &ExpandExcerptsUp,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.expand_excerpts_for_direction(action.lines, ExpandExcerptDirection::Up, cx)\n    }\n\n    pub fn expand_excerpts_for_direction(\n        &mut self,\n        lines: u32,\n        direction: ExpandExcerptDirection,\n\n        cx: &mut Context<Self>,\n    ) {\n        let selections = self.selections.disjoint_anchors();\n\n        let lines = if lines == 0 {\n            EditorSettings::get_global(cx).expand_excerpt_lines\n        } else {\n            lines\n        };\n\n        self.buffer.update(cx, |buffer, cx| {\n            let snapshot = buffer.snapshot(cx);\n            let mut excerpt_ids = selections\n                .iter()\n                .flat_map(|selection| snapshot.excerpt_ids_for_range(selection.range()))\n                .collect::<Vec<_>>();\n            excerpt_ids.sort();\n            excerpt_ids.dedup();\n            buffer.expand_excerpts(excerpt_ids, lines, direction, cx)\n        })\n    }\n\n    pub fn expand_excerpt(\n        &mut self,\n        excerpt: ExcerptId,\n        direction: ExpandExcerptDirection,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let current_scroll_position = self.scroll_position(cx);\n        let lines_to_expand = EditorSettings::get_global(cx).expand_excerpt_lines;\n        let mut should_scroll_up = false;\n\n        if direction == ExpandExcerptDirection::Down {\n            let multi_buffer = self.buffer.read(cx);\n            let snapshot = multi_buffer.snapshot(cx);\n            if let Some(buffer_id) = snapshot.buffer_id_for_excerpt(excerpt) {\n                if let Some(buffer) = multi_buffer.buffer(buffer_id) {\n                    if let Some(excerpt_range) = snapshot.buffer_range_for_excerpt(excerpt) {\n                        let buffer_snapshot = buffer.read(cx).snapshot();\n                        let excerpt_end_row =\n                            Point::from_anchor(&excerpt_range.end, &buffer_snapshot).row;\n                        let last_row = buffer_snapshot.max_point().row;\n                        let lines_below = last_row.saturating_sub(excerpt_end_row);\n                        should_scroll_up = lines_below >= lines_to_expand;\n                    }\n                }\n            }\n        }\n\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.expand_excerpts([excerpt], lines_to_expand, direction, cx)\n        });\n\n        if should_scroll_up {\n            let new_scroll_position =\n                current_scroll_position + gpui::Point::new(0.0, lines_to_expand as f32);\n            self.set_scroll_position(new_scroll_position, window, cx);\n        }\n    }\n\n    pub fn go_to_singleton_buffer_point(\n        &mut self,\n        point: Point,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.go_to_singleton_buffer_range(point..point, window, cx);\n    }\n\n    pub fn go_to_singleton_buffer_range(\n        &mut self,\n        range: Range<Point>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let multibuffer = self.buffer().read(cx);\n        let Some(buffer) = multibuffer.as_singleton() else {\n            return;\n        };\n        let Some(start) = multibuffer.buffer_point_to_anchor(&buffer, range.start, cx) else {\n            return;\n        };\n        let Some(end) = multibuffer.buffer_point_to_anchor(&buffer, range.end, cx) else {\n            return;\n        };\n        self.change_selections(Some(Autoscroll::center()), window, cx, |s| {\n            s.select_anchor_ranges([start..end])\n        });\n    }\n\n    pub fn go_to_diagnostic(\n        &mut self,\n        _: &GoToDiagnostic,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.go_to_diagnostic_impl(Direction::Next, window, cx)\n    }\n\n    pub fn go_to_prev_diagnostic(\n        &mut self,\n        _: &GoToPreviousDiagnostic,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        self.go_to_diagnostic_impl(Direction::Prev, window, cx)\n    }\n\n    pub fn go_to_diagnostic_impl(\n        &mut self,\n        direction: Direction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let selection = self.selections.newest::<usize>(cx);\n\n        let mut active_group_id = None;\n        if let ActiveDiagnostic::Group(active_group) = &self.active_diagnostics {\n            if active_group.active_range.start.to_offset(&buffer) == selection.start {\n                active_group_id = Some(active_group.group_id);\n            }\n        }\n\n        fn filtered(\n            snapshot: EditorSnapshot,\n            diagnostics: impl Iterator<Item = DiagnosticEntry<usize>>,\n        ) -> impl Iterator<Item = DiagnosticEntry<usize>> {\n            diagnostics\n                .filter(|entry| entry.range.start != entry.range.end)\n                .filter(|entry| !entry.diagnostic.is_unnecessary)\n                .filter(move |entry| !snapshot.intersects_fold(entry.range.start))\n        }\n\n        let snapshot = self.snapshot(window, cx);\n        let before = filtered(\n            snapshot.clone(),\n            buffer\n                .diagnostics_in_range(0..selection.start)\n                .filter(|entry| entry.range.start <= selection.start),\n        );\n        let after = filtered(\n            snapshot,\n            buffer\n                .diagnostics_in_range(selection.start..buffer.len())\n                .filter(|entry| entry.range.start >= selection.start),\n        );\n\n        let mut found: Option<DiagnosticEntry<usize>> = None;\n        if direction == Direction::Prev {\n            'outer: for prev_diagnostics in [before.collect::<Vec<_>>(), after.collect::<Vec<_>>()]\n            {\n                for diagnostic in prev_diagnostics.into_iter().rev() {\n                    if diagnostic.range.start != selection.start\n                        || active_group_id\n                            .is_some_and(|active| diagnostic.diagnostic.group_id < active)\n                    {\n                        found = Some(diagnostic);\n                        break 'outer;\n                    }\n                }\n            }\n        } else {\n            for diagnostic in after.chain(before) {\n                if diagnostic.range.start != selection.start\n                    || active_group_id.is_some_and(|active| diagnostic.diagnostic.group_id > active)\n                {\n                    found = Some(diagnostic);\n                    break;\n                }\n            }\n        }\n        let Some(next_diagnostic) = found else {\n            return;\n        };\n\n        let Some(buffer_id) = buffer.anchor_after(next_diagnostic.range.start).buffer_id else {\n            return;\n        };\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select_ranges(vec![\n                next_diagnostic.range.start..next_diagnostic.range.start,\n            ])\n        });\n        self.activate_diagnostics(buffer_id, next_diagnostic, window, cx);\n        self.refresh_inline_completion(false, true, window, cx);\n    }\n\n    pub fn go_to_next_hunk(&mut self, _: &GoToHunk, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        let snapshot = self.snapshot(window, cx);\n        let selection = self.selections.newest::<Point>(cx);\n        self.go_to_hunk_before_or_after_position(\n            &snapshot,\n            selection.head(),\n            Direction::Next,\n            window,\n            cx,\n        );\n    }\n\n    pub fn go_to_hunk_before_or_after_position(\n        &mut self,\n        snapshot: &EditorSnapshot,\n        position: Point,\n        direction: Direction,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        let row = if direction == Direction::Next {\n            self.hunk_after_position(snapshot, position)\n                .map(|hunk| hunk.row_range.start)\n        } else {\n            self.hunk_before_position(snapshot, position)\n        };\n\n        if let Some(row) = row {\n            let destination = Point::new(row.0, 0);\n            let autoscroll = Autoscroll::center();\n\n            self.unfold_ranges(&[destination..destination], false, false, cx);\n            self.change_selections(Some(autoscroll), window, cx, |s| {\n                s.select_ranges([destination..destination]);\n            });\n        }\n    }\n\n    fn hunk_after_position(\n        &mut self,\n        snapshot: &EditorSnapshot,\n        position: Point,\n    ) -> Option<MultiBufferDiffHunk> {\n        snapshot\n            .buffer_snapshot\n            .diff_hunks_in_range(position..snapshot.buffer_snapshot.max_point())\n            .find(|hunk| hunk.row_range.start.0 > position.row)\n            .or_else(|| {\n                snapshot\n                    .buffer_snapshot\n                    .diff_hunks_in_range(Point::zero()..position)\n                    .find(|hunk| hunk.row_range.end.0 < position.row)\n            })\n    }\n\n    fn go_to_prev_hunk(\n        &mut self,\n        _: &GoToPreviousHunk,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::MovementAction);\n        let snapshot = self.snapshot(window, cx);\n        let selection = self.selections.newest::<Point>(cx);\n        self.go_to_hunk_before_or_after_position(\n            &snapshot,\n            selection.head(),\n            Direction::Prev,\n            window,\n            cx,\n        );\n    }\n\n    fn hunk_before_position(\n        &mut self,\n        snapshot: &EditorSnapshot,\n        position: Point,\n    ) -> Option<MultiBufferRow> {\n        snapshot\n            .buffer_snapshot\n            .diff_hunk_before(position)\n            .or_else(|| snapshot.buffer_snapshot.diff_hunk_before(Point::MAX))\n    }\n\n    fn go_to_next_change(\n        &mut self,\n        _: &GoToNextChange,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(selections) = self\n            .change_list\n            .next_change(1, Direction::Next)\n            .map(|s| s.to_vec())\n        {\n            self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                let map = s.display_map();\n                s.select_display_ranges(selections.iter().map(|a| {\n                    let point = a.to_display_point(&map);\n                    point..point\n                }))\n            })\n        }\n    }\n\n    fn go_to_previous_change(\n        &mut self,\n        _: &GoToPreviousChange,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(selections) = self\n            .change_list\n            .next_change(1, Direction::Prev)\n            .map(|s| s.to_vec())\n        {\n            self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                let map = s.display_map();\n                s.select_display_ranges(selections.iter().map(|a| {\n                    let point = a.to_display_point(&map);\n                    point..point\n                }))\n            })\n        }\n    }\n\n    fn go_to_line<T: 'static>(\n        &mut self,\n        position: Anchor,\n        highlight_color: Option<Hsla>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.snapshot(window, cx).display_snapshot;\n        let position = position.to_point(&snapshot.buffer_snapshot);\n        let start = snapshot\n            .buffer_snapshot\n            .clip_point(Point::new(position.row, 0), Bias::Left);\n        let end = start + Point::new(1, 0);\n        let start = snapshot.buffer_snapshot.anchor_before(start);\n        let end = snapshot.buffer_snapshot.anchor_before(end);\n\n        self.highlight_rows::<T>(\n            start..end,\n            highlight_color\n                .unwrap_or_else(|| cx.theme().colors().editor_highlighted_line_background),\n            Default::default(),\n            cx,\n        );\n\n        if self.buffer.read(cx).is_singleton() {\n            self.request_autoscroll(Autoscroll::center().for_anchor(start), cx);\n        }\n    }\n\n    pub fn go_to_definition(\n        &mut self,\n        _: &GoToDefinition,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        let definition =\n            self.go_to_definition_of_kind(GotoDefinitionKind::Symbol, false, window, cx);\n        let fallback_strategy = EditorSettings::get_global(cx).go_to_definition_fallback;\n        cx.spawn_in(window, async move |editor, cx| {\n            if definition.await? == Navigated::Yes {\n                return Ok(Navigated::Yes);\n            }\n            match fallback_strategy {\n                GoToDefinitionFallback::None => Ok(Navigated::No),\n                GoToDefinitionFallback::FindAllReferences => {\n                    match editor.update_in(cx, |editor, window, cx| {\n                        editor.find_all_references(&FindAllReferences, window, cx)\n                    })? {\n                        Some(references) => references.await,\n                        None => Ok(Navigated::No),\n                    }\n                }\n            }\n        })\n    }\n\n    pub fn go_to_declaration(\n        &mut self,\n        _: &GoToDeclaration,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Declaration, false, window, cx)\n    }\n\n    pub fn go_to_declaration_split(\n        &mut self,\n        _: &GoToDeclaration,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Declaration, true, window, cx)\n    }\n\n    pub fn go_to_implementation(\n        &mut self,\n        _: &GoToImplementation,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Implementation, false, window, cx)\n    }\n\n    pub fn go_to_implementation_split(\n        &mut self,\n        _: &GoToImplementationSplit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Implementation, true, window, cx)\n    }\n\n    pub fn go_to_type_definition(\n        &mut self,\n        _: &GoToTypeDefinition,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Type, false, window, cx)\n    }\n\n    pub fn go_to_definition_split(\n        &mut self,\n        _: &GoToDefinitionSplit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Symbol, true, window, cx)\n    }\n\n    pub fn go_to_type_definition_split(\n        &mut self,\n        _: &GoToTypeDefinitionSplit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Type, true, window, cx)\n    }\n\n    fn go_to_definition_of_kind(\n        &mut self,\n        kind: GotoDefinitionKind,\n        split: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        let Some(provider) = self.semantics_provider.clone() else {\n            return Task::ready(Ok(Navigated::No));\n        };\n        let head = self.selections.newest::<usize>(cx).head();\n        let buffer = self.buffer.read(cx);\n        let (buffer, head) = if let Some(text_anchor) = buffer.text_anchor_for_position(head, cx) {\n            text_anchor\n        } else {\n            return Task::ready(Ok(Navigated::No));\n        };\n\n        let Some(definitions) = provider.definitions(&buffer, head, kind, cx) else {\n            return Task::ready(Ok(Navigated::No));\n        };\n\n        cx.spawn_in(window, async move |editor, cx| {\n            let definitions = definitions.await?;\n            let navigated = editor\n                .update_in(cx, |editor, window, cx| {\n                    editor.navigate_to_hover_links(\n                        Some(kind),\n                        definitions\n                            .into_iter()\n                            .filter(|location| {\n                                hover_links::exclude_link_to_position(&buffer, &head, location, cx)\n                            })\n                            .map(HoverLink::Text)\n                            .collect::<Vec<_>>(),\n                        split,\n                        window,\n                        cx,\n                    )\n                })?\n                .await?;\n            anyhow::Ok(navigated)\n        })\n    }\n\n    pub fn open_url(&mut self, _: &OpenUrl, window: &mut Window, cx: &mut Context<Self>) {\n        let selection = self.selections.newest_anchor();\n        let head = selection.head();\n        let tail = selection.tail();\n\n        let Some((buffer, start_position)) =\n            self.buffer.read(cx).text_anchor_for_position(head, cx)\n        else {\n            return;\n        };\n\n        let end_position = if head != tail {\n            let Some((_, pos)) = self.buffer.read(cx).text_anchor_for_position(tail, cx) else {\n                return;\n            };\n            Some(pos)\n        } else {\n            None\n        };\n\n        let url_finder = cx.spawn_in(window, async move |editor, cx| {\n            let url = if let Some(end_pos) = end_position {\n                find_url_from_range(&buffer, start_position..end_pos, cx.clone())\n            } else {\n                find_url(&buffer, start_position, cx.clone()).map(|(_, url)| url)\n            };\n\n            if let Some(url) = url {\n                editor.update(cx, |_, cx| {\n                    cx.open_url(&url);\n                })\n            } else {\n                Ok(())\n            }\n        });\n\n        url_finder.detach();\n    }\n\n    pub fn open_selected_filename(\n        &mut self,\n        _: &OpenSelectedFilename,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(workspace) = self.workspace() else {\n            return;\n        };\n\n        let position = self.selections.newest_anchor().head();\n\n        let Some((buffer, buffer_position)) =\n            self.buffer.read(cx).text_anchor_for_position(position, cx)\n        else {\n            return;\n        };\n\n        let project = self.project.clone();\n\n        cx.spawn_in(window, async move |_, cx| {\n            let result = find_file(&buffer, project, buffer_position, cx).await;\n\n            if let Some((_, path)) = result {\n                workspace\n                    .update_in(cx, |workspace, window, cx| {\n                        workspace.open_resolved_path(path, window, cx)\n                    })?\n                    .await?;\n            }\n            anyhow::Ok(())\n        })\n        .detach();\n    }\n\n    pub(crate) fn navigate_to_hover_links(\n        &mut self,\n        kind: Option<GotoDefinitionKind>,\n        mut definitions: Vec<HoverLink>,\n        split: bool,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<Navigated>> {\n        // If there is one definition, just open it directly\n        if definitions.len() == 1 {\n            let definition = definitions.pop().unwrap();\n\n            enum TargetTaskResult {\n                Location(Option<Location>),\n                AlreadyNavigated,\n            }\n\n            let target_task = match definition {\n                HoverLink::Text(link) => {\n                    Task::ready(anyhow::Ok(TargetTaskResult::Location(Some(link.target))))\n                }\n                HoverLink::InlayHint(lsp_location, server_id) => {\n                    let computation =\n                        self.compute_target_location(lsp_location, server_id, window, cx);\n                    cx.background_spawn(async move {\n                        let location = computation.await?;\n                        Ok(TargetTaskResult::Location(location))\n                    })\n                }\n                HoverLink::Url(url) => {\n                    cx.open_url(&url);\n                    Task::ready(Ok(TargetTaskResult::AlreadyNavigated))\n                }\n                HoverLink::File(path) => {\n                    if let Some(workspace) = self.workspace() {\n                        cx.spawn_in(window, async move |_, cx| {\n                            workspace\n                                .update_in(cx, |workspace, window, cx| {\n                                    workspace.open_resolved_path(path, window, cx)\n                                })?\n                                .await\n                                .map(|_| TargetTaskResult::AlreadyNavigated)\n                        })\n                    } else {\n                        Task::ready(Ok(TargetTaskResult::Location(None)))\n                    }\n                }\n            };\n            cx.spawn_in(window, async move |editor, cx| {\n                let target = match target_task.await.context(": "",
    ")? {\n                    TargetTaskResult::AlreadyNavigated => return Ok(Navigated::Yes),\n                    TargetTaskResult::Location(None) => return Ok(Navigated::No),\n                    TargetTaskResult::Location(Some(target)) => target,\n                };\n\n                editor.update_in(cx, |editor, window, cx| {\n                    let Some(workspace) = editor.workspace() else {\n                        return Navigated::No;\n                    };\n                    let pane = workspace.read(cx).active_pane().clone();\n\n                    let range = target.range.to_point(target.buffer.read(cx));\n                    let range = editor.range_for_match(&range);\n                    let range = collapse_multiline_range(range);\n\n                    if !split\n                        && Some(&target.buffer) == editor.buffer.read(cx).as_singleton().as_ref()\n                    {\n                        editor.go_to_singleton_buffer_range(range.clone(), window, cx);\n                    } else {\n                        window.defer(cx, move |window, cx| {\n                            let target_editor: Entity<Self> =\n                                workspace.update(cx, |workspace, cx| {\n                                    let pane = if split {\n                                        workspace.adjacent_pane(window, cx)\n                                    } else {\n                                        workspace.active_pane().clone()\n                                    };\n\n                                    workspace.open_project_item(\n                                        pane,\n                                        target.buffer.clone(),\n                                        true,\n                                        true,\n                                        window,\n                                        cx,\n                                    )\n                                });\n                            target_editor.update(cx, |target_editor, cx| {\n                                // When selecting a definition in a different buffer, disable the nav history\n                                // to avoid creating a history entry at the previous cursor location.\n                                pane.update(cx, |pane, _| pane.disable_history());\n                                target_editor.go_to_singleton_buffer_range(range, window, cx);\n                                pane.update(cx, |pane, _| pane.enable_history());\n                            });\n                        });\n                    }\n                    Navigated::Yes\n                })\n            })\n        } else if !definitions.is_empty() {\n            cx.spawn_in(window, async move |editor, cx| {\n                let (title, location_tasks, workspace) = editor\n                    .update_in(cx, |editor, window, cx| {\n                        let tab_kind = match kind {\n                            Some(GotoDefinitionKind::Implementation) => ": "",
    ",\n                            _ => ": "",
    ",\n                        };\n                        let title = definitions\n                            .iter()\n                            .find_map(|definition| match definition {\n                                HoverLink::Text(link) => link.origin.as_ref().map(|origin| {\n                                    let buffer = origin.buffer.read(cx);\n                                    format!(\n                                        ": "",
    ",\n                                        tab_kind,\n                                        buffer\n                                            .text_for_range(origin.range.clone())\n                                            .collect::<String>()\n                                    )\n                                }),\n                                HoverLink::InlayHint(_, _) => None,\n                                HoverLink::Url(_) => None,\n                                HoverLink::File(_) => None,\n                            })\n                            .unwrap_or(tab_kind.to_string());\n                        let location_tasks = definitions\n                            .into_iter()\n                            .map(|definition| match definition {\n                                HoverLink::Text(link) => Task::ready(Ok(Some(link.target))),\n                                HoverLink::InlayHint(lsp_location, server_id) => editor\n                                    .compute_target_location(lsp_location, server_id, window, cx),\n                                HoverLink::Url(_) => Task::ready(Ok(None)),\n                                HoverLink::File(_) => Task::ready(Ok(None)),\n                            })\n                            .collect::<Vec<_>>();\n                        (title, location_tasks, editor.workspace().clone())\n                    })\n                    .context(": "",
    ")?;\n\n                let locations = future::join_all(location_tasks)\n                    .await\n                    .into_iter()\n                    .filter_map(|location| location.transpose())\n                    .collect::<Result<_>>()\n                    .context(": "",
    ")?;\n\n                let Some(workspace) = workspace else {\n                    return Ok(Navigated::No);\n                };\n                let opened = workspace\n                    .update_in(cx, |workspace, window, cx| {\n                        Self::open_locations_in_multibuffer(\n                            workspace,\n                            locations,\n                            title,\n                            split,\n                            MultibufferSelectionMode::First,\n                            window,\n                            cx,\n                        )\n                    })\n                    .ok();\n\n                anyhow::Ok(Navigated::from_bool(opened.is_some()))\n            })\n        } else {\n            Task::ready(Ok(Navigated::No))\n        }\n    }\n\n    fn compute_target_location(\n        &self,\n        lsp_location: lsp::Location,\n        server_id: LanguageServerId,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<Option<Location>>> {\n        let Some(project) = self.project.clone() else {\n            return Task::ready(Ok(None));\n        };\n\n        cx.spawn_in(window, async move |editor, cx| {\n            let location_task = editor.update(cx, |_, cx| {\n                project.update(cx, |project, cx| {\n                    let language_server_name = project\n                        .language_server_statuses(cx)\n                        .find(|(id, _)| server_id == *id)\n                        .map(|(_, status)| LanguageServerName::from(status.name.as_str()));\n                    language_server_name.map(|language_server_name| {\n                        project.open_local_buffer_via_lsp(\n                            lsp_location.uri.clone(),\n                            server_id,\n                            language_server_name,\n                            cx,\n                        )\n                    })\n                })\n            })?;\n            let location = match location_task {\n                Some(task) => Some({\n                    let target_buffer_handle = task.await.context(": "",
    ")?;\n                    let range = target_buffer_handle.read_with(cx, |target_buffer, _| {\n                        let target_start = target_buffer\n                            .clip_point_utf16(point_from_lsp(lsp_location.range.start), Bias::Left);\n                        let target_end = target_buffer\n                            .clip_point_utf16(point_from_lsp(lsp_location.range.end), Bias::Left);\n                        target_buffer.anchor_after(target_start)\n                            ..target_buffer.anchor_before(target_end)\n                    })?;\n                    Location {\n                        buffer: target_buffer_handle,\n                        range,\n                    }\n                }),\n                None => None,\n            };\n            Ok(location)\n        })\n    }\n\n    pub fn find_all_references(\n        &mut self,\n        _: &FindAllReferences,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<Navigated>>> {\n        let selection = self.selections.newest::<usize>(cx);\n        let multi_buffer = self.buffer.read(cx);\n        let head = selection.head();\n\n        let multi_buffer_snapshot = multi_buffer.snapshot(cx);\n        let head_anchor = multi_buffer_snapshot.anchor_at(\n            head,\n            if head < selection.tail() {\n                Bias::Right\n            } else {\n                Bias::Left\n            },\n        );\n\n        match self\n            .find_all_references_task_sources\n            .binary_search_by(|anchor| anchor.cmp(&head_anchor, &multi_buffer_snapshot))\n        {\n            Ok(_) => {\n                log::info!(\n                    ": "",
    "\n                );\n                return None;\n            }\n            Err(i) => {\n                self.find_all_references_task_sources.insert(i, head_anchor);\n            }\n        }\n\n        let (buffer, head) = multi_buffer.text_anchor_for_position(head, cx)?;\n        let workspace = self.workspace()?;\n        let project = workspace.read(cx).project().clone();\n        let references = project.update(cx, |project, cx| project.references(&buffer, head, cx));\n        Some(cx.spawn_in(window, async move |editor, cx| {\n            let _cleanup = cx.on_drop(&editor, move |editor, _| {\n                if let Ok(i) = editor\n                    .find_all_references_task_sources\n                    .binary_search_by(|anchor| anchor.cmp(&head_anchor, &multi_buffer_snapshot))\n                {\n                    editor.find_all_references_task_sources.remove(i);\n                }\n            });\n\n            let locations = references.await?;\n            if locations.is_empty() {\n                return anyhow::Ok(Navigated::No);\n            }\n\n            workspace.update_in(cx, |workspace, window, cx| {\n                let title = locations\n                    .first()\n                    .as_ref()\n                    .map(|location| {\n                        let buffer = location.buffer.read(cx);\n                        format!(\n                            ": "",
    ",\n                            buffer\n                                .text_for_range(location.range.clone())\n                                .collect::<String>()\n                        )\n                    })\n                    .unwrap();\n                Self::open_locations_in_multibuffer(\n                    workspace,\n                    locations,\n                    title,\n                    false,\n                    MultibufferSelectionMode::First,\n                    window,\n                    cx,\n                );\n                Navigated::Yes\n            })\n        }))\n    }\n\n    /// Opens a multibuffer with the given project locations in it\n    pub fn open_locations_in_multibuffer(\n        workspace: &mut Workspace,\n        mut locations: Vec<Location>,\n        title: String,\n        split: bool,\n        multibuffer_selection_mode: MultibufferSelectionMode,\n        window: &mut Window,\n        cx: &mut Context<Workspace>,\n    ) {\n        // If there are multiple definitions, open them in a multibuffer\n        locations.sort_by_key(|location| location.buffer.read(cx).remote_id());\n        let mut locations = locations.into_iter().peekable();\n        let mut ranges: Vec<Range<Anchor>> = Vec::new();\n        let capability = workspace.project().read(cx).capability();\n\n        let excerpt_buffer = cx.new(|cx| {\n            let mut multibuffer = MultiBuffer::new(capability);\n            while let Some(location) = locations.next() {\n                let buffer = location.buffer.read(cx);\n                let mut ranges_for_buffer = Vec::new();\n                let range = location.range.to_point(buffer);\n                ranges_for_buffer.push(range.clone());\n\n                while let Some(next_location) = locations.peek() {\n                    if next_location.buffer == location.buffer {\n                        ranges_for_buffer.push(next_location.range.to_point(buffer));\n                        locations.next();\n                    } else {\n                        break;\n                    }\n                }\n\n                ranges_for_buffer.sort_by_key(|range| (range.start, Reverse(range.end)));\n                let (new_ranges, _) = multibuffer.set_excerpts_for_path(\n                    PathKey::for_buffer(&location.buffer, cx),\n                    location.buffer.clone(),\n                    ranges_for_buffer,\n                    DEFAULT_MULTIBUFFER_CONTEXT,\n                    cx,\n                );\n                ranges.extend(new_ranges)\n            }\n\n            multibuffer.with_title(title)\n        });\n\n        let editor = cx.new(|cx| {\n            Editor::for_multibuffer(\n                excerpt_buffer,\n                Some(workspace.project().clone()),\n                window,\n                cx,\n            )\n        });\n        editor.update(cx, |editor, cx| {\n            match multibuffer_selection_mode {\n                MultibufferSelectionMode::First => {\n                    if let Some(first_range) = ranges.first() {\n                        editor.change_selections(None, window, cx, |selections| {\n                            selections.clear_disjoint();\n                            selections.select_anchor_ranges(std::iter::once(first_range.clone()));\n                        });\n                    }\n                    editor.highlight_background::<Self>(\n                        &ranges,\n                        |theme| theme.editor_highlighted_line_background,\n                        cx,\n                    );\n                }\n                MultibufferSelectionMode::All => {\n                    editor.change_selections(None, window, cx, |selections| {\n                        selections.clear_disjoint();\n                        selections.select_anchor_ranges(ranges);\n                    });\n                }\n            }\n            editor.register_buffers_with_language_servers(cx);\n        });\n\n        let item = Box::new(editor);\n        let item_id = item.item_id();\n\n        if split {\n            workspace.split_item(SplitDirection::Right, item.clone(), window, cx);\n        } else {\n            if PreviewTabsSettings::get_global(cx).enable_preview_from_code_navigation {\n                let (preview_item_id, preview_item_idx) =\n                    workspace.active_pane().read_with(cx, |pane, _| {\n                        (pane.preview_item_id(), pane.preview_item_idx())\n                    });\n\n                workspace.add_item_to_active_pane(item.clone(), preview_item_idx, true, window, cx);\n\n                if let Some(preview_item_id) = preview_item_id {\n                    workspace.active_pane().update(cx, |pane, cx| {\n                        pane.remove_item(preview_item_id, false, false, window, cx);\n                    });\n                }\n            } else {\n                workspace.add_item_to_active_pane(item.clone(), None, true, window, cx);\n            }\n        }\n        workspace.active_pane().update(cx, |pane, cx| {\n            pane.set_preview_item_id(Some(item_id), cx);\n        });\n    }\n\n    pub fn rename(\n        &mut self,\n        _: &Rename,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        use language::ToOffset as _;\n\n        let provider = self.semantics_provider.clone()?;\n        let selection = self.selections.newest_anchor().clone();\n        let (cursor_buffer, cursor_buffer_position) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(selection.head(), cx)?;\n        let (tail_buffer, cursor_buffer_position_end) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(selection.tail(), cx)?;\n        if tail_buffer != cursor_buffer {\n            return None;\n        }\n\n        let snapshot = cursor_buffer.read(cx).snapshot();\n        let cursor_buffer_offset = cursor_buffer_position.to_offset(&snapshot);\n        let cursor_buffer_offset_end = cursor_buffer_position_end.to_offset(&snapshot);\n        let prepare_rename = provider\n            .range_for_rename(&cursor_buffer, cursor_buffer_position, cx)\n            .unwrap_or_else(|| Task::ready(Ok(None)));\n        drop(snapshot);\n\n        Some(cx.spawn_in(window, async move |this, cx| {\n            let rename_range = if let Some(range) = prepare_rename.await? {\n                Some(range)\n            } else {\n                this.update(cx, |this, cx| {\n                    let buffer = this.buffer.read(cx).snapshot(cx);\n                    let mut buffer_highlights = this\n                        .document_highlights_for_position(selection.head(), &buffer)\n                        .filter(|highlight| {\n                            highlight.start.excerpt_id == selection.head().excerpt_id\n                                && highlight.end.excerpt_id == selection.head().excerpt_id\n                        });\n                    buffer_highlights\n                        .next()\n                        .map(|highlight| highlight.start.text_anchor..highlight.end.text_anchor)\n                })?\n            };\n            if let Some(rename_range) = rename_range {\n                this.update_in(cx, |this, window, cx| {\n                    let snapshot = cursor_buffer.read(cx).snapshot();\n                    let rename_buffer_range = rename_range.to_offset(&snapshot);\n                    let cursor_offset_in_rename_range =\n                        cursor_buffer_offset.saturating_sub(rename_buffer_range.start);\n                    let cursor_offset_in_rename_range_end =\n                        cursor_buffer_offset_end.saturating_sub(rename_buffer_range.start);\n\n                    this.take_rename(false, window, cx);\n                    let buffer = this.buffer.read(cx).read(cx);\n                    let cursor_offset = selection.head().to_offset(&buffer);\n                    let rename_start = cursor_offset.saturating_sub(cursor_offset_in_rename_range);\n                    let rename_end = rename_start + rename_buffer_range.len();\n                    let range = buffer.anchor_before(rename_start)..buffer.anchor_after(rename_end);\n                    let mut old_highlight_id = None;\n                    let old_name: Arc<str> = buffer\n                        .chunks(rename_start..rename_end, true)\n                        .map(|chunk| {\n                            if old_highlight_id.is_none() {\n                                old_highlight_id = chunk.syntax_highlight_id;\n                            }\n                            chunk.text\n                        })\n                        .collect::<String>()\n                        .into();\n\n                    drop(buffer);\n\n                    // Position the selection in the rename editor so that it matches the current selection.\n                    this.show_local_selections = false;\n                    let rename_editor = cx.new(|cx| {\n                        let mut editor = Editor::single_line(window, cx);\n                        editor.buffer.update(cx, |buffer, cx| {\n                            buffer.edit([(0..0, old_name.clone())], None, cx)\n                        });\n                        let rename_selection_range = match cursor_offset_in_rename_range\n                            .cmp(&cursor_offset_in_rename_range_end)\n                        {\n                            Ordering::Equal => {\n                                editor.select_all(&SelectAll, window, cx);\n                                return editor;\n                            }\n                            Ordering::Less => {\n                                cursor_offset_in_rename_range..cursor_offset_in_rename_range_end\n                            }\n                            Ordering::Greater => {\n                                cursor_offset_in_rename_range_end..cursor_offset_in_rename_range\n                            }\n                        };\n                        if rename_selection_range.end > old_name.len() {\n                            editor.select_all(&SelectAll, window, cx);\n                        } else {\n                            editor.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                                s.select_ranges([rename_selection_range]);\n                            });\n                        }\n                        editor\n                    });\n                    cx.subscribe(&rename_editor, |_, _, e: &EditorEvent, cx| {\n                        if e == &EditorEvent::Focused {\n                            cx.emit(EditorEvent::FocusedIn)\n                        }\n                    })\n                    .detach();\n\n                    let write_highlights =\n                        this.clear_background_highlights::<DocumentHighlightWrite>(cx);\n                    let read_highlights =\n                        this.clear_background_highlights::<DocumentHighlightRead>(cx);\n                    let ranges = write_highlights\n                        .iter()\n                        .flat_map(|(_, ranges)| ranges.iter())\n                        .chain(read_highlights.iter().flat_map(|(_, ranges)| ranges.iter()))\n                        .cloned()\n                        .collect();\n\n                    this.highlight_text::<Rename>(\n                        ranges,\n                        HighlightStyle {\n                            fade_out: Some(0.6),\n                            ..Default::default()\n                        },\n                        cx,\n                    );\n                    let rename_focus_handle = rename_editor.focus_handle(cx);\n                    window.focus(&rename_focus_handle);\n                    let block_id = this.insert_blocks(\n                        [BlockProperties {\n                            style: BlockStyle::Flex,\n                            placement: BlockPlacement::Below(range.start),\n                            height: Some(1),\n                            render: Arc::new({\n                                let rename_editor = rename_editor.clone();\n                                move |cx: &mut BlockContext| {\n                                    let mut text_style = cx.editor_style.text.clone();\n                                    if let Some(highlight_style) = old_highlight_id\n                                        .and_then(|h| h.style(&cx.editor_style.syntax))\n                                    {\n                                        text_style = text_style.highlight(highlight_style);\n                                    }\n                                    div()\n                                        .block_mouse_except_scroll()\n                                        .pl(cx.anchor_x)\n                                        .child(EditorElement::new(\n                                            &rename_editor,\n                                            EditorStyle {\n                                                background: cx.theme().system().transparent,\n                                                local_player: cx.editor_style.local_player,\n                                                text: text_style,\n                                                scrollbar_width: cx.editor_style.scrollbar_width,\n                                                syntax: cx.editor_style.syntax.clone(),\n                                                status: cx.editor_style.status.clone(),\n                                                inlay_hints_style: HighlightStyle {\n                                                    font_weight: Some(FontWeight::BOLD),\n                                                    ..make_inlay_hints_style(cx.app)\n                                                },\n                                                inline_completion_styles: make_suggestion_styles(\n                                                    cx.app,\n                                                ),\n                                                ..EditorStyle::default()\n                                            },\n                                        ))\n                                        .into_any_element()\n                                }\n                            }),\n                            priority: 0,\n                            render_in_minimap: true,\n                        }],\n                        Some(Autoscroll::fit()),\n                        cx,\n                    )[0];\n                    this.pending_rename = Some(RenameState {\n                        range,\n                        old_name,\n                        editor: rename_editor,\n                        block_id,\n                    });\n                })?;\n            }\n\n            Ok(())\n        }))\n    }\n\n    pub fn confirm_rename(\n        &mut self,\n        _: &ConfirmRename,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        let rename = self.take_rename(false, window, cx)?;\n        let workspace = self.workspace()?.downgrade();\n        let (buffer, start) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(rename.range.start, cx)?;\n        let (end_buffer, _) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(rename.range.end, cx)?;\n        if buffer != end_buffer {\n            return None;\n        }\n\n        let old_name = rename.old_name;\n        let new_name = rename.editor.read(cx).text(cx);\n\n        let rename = self.semantics_provider.as_ref()?.perform_rename(\n            &buffer,\n            start,\n            new_name.clone(),\n            cx,\n        )?;\n\n        Some(cx.spawn_in(window, async move |editor, cx| {\n            let project_transaction = rename.await?;\n            Self::open_project_transaction(\n                &editor,\n                workspace,\n                project_transaction,\n                format!(": "",
    ", old_name, new_name),\n                cx,\n            )\n            .await?;\n\n            editor.update(cx, |editor, cx| {\n                editor.refresh_document_highlights(cx);\n            })?;\n            Ok(())\n        }))\n    }\n\n    fn take_rename(\n        &mut self,\n        moving_cursor: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<RenameState> {\n        let rename = self.pending_rename.take()?;\n        if rename.editor.focus_handle(cx).is_focused(window) {\n            window.focus(&self.focus_handle);\n        }\n\n        self.remove_blocks(\n            [rename.block_id].into_iter().collect(),\n            Some(Autoscroll::fit()),\n            cx,\n        );\n        self.clear_highlights::<Rename>(cx);\n        self.show_local_selections = true;\n\n        if moving_cursor {\n            let cursor_in_rename_editor = rename.editor.update(cx, |editor, cx| {\n                editor.selections.newest::<usize>(cx).head()\n            });\n\n            // Update the selection to match the position of the selection inside\n            // the rename editor.\n            let snapshot = self.buffer.read(cx).read(cx);\n            let rename_range = rename.range.to_offset(&snapshot);\n            let cursor_in_editor = snapshot\n                .clip_offset(rename_range.start + cursor_in_rename_editor, Bias::Left)\n                .min(rename_range.end);\n            drop(snapshot);\n\n            self.change_selections(None, window, cx, |s| {\n                s.select_ranges(vec![cursor_in_editor..cursor_in_editor])\n            });\n        } else {\n            self.refresh_document_highlights(cx);\n        }\n\n        Some(rename)\n    }\n\n    pub fn pending_rename(&self) -> Option<&RenameState> {\n        self.pending_rename.as_ref()\n    }\n\n    fn format(\n        &mut self,\n        _: &Format,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n\n        let project = match &self.project {\n            Some(project) => project.clone(),\n            None => return None,\n        };\n\n        Some(self.perform_format(\n            project,\n            FormatTrigger::Manual,\n            FormatTarget::Buffers(self.buffer.read(cx).all_buffers()),\n            window,\n            cx,\n        ))\n    }\n\n    fn format_selections(\n        &mut self,\n        _: &FormatSelections,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n\n        let project = match &self.project {\n            Some(project) => project.clone(),\n            None => return None,\n        };\n\n        let ranges = self\n            .selections\n            .all_adjusted(cx)\n            .into_iter()\n            .map(|selection| selection.range())\n            .collect_vec();\n\n        Some(self.perform_format(\n            project,\n            FormatTrigger::Manual,\n            FormatTarget::Ranges(ranges),\n            window,\n            cx,\n        ))\n    }\n\n    fn perform_format(\n        &mut self,\n        project: Entity<Project>,\n        trigger: FormatTrigger,\n        target: FormatTarget,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        let buffer = self.buffer.clone();\n        let (buffers, target) = match target {\n            FormatTarget::Buffers(buffers) => (buffers, LspFormatTarget::Buffers),\n            FormatTarget::Ranges(selection_ranges) => {\n                let multi_buffer = buffer.read(cx);\n                let snapshot = multi_buffer.read(cx);\n                let mut buffers = HashSet::default();\n                let mut buffer_id_to_ranges: BTreeMap<BufferId, Vec<Range<text::Anchor>>> =\n                    BTreeMap::new();\n                for selection_range in selection_ranges {\n                    for (buffer, buffer_range, _) in\n                        snapshot.range_to_buffer_ranges(selection_range)\n                    {\n                        let buffer_id = buffer.remote_id();\n                        let start = buffer.anchor_before(buffer_range.start);\n                        let end = buffer.anchor_after(buffer_range.end);\n                        buffers.insert(multi_buffer.buffer(buffer_id).unwrap());\n                        buffer_id_to_ranges\n                            .entry(buffer_id)\n                            .and_modify(|buffer_ranges| buffer_ranges.push(start..end))\n                            .or_insert_with(|| vec![start..end]);\n                    }\n                }\n                (buffers, LspFormatTarget::Ranges(buffer_id_to_ranges))\n            }\n        };\n\n        let transaction_id_prev = buffer.read(cx).last_transaction_id(cx);\n        let selections_prev = transaction_id_prev\n            .and_then(|transaction_id_prev| {\n                // default to selections as they were after the last edit, if we have them,\n                // instead of how they are now.\n                // This will make it so that editing, moving somewhere else, formatting, then undoing the format\n                // will take you back to where you made the last edit, instead of staying where you scrolled\n                self.selection_history\n                    .transaction(transaction_id_prev)\n                    .map(|t| t.0.clone())\n            })\n            .unwrap_or_else(|| {\n                log::info!(": "",
    ");\n                self.selections.disjoint_anchors()\n            });\n\n        let mut timeout = cx.background_executor().timer(FORMAT_TIMEOUT).fuse();\n        let format = project.update(cx, |project, cx| {\n            project.format(buffers, target, true, trigger, cx)\n        });\n\n        cx.spawn_in(window, async move |editor, cx| {\n            let transaction = futures::select_biased! {\n                transaction = format.log_err().fuse() => transaction,\n                () = timeout => {\n                    log::warn!(": "",
    ");\n                    None\n                }\n            };\n\n            buffer\n                .update(cx, |buffer, cx| {\n                    if let Some(transaction) = transaction {\n                        if !buffer.is_singleton() {\n                            buffer.push_transaction(&transaction.0, cx);\n                        }\n                    }\n                    cx.notify();\n                })\n                .ok();\n\n            if let Some(transaction_id_now) =\n                buffer.read_with(cx, |b, cx| b.last_transaction_id(cx))?\n            {\n                let has_new_transaction = transaction_id_prev != Some(transaction_id_now);\n                if has_new_transaction {\n                    _ = editor.update(cx, |editor, _| {\n                        editor\n                            .selection_history\n                            .insert_transaction(transaction_id_now, selections_prev);\n                    });\n                }\n            }\n\n            Ok(())\n        })\n    }\n\n    fn organize_imports(\n        &mut self,\n        _: &OrganizeImports,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n        let project = match &self.project {\n            Some(project) => project.clone(),\n            None => return None,\n        };\n        Some(self.perform_code_action_kind(\n            project,\n            CodeActionKind::SOURCE_ORGANIZE_IMPORTS,\n            window,\n            cx,\n        ))\n    }\n\n    fn perform_code_action_kind(\n        &mut self,\n        project: Entity<Project>,\n        kind: CodeActionKind,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        let buffer = self.buffer.clone();\n        let buffers = buffer.read(cx).all_buffers();\n        let mut timeout = cx.background_executor().timer(CODE_ACTION_TIMEOUT).fuse();\n        let apply_action = project.update(cx, |project, cx| {\n            project.apply_code_action_kind(buffers, kind, true, cx)\n        });\n        cx.spawn_in(window, async move |_, cx| {\n            let transaction = futures::select_biased! {\n                () = timeout => {\n                    log::warn!(": "",
    ");\n                    None\n                }\n                transaction = apply_action.log_err().fuse() => transaction,\n            };\n            buffer\n                .update(cx, |buffer, cx| {\n                    // check if we need this\n                    if let Some(transaction) = transaction {\n                        if !buffer.is_singleton() {\n                            buffer.push_transaction(&transaction.0, cx);\n                        }\n                    }\n                    cx.notify();\n                })\n                .ok();\n            Ok(())\n        })\n    }\n\n    fn restart_language_server(\n        &mut self,\n        _: &RestartLanguageServer,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(project) = self.project.clone() {\n            self.buffer.update(cx, |multi_buffer, cx| {\n                project.update(cx, |project, cx| {\n                    project.restart_language_servers_for_buffers(\n                        multi_buffer.all_buffers().into_iter().collect(),\n                        cx,\n                    );\n                });\n            })\n        }\n    }\n\n    fn stop_language_server(\n        &mut self,\n        _: &StopLanguageServer,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(project) = self.project.clone() {\n            self.buffer.update(cx, |multi_buffer, cx| {\n                project.update(cx, |project, cx| {\n                    project.stop_language_servers_for_buffers(\n                        multi_buffer.all_buffers().into_iter().collect(),\n                        cx,\n                    );\n                    cx.emit(project::Event::RefreshInlayHints);\n                });\n            });\n        }\n    }\n\n    fn cancel_language_server_work(\n        workspace: &mut Workspace,\n        _: &actions::CancelLanguageServerWork,\n        _: &mut Window,\n        cx: &mut Context<Workspace>,\n    ) {\n        let project = workspace.project();\n        let buffers = workspace\n            .active_item(cx)\n            .and_then(|item| item.act_as::<Editor>(cx))\n            .map_or(HashSet::default(), |editor| {\n                editor.read(cx).buffer.read(cx).all_buffers()\n            });\n        project.update(cx, |project, cx| {\n            project.cancel_language_server_work_for_buffers(buffers, cx);\n        });\n    }\n\n    fn show_character_palette(\n        &mut self,\n        _: &ShowCharacterPalette,\n        window: &mut Window,\n        _: &mut Context<Self>,\n    ) {\n        window.show_character_palette();\n    }\n\n    fn refresh_active_diagnostics(&mut self, cx: &mut Context<Editor>) {\n        if self.mode.is_minimap() {\n            return;\n        }\n\n        if let ActiveDiagnostic::Group(active_diagnostics) = &mut self.active_diagnostics {\n            let buffer = self.buffer.read(cx).snapshot(cx);\n            let primary_range_start = active_diagnostics.active_range.start.to_offset(&buffer);\n            let primary_range_end = active_diagnostics.active_range.end.to_offset(&buffer);\n            let is_valid = buffer\n                .diagnostics_in_range::<usize>(primary_range_start..primary_range_end)\n                .any(|entry| {\n                    entry.diagnostic.is_primary\n                        && !entry.range.is_empty()\n                        && entry.range.start == primary_range_start\n                        && entry.diagnostic.message == active_diagnostics.active_message\n                });\n\n            if !is_valid {\n                self.dismiss_diagnostics(cx);\n            }\n        }\n    }\n\n    pub fn active_diagnostic_group(&self) -> Option<&ActiveDiagnosticGroup> {\n        match &self.active_diagnostics {\n            ActiveDiagnostic::Group(group) => Some(group),\n            _ => None,\n        }\n    }\n\n    pub fn set_all_diagnostics_active(&mut self, cx: &mut Context<Self>) {\n        self.dismiss_diagnostics(cx);\n        self.active_diagnostics = ActiveDiagnostic::All;\n    }\n\n    fn activate_diagnostics(\n        &mut self,\n        buffer_id: BufferId,\n        diagnostic: DiagnosticEntry<usize>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.active_diagnostics, ActiveDiagnostic::All) {\n            return;\n        }\n        self.dismiss_diagnostics(cx);\n        let snapshot = self.snapshot(window, cx);\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let Some(renderer) = GlobalDiagnosticRenderer::global(cx) else {\n            return;\n        };\n\n        let diagnostic_group = buffer\n            .diagnostic_group(buffer_id, diagnostic.diagnostic.group_id)\n            .collect::<Vec<_>>();\n\n        let blocks =\n            renderer.render_group(diagnostic_group, buffer_id, snapshot, cx.weak_entity(), cx);\n\n        let blocks = self.display_map.update(cx, |display_map, cx| {\n            display_map.insert_blocks(blocks, cx).into_iter().collect()\n        });\n        self.active_diagnostics = ActiveDiagnostic::Group(ActiveDiagnosticGroup {\n            active_range: buffer.anchor_before(diagnostic.range.start)\n                ..buffer.anchor_after(diagnostic.range.end),\n            active_message: diagnostic.diagnostic.message.clone(),\n            group_id: diagnostic.diagnostic.group_id,\n            blocks,\n        });\n        cx.notify();\n    }\n\n    fn dismiss_diagnostics(&mut self, cx: &mut Context<Self>) {\n        if matches!(self.active_diagnostics, ActiveDiagnostic::All) {\n            return;\n        };\n\n        let prev = mem::replace(&mut self.active_diagnostics, ActiveDiagnostic::None);\n        if let ActiveDiagnostic::Group(group) = prev {\n            self.display_map.update(cx, |display_map, cx| {\n                display_map.remove_blocks(group.blocks, cx);\n            });\n            cx.notify();\n        }\n    }\n\n    /// Disable inline diagnostics rendering for this editor.\n    pub fn disable_inline_diagnostics(&mut self) {\n        self.inline_diagnostics_enabled = false;\n        self.inline_diagnostics_update = Task::ready(());\n        self.inline_diagnostics.clear();\n    }\n\n    pub fn diagnostics_enabled(&self) -> bool {\n        self.mode.is_full()\n    }\n\n    pub fn inline_diagnostics_enabled(&self) -> bool {\n        self.diagnostics_enabled() && self.inline_diagnostics_enabled\n    }\n\n    pub fn show_inline_diagnostics(&self) -> bool {\n        self.show_inline_diagnostics\n    }\n\n    pub fn toggle_inline_diagnostics(\n        &mut self,\n        _: &ToggleInlineDiagnostics,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        self.show_inline_diagnostics = !self.show_inline_diagnostics;\n        self.refresh_inline_diagnostics(false, window, cx);\n    }\n\n    pub fn set_max_diagnostics_severity(&mut self, severity: DiagnosticSeverity, cx: &mut App) {\n        self.diagnostics_max_severity = severity;\n        self.display_map.update(cx, |display_map, _| {\n            display_map.diagnostics_max_severity = self.diagnostics_max_severity;\n        });\n    }\n\n    pub fn toggle_diagnostics(\n        &mut self,\n        _: &ToggleDiagnostics,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        if !self.diagnostics_enabled() {\n            return;\n        }\n\n        let new_severity = if self.diagnostics_max_severity == DiagnosticSeverity::Off {\n            EditorSettings::get_global(cx)\n                .diagnostics_max_severity\n                .filter(|severity| severity != &DiagnosticSeverity::Off)\n                .unwrap_or(DiagnosticSeverity::Hint)\n        } else {\n            DiagnosticSeverity::Off\n        };\n        self.set_max_diagnostics_severity(new_severity, cx);\n        if self.diagnostics_max_severity == DiagnosticSeverity::Off {\n            self.active_diagnostics = ActiveDiagnostic::None;\n            self.inline_diagnostics_update = Task::ready(());\n            self.inline_diagnostics.clear();\n        } else {\n            self.refresh_inline_diagnostics(false, window, cx);\n        }\n\n        cx.notify();\n    }\n\n    pub fn toggle_minimap(\n        &mut self,\n        _: &ToggleMinimap,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        if self.supports_minimap(cx) {\n            self.set_minimap_visibility(self.minimap_visibility.toggle_visibility(), window, cx);\n        }\n    }\n\n    fn refresh_inline_diagnostics(\n        &mut self,\n        debounce: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let max_severity = ProjectSettings::get_global(cx)\n            .diagnostics\n            .inline\n            .max_severity\n            .unwrap_or(self.diagnostics_max_severity);\n\n        if !self.inline_diagnostics_enabled()\n            || !self.show_inline_diagnostics\n            || max_severity == DiagnosticSeverity::Off\n        {\n            self.inline_diagnostics_update = Task::ready(());\n            self.inline_diagnostics.clear();\n            return;\n        }\n\n        let debounce_ms = ProjectSettings::get_global(cx)\n            .diagnostics\n            .inline\n            .update_debounce_ms;\n        let debounce = if debounce && debounce_ms > 0 {\n            Some(Duration::from_millis(debounce_ms))\n        } else {\n            None\n        };\n        self.inline_diagnostics_update = cx.spawn_in(window, async move |editor, cx| {\n            if let Some(debounce) = debounce {\n                cx.background_executor().timer(debounce).await;\n            }\n            let Some(snapshot) = editor.upgrade().and_then(|editor| {\n                editor\n                    .update(cx, |editor, cx| editor.buffer().read(cx).snapshot(cx))\n                    .ok()\n            }) else {\n                return;\n            };\n\n            let new_inline_diagnostics = cx\n                .background_spawn(async move {\n                    let mut inline_diagnostics = Vec::<(Anchor, InlineDiagnostic)>::new();\n                    for diagnostic_entry in snapshot.diagnostics_in_range(0..snapshot.len()) {\n                        let message = diagnostic_entry\n                            .diagnostic\n                            .message\n                            .split_once('\\n')\n                            .map(|(line, _)| line)\n                            .map(SharedString::new)\n                            .unwrap_or_else(|| {\n                                SharedString::from(diagnostic_entry.diagnostic.message)\n                            });\n                        let start_anchor = snapshot.anchor_before(diagnostic_entry.range.start);\n                        let (Ok(i) | Err(i)) = inline_diagnostics\n                            .binary_search_by(|(probe, _)| probe.cmp(&start_anchor, &snapshot));\n                        inline_diagnostics.insert(\n                            i,\n                            (\n                                start_anchor,\n                                InlineDiagnostic {\n                                    message,\n                                    group_id: diagnostic_entry.diagnostic.group_id,\n                                    start: diagnostic_entry.range.start.to_point(&snapshot),\n                                    is_primary: diagnostic_entry.diagnostic.is_primary,\n                                    severity: diagnostic_entry.diagnostic.severity,\n                                },\n                            ),\n                        );\n                    }\n                    inline_diagnostics\n                })\n                .await;\n\n            editor\n                .update(cx, |editor, cx| {\n                    editor.inline_diagnostics = new_inline_diagnostics;\n                    cx.notify();\n                })\n                .ok();\n        });\n    }\n\n    fn pull_diagnostics(\n        &mut self,\n        buffer_id: Option<BufferId>,\n        window: &Window,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        if !self.mode().is_full() {\n            return None;\n        }\n        let pull_diagnostics_settings = ProjectSettings::get_global(cx)\n            .diagnostics\n            .lsp_pull_diagnostics;\n        if !pull_diagnostics_settings.enabled {\n            return None;\n        }\n        let project = self.project.as_ref()?.downgrade();\n        let debounce = Duration::from_millis(pull_diagnostics_settings.debounce_ms);\n        let mut buffers = self.buffer.read(cx).all_buffers();\n        if let Some(buffer_id) = buffer_id {\n            buffers.retain(|buffer| buffer.read(cx).remote_id() == buffer_id);\n        }\n\n        self.pull_diagnostics_task = cx.spawn_in(window, async move |editor, cx| {\n            cx.background_executor().timer(debounce).await;\n\n            let Ok(mut pull_diagnostics_tasks) = cx.update(|_, cx| {\n                buffers\n                    .into_iter()\n                    .flat_map(|buffer| {\n                        Some(project.upgrade()?.pull_diagnostics_for_buffer(buffer, cx))\n                    })\n                    .collect::<FuturesUnordered<_>>()\n            }) else {\n                return;\n            };\n\n            while let Some(pull_task) = pull_diagnostics_tasks.next().await {\n                match pull_task {\n                    Ok(()) => {\n                        if editor\n                            .update_in(cx, |editor, window, cx| {\n                                editor.update_diagnostics_state(window, cx);\n                            })\n                            .is_err()\n                        {\n                            return;\n                        }\n                    }\n                    Err(e) => log::error!(": "",
    "),\n                }\n            }\n        });\n\n        Some(())\n    }\n\n    pub fn set_selections_from_remote(\n        &mut self,\n        selections: Vec<Selection<Anchor>>,\n        pending_selection: Option<Selection<Anchor>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let old_cursor_position = self.selections.newest_anchor().head();\n        self.selections.change_with(cx, |s| {\n            s.select_anchors(selections);\n            if let Some(pending_selection) = pending_selection {\n                s.set_pending(pending_selection, SelectMode::Character);\n            } else {\n                s.clear_pending();\n            }\n        });\n        self.selections_did_change(\n            false,\n            &old_cursor_position,\n            SelectionEffects::default(),\n            window,\n            cx,\n        );\n    }\n\n    pub fn transact(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n        update: impl FnOnce(&mut Self, &mut Window, &mut Context<Self>),\n    ) -> Option<TransactionId> {\n        self.with_selection_effects_deferred(window, cx, |this, window, cx| {\n            this.start_transaction_at(Instant::now(), window, cx);\n            update(this, window, cx);\n            this.end_transaction_at(Instant::now(), cx)\n        })\n    }\n\n    pub fn start_transaction_at(\n        &mut self,\n        now: Instant,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.end_selection(window, cx);\n        if let Some(tx_id) = self\n            .buffer\n            .update(cx, |buffer, cx| buffer.start_transaction_at(now, cx))\n        {\n            self.selection_history\n                .insert_transaction(tx_id, self.selections.disjoint_anchors());\n            cx.emit(EditorEvent::TransactionBegun {\n                transaction_id: tx_id,\n            })\n        }\n    }\n\n    pub fn end_transaction_at(\n        &mut self,\n        now: Instant,\n        cx: &mut Context<Self>,\n    ) -> Option<TransactionId> {\n        if let Some(transaction_id) = self\n            .buffer\n            .update(cx, |buffer, cx| buffer.end_transaction_at(now, cx))\n        {\n            if let Some((_, end_selections)) =\n                self.selection_history.transaction_mut(transaction_id)\n            {\n                *end_selections = Some(self.selections.disjoint_anchors());\n            } else {\n                log::error!(": "",
    ");\n            }\n\n            cx.emit(EditorEvent::Edited { transaction_id });\n            Some(transaction_id)\n        } else {\n            None\n        }\n    }\n\n    pub fn set_mark(&mut self, _: &actions::SetMark, window: &mut Window, cx: &mut Context<Self>) {\n        if self.selection_mark_mode {\n            self.change_selections(None, window, cx, |s| {\n                s.move_with(|_, sel| {\n                    sel.collapse_to(sel.head(), SelectionGoal::None);\n                });\n            })\n        }\n        self.selection_mark_mode = true;\n        cx.notify();\n    }\n\n    pub fn swap_selection_ends(\n        &mut self,\n        _: &actions::SwapSelectionEnds,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(None, window, cx, |s| {\n            s.move_with(|_, sel| {\n                if sel.start != sel.end {\n                    sel.reversed = !sel.reversed\n                }\n            });\n        });\n        self.request_autoscroll(Autoscroll::newest(), cx);\n        cx.notify();\n    }\n\n    pub fn toggle_fold(\n        &mut self,\n        _: &actions::ToggleFold,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.is_singleton(cx) {\n            let selection = self.selections.newest::<Point>(cx);\n\n            let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n            let range = if selection.is_empty() {\n                let point = selection.head().to_display_point(&display_map);\n                let start = DisplayPoint::new(point.row(), 0).to_point(&display_map);\n                let end = DisplayPoint::new(point.row(), display_map.line_len(point.row()))\n                    .to_point(&display_map);\n                start..end\n            } else {\n                selection.range()\n            };\n            if display_map.folds_in_range(range).next().is_some() {\n                self.unfold_lines(&Default::default(), window, cx)\n            } else {\n                self.fold(&Default::default(), window, cx)\n            }\n        } else {\n            let multi_buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n            let buffer_ids: HashSet<_> = self\n                .selections\n                .disjoint_anchor_ranges()\n                .flat_map(|range| multi_buffer_snapshot.buffer_ids_for_range(range))\n                .collect();\n\n            let should_unfold = buffer_ids\n                .iter()\n                .any(|buffer_id| self.is_buffer_folded(*buffer_id, cx));\n\n            for buffer_id in buffer_ids {\n                if should_unfold {\n                    self.unfold_buffer(buffer_id, cx);\n                } else {\n                    self.fold_buffer(buffer_id, cx);\n                }\n            }\n        }\n    }\n\n    pub fn toggle_fold_recursive(\n        &mut self,\n        _: &actions::ToggleFoldRecursive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let selection = self.selections.newest::<Point>(cx);\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let range = if selection.is_empty() {\n            let point = selection.head().to_display_point(&display_map);\n            let start = DisplayPoint::new(point.row(), 0).to_point(&display_map);\n            let end = DisplayPoint::new(point.row(), display_map.line_len(point.row()))\n                .to_point(&display_map);\n            start..end\n        } else {\n            selection.range()\n        };\n        if display_map.folds_in_range(range).next().is_some() {\n            self.unfold_recursive(&Default::default(), window, cx)\n        } else {\n            self.fold_recursive(&Default::default(), window, cx)\n        }\n    }\n\n    pub fn fold(&mut self, _: &actions::Fold, window: &mut Window, cx: &mut Context<Self>) {\n        if self.is_singleton(cx) {\n            let mut to_fold = Vec::new();\n            let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n            let selections = self.selections.all_adjusted(cx);\n\n            for selection in selections {\n                let range = selection.range().sorted();\n                let buffer_start_row = range.start.row;\n\n                if range.start.row != range.end.row {\n                    let mut found = false;\n                    let mut row = range.start.row;\n                    while row <= range.end.row {\n                        if let Some(crease) = display_map.crease_for_buffer_row(MultiBufferRow(row))\n                        {\n                            found = true;\n                            row = crease.range().end.row + 1;\n                            to_fold.push(crease);\n                        } else {\n                            row += 1\n                        }\n                    }\n                    if found {\n                        continue;\n                    }\n                }\n\n                for row in (0..=range.start.row).rev() {\n                    if let Some(crease) = display_map.crease_for_buffer_row(MultiBufferRow(row)) {\n                        if crease.range().end.row >= buffer_start_row {\n                            to_fold.push(crease);\n                            if row <= range.start.row {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            self.fold_creases(to_fold, true, window, cx);\n        } else {\n            let multi_buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n            let buffer_ids = self\n                .selections\n                .disjoint_anchor_ranges()\n                .flat_map(|range| multi_buffer_snapshot.buffer_ids_for_range(range))\n                .collect::<HashSet<_>>();\n            for buffer_id in buffer_ids {\n                self.fold_buffer(buffer_id, cx);\n            }\n        }\n    }\n\n    fn fold_at_level(\n        &mut self,\n        fold_at: &FoldAtLevel,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.buffer.read(cx).is_singleton() {\n            return;\n        }\n\n        let fold_at_level = fold_at.0;\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let mut to_fold = Vec::new();\n        let mut stack = vec![(0, snapshot.max_row().0, 1)];\n\n        while let Some((mut start_row, end_row, current_level)) = stack.pop() {\n            while start_row < end_row {\n                match self\n                    .snapshot(window, cx)\n                    .crease_for_buffer_row(MultiBufferRow(start_row))\n                {\n                    Some(crease) => {\n                        let nested_start_row = crease.range().start.row + 1;\n                        let nested_end_row = crease.range().end.row;\n\n                        if current_level < fold_at_level {\n                            stack.push((nested_start_row, nested_end_row, current_level + 1));\n                        } else if current_level == fold_at_level {\n                            to_fold.push(crease);\n                        }\n\n                        start_row = nested_end_row + 1;\n                    }\n                    None => start_row += 1,\n                }\n            }\n        }\n\n        self.fold_creases(to_fold, true, window, cx);\n    }\n\n    pub fn fold_all(&mut self, _: &actions::FoldAll, window: &mut Window, cx: &mut Context<Self>) {\n        if self.buffer.read(cx).is_singleton() {\n            let mut fold_ranges = Vec::new();\n            let snapshot = self.buffer.read(cx).snapshot(cx);\n\n            for row in 0..snapshot.max_row().0 {\n                if let Some(foldable_range) = self\n                    .snapshot(window, cx)\n                    .crease_for_buffer_row(MultiBufferRow(row))\n                {\n                    fold_ranges.push(foldable_range);\n                }\n            }\n\n            self.fold_creases(fold_ranges, true, window, cx);\n        } else {\n            self.toggle_fold_multiple_buffers = cx.spawn_in(window, async move |editor, cx| {\n                editor\n                    .update_in(cx, |editor, _, cx| {\n                        for buffer_id in editor.buffer.read(cx).excerpt_buffer_ids() {\n                            editor.fold_buffer(buffer_id, cx);\n                        }\n                    })\n                    .ok();\n            });\n        }\n    }\n\n    pub fn fold_function_bodies(\n        &mut self,\n        _: &actions::FoldFunctionBodies,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n\n        let ranges = snapshot\n            .text_object_ranges(0..snapshot.len(), TreeSitterOptions::default())\n            .filter_map(|(range, obj)| (obj == TextObject::InsideFunction).then_some(range))\n            .collect::<Vec<_>>();\n\n        let creases = ranges\n            .into_iter()\n            .map(|range| Crease::simple(range, self.display_map.read(cx).fold_placeholder.clone()))\n            .collect();\n\n        self.fold_creases(creases, true, window, cx);\n    }\n\n    pub fn fold_recursive(\n        &mut self,\n        _: &actions::FoldRecursive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let mut to_fold = Vec::new();\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let selections = self.selections.all_adjusted(cx);\n\n        for selection in selections {\n            let range = selection.range().sorted();\n            let buffer_start_row = range.start.row;\n\n            if range.start.row != range.end.row {\n                let mut found = false;\n                for row in range.start.row..=range.end.row {\n                    if let Some(crease) = display_map.crease_for_buffer_row(MultiBufferRow(row)) {\n                        found = true;\n                        to_fold.push(crease);\n                    }\n                }\n                if found {\n                    continue;\n                }\n            }\n\n            for row in (0..=range.start.row).rev() {\n                if let Some(crease) = display_map.crease_for_buffer_row(MultiBufferRow(row)) {\n                    if crease.range().end.row >= buffer_start_row {\n                        to_fold.push(crease);\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        self.fold_creases(to_fold, true, window, cx);\n    }\n\n    pub fn fold_at(\n        &mut self,\n        buffer_row: MultiBufferRow,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        if let Some(crease) = display_map.crease_for_buffer_row(buffer_row) {\n            let autoscroll = self\n                .selections\n                .all::<Point>(cx)\n                .iter()\n                .any(|selection| crease.range().overlaps(&selection.range()));\n\n            self.fold_creases(vec![crease], autoscroll, window, cx);\n        }\n    }\n\n    pub fn unfold_lines(&mut self, _: &UnfoldLines, _window: &mut Window, cx: &mut Context<Self>) {\n        if self.is_singleton(cx) {\n            let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n            let buffer = &display_map.buffer_snapshot;\n            let selections = self.selections.all::<Point>(cx);\n            let ranges = selections\n                .iter()\n                .map(|s| {\n                    let range = s.display_range(&display_map).sorted();\n                    let mut start = range.start.to_point(&display_map);\n                    let mut end = range.end.to_point(&display_map);\n                    start.column = 0;\n                    end.column = buffer.line_len(MultiBufferRow(end.row));\n                    start..end\n                })\n                .collect::<Vec<_>>();\n\n            self.unfold_ranges(&ranges, true, true, cx);\n        } else {\n            let multi_buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n            let buffer_ids = self\n                .selections\n                .disjoint_anchor_ranges()\n                .flat_map(|range| multi_buffer_snapshot.buffer_ids_for_range(range))\n                .collect::<HashSet<_>>();\n            for buffer_id in buffer_ids {\n                self.unfold_buffer(buffer_id, cx);\n            }\n        }\n    }\n\n    pub fn unfold_recursive(\n        &mut self,\n        _: &UnfoldRecursive,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let selections = self.selections.all::<Point>(cx);\n        let ranges = selections\n            .iter()\n            .map(|s| {\n                let mut range = s.display_range(&display_map).sorted();\n                *range.start.column_mut() = 0;\n                *range.end.column_mut() = display_map.line_len(range.end.row());\n                let start = range.start.to_point(&display_map);\n                let end = range.end.to_point(&display_map);\n                start..end\n            })\n            .collect::<Vec<_>>();\n\n        self.unfold_ranges(&ranges, true, true, cx);\n    }\n\n    pub fn unfold_at(\n        &mut self,\n        buffer_row: MultiBufferRow,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        let intersection_range = Point::new(buffer_row.0, 0)\n            ..Point::new(\n                buffer_row.0,\n                display_map.buffer_snapshot.line_len(buffer_row),\n            );\n\n        let autoscroll = self\n            .selections\n            .all::<Point>(cx)\n            .iter()\n            .any(|selection| RangeExt::overlaps(&selection.range(), &intersection_range));\n\n        self.unfold_ranges(&[intersection_range], true, autoscroll, cx);\n    }\n\n    pub fn unfold_all(\n        &mut self,\n        _: &actions::UnfoldAll,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.buffer.read(cx).is_singleton() {\n            let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n            self.unfold_ranges(&[0..display_map.buffer_snapshot.len()], true, true, cx);\n        } else {\n            self.toggle_fold_multiple_buffers = cx.spawn(async move |editor, cx| {\n                editor\n                    .update(cx, |editor, cx| {\n                        for buffer_id in editor.buffer.read(cx).excerpt_buffer_ids() {\n                            editor.unfold_buffer(buffer_id, cx);\n                        }\n                    })\n                    .ok();\n            });\n        }\n    }\n\n    pub fn fold_selected_ranges(\n        &mut self,\n        _: &FoldSelectedRanges,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let selections = self.selections.all_adjusted(cx);\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let ranges = selections\n            .into_iter()\n            .map(|s| Crease::simple(s.range(), display_map.fold_placeholder.clone()))\n            .collect::<Vec<_>>();\n        self.fold_creases(ranges, true, window, cx);\n    }\n\n    pub fn fold_ranges<T: ToOffset + Clone>(\n        &mut self,\n        ranges: Vec<Range<T>>,\n        auto_scroll: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let ranges = ranges\n            .into_iter()\n            .map(|r| Crease::simple(r, display_map.fold_placeholder.clone()))\n            .collect::<Vec<_>>();\n        self.fold_creases(ranges, auto_scroll, window, cx);\n    }\n\n    pub fn fold_creases<T: ToOffset + Clone>(\n        &mut self,\n        creases: Vec<Crease<T>>,\n        auto_scroll: bool,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if creases.is_empty() {\n            return;\n        }\n\n        let mut buffers_affected = HashSet::default();\n        let multi_buffer = self.buffer().read(cx);\n        for crease in &creases {\n            if let Some((_, buffer, _)) =\n                multi_buffer.excerpt_containing(crease.range().start.clone(), cx)\n            {\n                buffers_affected.insert(buffer.read(cx).remote_id());\n            };\n        }\n\n        self.display_map.update(cx, |map, cx| map.fold(creases, cx));\n\n        if auto_scroll {\n            self.request_autoscroll(Autoscroll::fit(), cx);\n        }\n\n        cx.notify();\n\n        self.scrollbar_marker_state.dirty = true;\n        self.folds_did_change(cx);\n    }\n\n    /// Removes any folds whose ranges intersect any of the given ranges.\n    pub fn unfold_ranges<T: ToOffset + Clone>(\n        &mut self,\n        ranges: &[Range<T>],\n        inclusive: bool,\n        auto_scroll: bool,\n        cx: &mut Context<Self>,\n    ) {\n        self.remove_folds_with(ranges, auto_scroll, cx, |map, cx| {\n            map.unfold_intersecting(ranges.iter().cloned(), inclusive, cx)\n        });\n        self.folds_did_change(cx);\n    }\n\n    pub fn fold_buffer(&mut self, buffer_id: BufferId, cx: &mut Context<Self>) {\n        if self.buffer().read(cx).is_singleton() || self.is_buffer_folded(buffer_id, cx) {\n            return;\n        }\n        let folded_excerpts = self.buffer().read(cx).excerpts_for_buffer(buffer_id, cx);\n        self.display_map.update(cx, |display_map, cx| {\n            display_map.fold_buffers([buffer_id], cx)\n        });\n        cx.emit(EditorEvent::BufferFoldToggled {\n            ids: folded_excerpts.iter().map(|&(id, _)| id).collect(),\n            folded: true,\n        });\n        cx.notify();\n    }\n\n    pub fn unfold_buffer(&mut self, buffer_id: BufferId, cx: &mut Context<Self>) {\n        if self.buffer().read(cx).is_singleton() || !self.is_buffer_folded(buffer_id, cx) {\n            return;\n        }\n        let unfolded_excerpts = self.buffer().read(cx).excerpts_for_buffer(buffer_id, cx);\n        self.display_map.update(cx, |display_map, cx| {\n            display_map.unfold_buffers([buffer_id], cx);\n        });\n        cx.emit(EditorEvent::BufferFoldToggled {\n            ids: unfolded_excerpts.iter().map(|&(id, _)| id).collect(),\n            folded: false,\n        });\n        cx.notify();\n    }\n\n    pub fn is_buffer_folded(&self, buffer: BufferId, cx: &App) -> bool {\n        self.display_map.read(cx).is_buffer_folded(buffer)\n    }\n\n    pub fn folded_buffers<'a>(&self, cx: &'a App) -> &'a HashSet<BufferId> {\n        self.display_map.read(cx).folded_buffers()\n    }\n\n    pub fn disable_header_for_buffer(&mut self, buffer_id: BufferId, cx: &mut Context<Self>) {\n        self.display_map.update(cx, |display_map, cx| {\n            display_map.disable_header_for_buffer(buffer_id, cx);\n        });\n        cx.notify();\n    }\n\n    /// Removes any folds with the given ranges.\n    pub fn remove_folds_with_type<T: ToOffset + Clone>(\n        &mut self,\n        ranges: &[Range<T>],\n        type_id: TypeId,\n        auto_scroll: bool,\n        cx: &mut Context<Self>,\n    ) {\n        self.remove_folds_with(ranges, auto_scroll, cx, |map, cx| {\n            map.remove_folds_with_type(ranges.iter().cloned(), type_id, cx)\n        });\n        self.folds_did_change(cx);\n    }\n\n    fn remove_folds_with<T: ToOffset + Clone>(\n        &mut self,\n        ranges: &[Range<T>],\n        auto_scroll: bool,\n        cx: &mut Context<Self>,\n        update: impl FnOnce(&mut DisplayMap, &mut Context<DisplayMap>),\n    ) {\n        if ranges.is_empty() {\n            return;\n        }\n\n        let mut buffers_affected = HashSet::default();\n        let multi_buffer = self.buffer().read(cx);\n        for range in ranges {\n            if let Some((_, buffer, _)) = multi_buffer.excerpt_containing(range.start.clone(), cx) {\n                buffers_affected.insert(buffer.read(cx).remote_id());\n            };\n        }\n\n        self.display_map.update(cx, update);\n\n        if auto_scroll {\n            self.request_autoscroll(Autoscroll::fit(), cx);\n        }\n\n        cx.notify();\n        self.scrollbar_marker_state.dirty = true;\n        self.active_indent_guides_state.dirty = true;\n    }\n\n    pub fn update_fold_widths(\n        &mut self,\n        widths: impl IntoIterator<Item = (FoldId, Pixels)>,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        self.display_map\n            .update(cx, |map, cx| map.update_fold_widths(widths, cx))\n    }\n\n    pub fn default_fold_placeholder(&self, cx: &App) -> FoldPlaceholder {\n        self.display_map.read(cx).fold_placeholder.clone()\n    }\n\n    pub fn set_expand_all_diff_hunks(&mut self, cx: &mut App) {\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.set_all_diff_hunks_expanded(cx);\n        });\n    }\n\n    pub fn expand_all_diff_hunks(\n        &mut self,\n        _: &ExpandAllDiffHunks,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.expand_diff_hunks(vec![Anchor::min()..Anchor::max()], cx)\n        });\n    }\n\n    pub fn toggle_selected_diff_hunks(\n        &mut self,\n        _: &ToggleSelectedDiffHunks,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let ranges: Vec<_> = self.selections.disjoint.iter().map(|s| s.range()).collect();\n        self.toggle_diff_hunks_in_ranges(ranges, cx);\n    }\n\n    pub fn diff_hunks_in_ranges<'a>(\n        &'a self,\n        ranges: &'a [Range<Anchor>],\n        buffer: &'a MultiBufferSnapshot,\n    ) -> impl 'a + Iterator<Item = MultiBufferDiffHunk> {\n        ranges.iter().flat_map(move |range| {\n            let end_excerpt_id = range.end.excerpt_id;\n            let range = range.to_point(buffer);\n            let mut peek_end = range.end;\n            if range.end.row < buffer.max_row().0 {\n                peek_end = Point::new(range.end.row + 1, 0);\n            }\n            buffer\n                .diff_hunks_in_range(range.start..peek_end)\n                .filter(move |hunk| hunk.excerpt_id.cmp(&end_excerpt_id, buffer).is_le())\n        })\n    }\n\n    pub fn has_stageable_diff_hunks_in_ranges(\n        &self,\n        ranges: &[Range<Anchor>],\n        snapshot: &MultiBufferSnapshot,\n    ) -> bool {\n        let mut hunks = self.diff_hunks_in_ranges(ranges, &snapshot);\n        hunks.any(|hunk| hunk.status().has_secondary_hunk())\n    }\n\n    pub fn toggle_staged_selected_diff_hunks(\n        &mut self,\n        _: &::git::ToggleStaged,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let ranges: Vec<_> = self.selections.disjoint.iter().map(|s| s.range()).collect();\n        let stage = self.has_stageable_diff_hunks_in_ranges(&ranges, &snapshot);\n        self.stage_or_unstage_diff_hunks(stage, ranges, cx);\n    }\n\n    pub fn set_render_diff_hunk_controls(\n        &mut self,\n        render_diff_hunk_controls: RenderDiffHunkControlsFn,\n        cx: &mut Context<Self>,\n    ) {\n        self.render_diff_hunk_controls = render_diff_hunk_controls;\n        cx.notify();\n    }\n\n    pub fn stage_and_next(\n        &mut self,\n        _: &::git::StageAndNext,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.do_stage_or_unstage_and_next(true, window, cx);\n    }\n\n    pub fn unstage_and_next(\n        &mut self,\n        _: &::git::UnstageAndNext,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.do_stage_or_unstage_and_next(false, window, cx);\n    }\n\n    pub fn stage_or_unstage_diff_hunks(\n        &mut self,\n        stage: bool,\n        ranges: Vec<Range<Anchor>>,\n        cx: &mut Context<Self>,\n    ) {\n        let task = self.save_buffers_for_ranges_if_needed(&ranges, cx);\n        cx.spawn(async move |this, cx| {\n            task.await?;\n            this.update(cx, |this, cx| {\n                let snapshot = this.buffer.read(cx).snapshot(cx);\n                let chunk_by = this\n                    .diff_hunks_in_ranges(&ranges, &snapshot)\n                    .chunk_by(|hunk| hunk.buffer_id);\n                for (buffer_id, hunks) in &chunk_by {\n                    this.do_stage_or_unstage(stage, buffer_id, hunks, cx);\n                }\n            })\n        })\n        .detach_and_log_err(cx);\n    }\n\n    fn save_buffers_for_ranges_if_needed(\n        &mut self,\n        ranges: &[Range<Anchor>],\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<()>> {\n        let multibuffer = self.buffer.read(cx);\n        let snapshot = multibuffer.read(cx);\n        let buffer_ids: HashSet<_> = ranges\n            .iter()\n            .flat_map(|range| snapshot.buffer_ids_for_range(range.clone()))\n            .collect();\n        drop(snapshot);\n\n        let mut buffers = HashSet::default();\n        for buffer_id in buffer_ids {\n            if let Some(buffer_entity) = multibuffer.buffer(buffer_id) {\n                let buffer = buffer_entity.read(cx);\n                if buffer.file().is_some_and(|file| file.disk_state().exists()) && buffer.is_dirty()\n                {\n                    buffers.insert(buffer_entity);\n                }\n            }\n        }\n\n        if let Some(project) = &self.project {\n            project.update(cx, |project, cx| project.save_buffers(buffers, cx))\n        } else {\n            Task::ready(Ok(()))\n        }\n    }\n\n    fn do_stage_or_unstage_and_next(\n        &mut self,\n        stage: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let ranges = self.selections.disjoint_anchor_ranges().collect::<Vec<_>>();\n\n        if ranges.iter().any(|range| range.start != range.end) {\n            self.stage_or_unstage_diff_hunks(stage, ranges, cx);\n            return;\n        }\n\n        self.stage_or_unstage_diff_hunks(stage, ranges, cx);\n        let snapshot = self.snapshot(window, cx);\n        let position = self.selections.newest::<Point>(cx).head();\n        let mut row = snapshot\n            .buffer_snapshot\n            .diff_hunks_in_range(position..snapshot.buffer_snapshot.max_point())\n            .find(|hunk| hunk.row_range.start.0 > position.row)\n            .map(|hunk| hunk.row_range.start);\n\n        let all_diff_hunks_expanded = self.buffer().read(cx).all_diff_hunks_expanded();\n        // Outside of the project diff editor, wrap around to the beginning.\n        if !all_diff_hunks_expanded {\n            row = row.or_else(|| {\n                snapshot\n                    .buffer_snapshot\n                    .diff_hunks_in_range(Point::zero()..position)\n                    .find(|hunk| hunk.row_range.end.0 < position.row)\n                    .map(|hunk| hunk.row_range.start)\n            });\n        }\n\n        if let Some(row) = row {\n            let destination = Point::new(row.0, 0);\n            let autoscroll = Autoscroll::center();\n\n            self.unfold_ranges(&[destination..destination], false, false, cx);\n            self.change_selections(Some(autoscroll), window, cx, |s| {\n                s.select_ranges([destination..destination]);\n            });\n        }\n    }\n\n    fn do_stage_or_unstage(\n        &self,\n        stage: bool,\n        buffer_id: BufferId,\n        hunks: impl Iterator<Item = MultiBufferDiffHunk>,\n        cx: &mut App,\n    ) -> Option<()> {\n        let project = self.project.as_ref()?;\n        let buffer = project.read(cx).buffer_for_id(buffer_id, cx)?;\n        let diff = self.buffer.read(cx).diff_for(buffer_id)?;\n        let buffer_snapshot = buffer.read(cx).snapshot();\n        let file_exists = buffer_snapshot\n            .file()\n            .is_some_and(|file| file.disk_state().exists());\n        diff.update(cx, |diff, cx| {\n            diff.stage_or_unstage_hunks(\n                stage,\n                &hunks\n                    .map(|hunk| buffer_diff::DiffHunk {\n                        buffer_range: hunk.buffer_range,\n                        diff_base_byte_range: hunk.diff_base_byte_range,\n                        secondary_status: hunk.secondary_status,\n                        range: Point::zero()..Point::zero(), // unused\n                    })\n                    .collect::<Vec<_>>(),\n                &buffer_snapshot,\n                file_exists,\n                cx,\n            )\n        });\n        None\n    }\n\n    pub fn expand_selected_diff_hunks(&mut self, cx: &mut Context<Self>) {\n        let ranges: Vec<_> = self.selections.disjoint.iter().map(|s| s.range()).collect();\n        self.buffer\n            .update(cx, |buffer, cx| buffer.expand_diff_hunks(ranges, cx))\n    }\n\n    pub fn clear_expanded_diff_hunks(&mut self, cx: &mut Context<Self>) -> bool {\n        self.buffer.update(cx, |buffer, cx| {\n            let ranges = vec![Anchor::min()..Anchor::max()];\n            if !buffer.all_diff_hunks_expanded()\n                && buffer.has_expanded_diff_hunks_in_ranges(&ranges, cx)\n            {\n                buffer.collapse_diff_hunks(ranges, cx);\n                true\n            } else {\n                false\n            }\n        })\n    }\n\n    fn toggle_diff_hunks_in_ranges(\n        &mut self,\n        ranges: Vec<Range<Anchor>>,\n        cx: &mut Context<Editor>,\n    ) {\n        self.buffer.update(cx, |buffer, cx| {\n            let expand = !buffer.has_expanded_diff_hunks_in_ranges(&ranges, cx);\n            buffer.expand_or_collapse_diff_hunks(ranges, expand, cx);\n        })\n    }\n\n    fn toggle_single_diff_hunk(&mut self, range: Range<Anchor>, cx: &mut Context<Self>) {\n        self.buffer.update(cx, |buffer, cx| {\n            let snapshot = buffer.snapshot(cx);\n            let excerpt_id = range.end.excerpt_id;\n            let point_range = range.to_point(&snapshot);\n            let expand = !buffer.single_hunk_is_expanded(range, cx);\n            buffer.expand_or_collapse_diff_hunks_inner([(point_range, excerpt_id)], expand, cx);\n        })\n    }\n\n    pub(crate) fn apply_all_diff_hunks(\n        &mut self,\n        _: &ApplyAllDiffHunks,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n\n        let buffers = self.buffer.read(cx).all_buffers();\n        for branch_buffer in buffers {\n            branch_buffer.update(cx, |branch_buffer, cx| {\n                branch_buffer.merge_into_base(Vec::new(), cx);\n            });\n        }\n\n        if let Some(project) = self.project.clone() {\n            self.save(\n                SaveOptions {\n                    format: true,\n                    autosave: false,\n                },\n                project,\n                window,\n                cx,\n            )\n            .detach_and_log_err(cx);\n        }\n    }\n\n    pub(crate) fn apply_selected_diff_hunks(\n        &mut self,\n        _: &ApplyDiffHunk,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n        let snapshot = self.snapshot(window, cx);\n        let hunks = snapshot.hunks_for_ranges(self.selections.ranges(cx));\n        let mut ranges_by_buffer = HashMap::default();\n        self.transact(window, cx, |editor, _window, cx| {\n            for hunk in hunks {\n                if let Some(buffer) = editor.buffer.read(cx).buffer(hunk.buffer_id) {\n                    ranges_by_buffer\n                        .entry(buffer.clone())\n                        .or_insert_with(Vec::new)\n                        .push(hunk.buffer_range.to_offset(buffer.read(cx)));\n                }\n            }\n\n            for (buffer, ranges) in ranges_by_buffer {\n                buffer.update(cx, |buffer, cx| {\n                    buffer.merge_into_base(ranges, cx);\n                });\n            }\n        });\n\n        if let Some(project) = self.project.clone() {\n            self.save(\n                SaveOptions {\n                    format: true,\n                    autosave: false,\n                },\n                project,\n                window,\n                cx,\n            )\n            .detach_and_log_err(cx);\n        }\n    }\n\n    pub fn set_gutter_hovered(&mut self, hovered: bool, cx: &mut Context<Self>) {\n        if hovered != self.gutter_hovered {\n            self.gutter_hovered = hovered;\n            cx.notify();\n        }\n    }\n\n    pub fn insert_blocks(\n        &mut self,\n        blocks: impl IntoIterator<Item = BlockProperties<Anchor>>,\n        autoscroll: Option<Autoscroll>,\n        cx: &mut Context<Self>,\n    ) -> Vec<CustomBlockId> {\n        let blocks = self\n            .display_map\n            .update(cx, |display_map, cx| display_map.insert_blocks(blocks, cx));\n        if let Some(autoscroll) = autoscroll {\n            self.request_autoscroll(autoscroll, cx);\n        }\n        cx.notify();\n        blocks\n    }\n\n    pub fn resize_blocks(\n        &mut self,\n        heights: HashMap<CustomBlockId, u32>,\n        autoscroll: Option<Autoscroll>,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map\n            .update(cx, |display_map, cx| display_map.resize_blocks(heights, cx));\n        if let Some(autoscroll) = autoscroll {\n            self.request_autoscroll(autoscroll, cx);\n        }\n        cx.notify();\n    }\n\n    pub fn replace_blocks(\n        &mut self,\n        renderers: HashMap<CustomBlockId, RenderBlock>,\n        autoscroll: Option<Autoscroll>,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map\n            .update(cx, |display_map, _cx| display_map.replace_blocks(renderers));\n        if let Some(autoscroll) = autoscroll {\n            self.request_autoscroll(autoscroll, cx);\n        }\n        cx.notify();\n    }\n\n    pub fn remove_blocks(\n        &mut self,\n        block_ids: HashSet<CustomBlockId>,\n        autoscroll: Option<Autoscroll>,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map.update(cx, |display_map, cx| {\n            display_map.remove_blocks(block_ids, cx)\n        });\n        if let Some(autoscroll) = autoscroll {\n            self.request_autoscroll(autoscroll, cx);\n        }\n        cx.notify();\n    }\n\n    pub fn row_for_block(\n        &self,\n        block_id: CustomBlockId,\n        cx: &mut Context<Self>,\n    ) -> Option<DisplayRow> {\n        self.display_map\n            .update(cx, |map, cx| map.row_for_block(block_id, cx))\n    }\n\n    pub(crate) fn set_focused_block(&mut self, focused_block: FocusedBlock) {\n        self.focused_block = Some(focused_block);\n    }\n\n    pub(crate) fn take_focused_block(&mut self) -> Option<FocusedBlock> {\n        self.focused_block.take()\n    }\n\n    pub fn insert_creases(\n        &mut self,\n        creases: impl IntoIterator<Item = Crease<Anchor>>,\n        cx: &mut Context<Self>,\n    ) -> Vec<CreaseId> {\n        self.display_map\n            .update(cx, |map, cx| map.insert_creases(creases, cx))\n    }\n\n    pub fn remove_creases(\n        &mut self,\n        ids: impl IntoIterator<Item = CreaseId>,\n        cx: &mut Context<Self>,\n    ) -> Vec<(CreaseId, Range<Anchor>)> {\n        self.display_map\n            .update(cx, |map, cx| map.remove_creases(ids, cx))\n    }\n\n    pub fn longest_row(&self, cx: &mut App) -> DisplayRow {\n        self.display_map\n            .update(cx, |map, cx| map.snapshot(cx))\n            .longest_row()\n    }\n\n    pub fn max_point(&self, cx: &mut App) -> DisplayPoint {\n        self.display_map\n            .update(cx, |map, cx| map.snapshot(cx))\n            .max_point()\n    }\n\n    pub fn text(&self, cx: &App) -> String {\n        self.buffer.read(cx).read(cx).text()\n    }\n\n    pub fn is_empty(&self, cx: &App) -> bool {\n        self.buffer.read(cx).read(cx).is_empty()\n    }\n\n    pub fn text_option(&self, cx: &App) -> Option<String> {\n        let text = self.text(cx);\n        let text = text.trim();\n\n        if text.is_empty() {\n            return None;\n        }\n\n        Some(text.to_string())\n    }\n\n    pub fn set_text(\n        &mut self,\n        text: impl Into<Arc<str>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.transact(window, cx, |this, _, cx| {\n            this.buffer\n                .read(cx)\n                .as_singleton()\n                .expect(": "",
    ")\n                .update(cx, |buffer, cx| buffer.set_text(text, cx));\n        });\n    }\n\n    pub fn display_text(&self, cx: &mut App) -> String {\n        self.display_map\n            .update(cx, |map, cx| map.snapshot(cx))\n            .text()\n    }\n\n    fn create_minimap(\n        &self,\n        minimap_settings: MinimapSettings,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Entity<Self>> {\n        (minimap_settings.minimap_enabled() && self.is_singleton(cx))\n            .then(|| self.initialize_new_minimap(minimap_settings, window, cx))\n    }\n\n    fn initialize_new_minimap(\n        &self,\n        minimap_settings: MinimapSettings,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Entity<Self> {\n        const MINIMAP_FONT_WEIGHT: gpui::FontWeight = gpui::FontWeight::BLACK;\n\n        let mut minimap = Editor::new_internal(\n            EditorMode::Minimap {\n                parent: cx.weak_entity(),\n            },\n            self.buffer.clone(),\n            self.project.clone(),\n            Some(self.display_map.clone()),\n            window,\n            cx,\n        );\n        minimap.scroll_manager.clone_state(&self.scroll_manager);\n        minimap.set_text_style_refinement(TextStyleRefinement {\n            font_size: Some(MINIMAP_FONT_SIZE),\n            font_weight: Some(MINIMAP_FONT_WEIGHT),\n            ..Default::default()\n        });\n        minimap.update_minimap_configuration(minimap_settings, cx);\n        cx.new(|_| minimap)\n    }\n\n    fn update_minimap_configuration(&mut self, minimap_settings: MinimapSettings, cx: &App) {\n        let current_line_highlight = minimap_settings\n            .current_line_highlight\n            .unwrap_or_else(|| EditorSettings::get_global(cx).current_line_highlight);\n        self.set_current_line_highlight(Some(current_line_highlight));\n    }\n\n    pub fn minimap(&self) -> Option<&Entity<Self>> {\n        self.minimap\n            .as_ref()\n            .filter(|_| self.minimap_visibility.visible())\n    }\n\n    pub fn wrap_guides(&self, cx: &App) -> SmallVec<[(usize, bool); 2]> {\n        let mut wrap_guides = smallvec![];\n\n        if self.show_wrap_guides == Some(false) {\n            return wrap_guides;\n        }\n\n        let settings = self.buffer.read(cx).language_settings(cx);\n        if settings.show_wrap_guides {\n            match self.soft_wrap_mode(cx) {\n                SoftWrap::Column(soft_wrap) => {\n                    wrap_guides.push((soft_wrap as usize, true));\n                }\n                SoftWrap::Bounded(soft_wrap) => {\n                    wrap_guides.push((soft_wrap as usize, true));\n                }\n                SoftWrap::GitDiff | SoftWrap::None | SoftWrap::EditorWidth => {}\n            }\n            wrap_guides.extend(settings.wrap_guides.iter().map(|guide| (*guide, false)))\n        }\n\n        wrap_guides\n    }\n\n    pub fn soft_wrap_mode(&self, cx: &App) -> SoftWrap {\n        let settings = self.buffer.read(cx).language_settings(cx);\n        let mode = self.soft_wrap_mode_override.unwrap_or(settings.soft_wrap);\n        match mode {\n            language_settings::SoftWrap::PreferLine | language_settings::SoftWrap::None => {\n                SoftWrap::None\n            }\n            language_settings::SoftWrap::EditorWidth => SoftWrap::EditorWidth,\n            language_settings::SoftWrap::PreferredLineLength => {\n                SoftWrap::Column(settings.preferred_line_length)\n            }\n            language_settings::SoftWrap::Bounded => {\n                SoftWrap::Bounded(settings.preferred_line_length)\n            }\n        }\n    }\n\n    pub fn set_soft_wrap_mode(\n        &mut self,\n        mode: language_settings::SoftWrap,\n\n        cx: &mut Context<Self>,\n    ) {\n        self.soft_wrap_mode_override = Some(mode);\n        cx.notify();\n    }\n\n    pub fn set_hard_wrap(&mut self, hard_wrap: Option<usize>, cx: &mut Context<Self>) {\n        self.hard_wrap = hard_wrap;\n        cx.notify();\n    }\n\n    pub fn set_text_style_refinement(&mut self, style: TextStyleRefinement) {\n        self.text_style_refinement = Some(style);\n    }\n\n    /// called by the Element so we know what style we were most recently rendered with.\n    pub(crate) fn set_style(\n        &mut self,\n        style: EditorStyle,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        // We intentionally do not inform the display map about the minimap style\n        // so that wrapping is not recalculated and stays consistent for the editor\n        // and its linked minimap.\n        if !self.mode.is_minimap() {\n            let rem_size = window.rem_size();\n            self.display_map.update(cx, |map, cx| {\n                map.set_font(\n                    style.text.font(),\n                    style.text.font_size.to_pixels(rem_size),\n                    cx,\n                )\n            });\n        }\n        self.style = Some(style);\n    }\n\n    pub fn style(&self) -> Option<&EditorStyle> {\n        self.style.as_ref()\n    }\n\n    // Called by the element. This method is not designed to be called outside of the editor\n    // element's layout code because it does not notify when rewrapping is computed synchronously.\n    pub(crate) fn set_wrap_width(&self, width: Option<Pixels>, cx: &mut App) -> bool {\n        self.display_map\n            .update(cx, |map, cx| map.set_wrap_width(width, cx))\n    }\n\n    pub fn set_soft_wrap(&mut self) {\n        self.soft_wrap_mode_override = Some(language_settings::SoftWrap::EditorWidth)\n    }\n\n    pub fn toggle_soft_wrap(&mut self, _: &ToggleSoftWrap, _: &mut Window, cx: &mut Context<Self>) {\n        if self.soft_wrap_mode_override.is_some() {\n            self.soft_wrap_mode_override.take();\n        } else {\n            let soft_wrap = match self.soft_wrap_mode(cx) {\n                SoftWrap::GitDiff => return,\n                SoftWrap::None => language_settings::SoftWrap::EditorWidth,\n                SoftWrap::EditorWidth | SoftWrap::Column(_) | SoftWrap::Bounded(_) => {\n                    language_settings::SoftWrap::None\n                }\n            };\n            self.soft_wrap_mode_override = Some(soft_wrap);\n        }\n        cx.notify();\n    }\n\n    pub fn toggle_tab_bar(&mut self, _: &ToggleTabBar, _: &mut Window, cx: &mut Context<Self>) {\n        let Some(workspace) = self.workspace() else {\n            return;\n        };\n        let fs = workspace.read(cx).app_state().fs.clone();\n        let current_show = TabBarSettings::get_global(cx).show;\n        update_settings_file::<TabBarSettings>(fs, cx, move |setting, _| {\n            setting.show = Some(!current_show);\n        });\n    }\n\n    pub fn toggle_indent_guides(\n        &mut self,\n        _: &ToggleIndentGuides,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let currently_enabled = self.should_show_indent_guides().unwrap_or_else(|| {\n            self.buffer\n                .read(cx)\n                .language_settings(cx)\n                .indent_guides\n                .enabled\n        });\n        self.show_indent_guides = Some(!currently_enabled);\n        cx.notify();\n    }\n\n    fn should_show_indent_guides(&self) -> Option<bool> {\n        self.show_indent_guides\n    }\n\n    pub fn toggle_line_numbers(\n        &mut self,\n        _: &ToggleLineNumbers,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let mut editor_settings = EditorSettings::get_global(cx).clone();\n        editor_settings.gutter.line_numbers = !editor_settings.gutter.line_numbers;\n        EditorSettings::override_global(editor_settings, cx);\n    }\n\n    pub fn line_numbers_enabled(&self, cx: &App) -> bool {\n        if let Some(show_line_numbers) = self.show_line_numbers {\n            return show_line_numbers;\n        }\n        EditorSettings::get_global(cx).gutter.line_numbers\n    }\n\n    pub fn should_use_relative_line_numbers(&self, cx: &mut App) -> bool {\n        self.use_relative_line_numbers\n            .unwrap_or(EditorSettings::get_global(cx).relative_line_numbers)\n    }\n\n    pub fn toggle_relative_line_numbers(\n        &mut self,\n        _: &ToggleRelativeLineNumbers,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let is_relative = self.should_use_relative_line_numbers(cx);\n        self.set_relative_line_number(Some(!is_relative), cx)\n    }\n\n    pub fn set_relative_line_number(&mut self, is_relative: Option<bool>, cx: &mut Context<Self>) {\n        self.use_relative_line_numbers = is_relative;\n        cx.notify();\n    }\n\n    pub fn set_show_gutter(&mut self, show_gutter: bool, cx: &mut Context<Self>) {\n        self.show_gutter = show_gutter;\n        cx.notify();\n    }\n\n    pub fn set_show_scrollbars(&mut self, show: bool, cx: &mut Context<Self>) {\n        self.show_scrollbars = ScrollbarAxes {\n            horizontal: show,\n            vertical: show,\n        };\n        cx.notify();\n    }\n\n    pub fn set_show_vertical_scrollbar(&mut self, show: bool, cx: &mut Context<Self>) {\n        self.show_scrollbars.vertical = show;\n        cx.notify();\n    }\n\n    pub fn set_show_horizontal_scrollbar(&mut self, show: bool, cx: &mut Context<Self>) {\n        self.show_scrollbars.horizontal = show;\n        cx.notify();\n    }\n\n    pub fn set_minimap_visibility(\n        &mut self,\n        minimap_visibility: MinimapVisibility,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.minimap_visibility != minimap_visibility {\n            if minimap_visibility.visible() && self.minimap.is_none() {\n                let minimap_settings = EditorSettings::get_global(cx).minimap;\n                self.minimap =\n                    self.create_minimap(minimap_settings.with_show_override(), window, cx);\n            }\n            self.minimap_visibility = minimap_visibility;\n            cx.notify();\n        }\n    }\n\n    pub fn disable_scrollbars_and_minimap(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.set_show_scrollbars(false, cx);\n        self.set_minimap_visibility(MinimapVisibility::Disabled, window, cx);\n    }\n\n    pub fn hide_minimap_by_default(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.set_minimap_visibility(self.minimap_visibility.hidden(), window, cx);\n    }\n\n    /// Normally the text in full mode and auto height editors is padded on the\n    /// left side by roughly half a character width for improved hit testing.\n    ///\n    /// Use this method to disable this for cases where this is not wanted (e.g.\n    /// if you want to align the editor text with some other text above or below)\n    /// or if you want to add this padding to single-line editors.\n    pub fn set_offset_content(&mut self, offset_content: bool, cx: &mut Context<Self>) {\n        self.offset_content = offset_content;\n        cx.notify();\n    }\n\n    pub fn set_show_line_numbers(&mut self, show_line_numbers: bool, cx: &mut Context<Self>) {\n        self.show_line_numbers = Some(show_line_numbers);\n        cx.notify();\n    }\n\n    pub fn disable_expand_excerpt_buttons(&mut self, cx: &mut Context<Self>) {\n        self.disable_expand_excerpt_buttons = true;\n        cx.notify();\n    }\n\n    pub fn set_show_git_diff_gutter(&mut self, show_git_diff_gutter: bool, cx: &mut Context<Self>) {\n        self.show_git_diff_gutter = Some(show_git_diff_gutter);\n        cx.notify();\n    }\n\n    pub fn set_show_code_actions(&mut self, show_code_actions: bool, cx: &mut Context<Self>) {\n        self.show_code_actions = Some(show_code_actions);\n        cx.notify();\n    }\n\n    pub fn set_show_runnables(&mut self, show_runnables: bool, cx: &mut Context<Self>) {\n        self.show_runnables = Some(show_runnables);\n        cx.notify();\n    }\n\n    pub fn set_show_breakpoints(&mut self, show_breakpoints: bool, cx: &mut Context<Self>) {\n        self.show_breakpoints = Some(show_breakpoints);\n        cx.notify();\n    }\n\n    pub fn set_masked(&mut self, masked: bool, cx: &mut Context<Self>) {\n        if self.display_map.read(cx).masked != masked {\n            self.display_map.update(cx, |map, _| map.masked = masked);\n        }\n        cx.notify()\n    }\n\n    pub fn set_show_wrap_guides(&mut self, show_wrap_guides: bool, cx: &mut Context<Self>) {\n        self.show_wrap_guides = Some(show_wrap_guides);\n        cx.notify();\n    }\n\n    pub fn set_show_indent_guides(&mut self, show_indent_guides: bool, cx: &mut Context<Self>) {\n        self.show_indent_guides = Some(show_indent_guides);\n        cx.notify();\n    }\n\n    pub fn working_directory(&self, cx: &App) -> Option<PathBuf> {\n        if let Some(buffer) = self.buffer().read(cx).as_singleton() {\n            if let Some(file) = buffer.read(cx).file().and_then(|f| f.as_local()) {\n                if let Some(dir) = file.abs_path(cx).parent() {\n                    return Some(dir.to_owned());\n                }\n            }\n\n            if let Some(project_path) = buffer.read(cx).project_path(cx) {\n                return Some(project_path.path.to_path_buf());\n            }\n        }\n\n        None\n    }\n\n    fn target_file<'a>(&self, cx: &'a App) -> Option<&'a dyn language::LocalFile> {\n        self.active_excerpt(cx)?\n            .1\n            .read(cx)\n            .file()\n            .and_then(|f| f.as_local())\n    }\n\n    pub fn target_file_abs_path(&self, cx: &mut Context<Self>) -> Option<PathBuf> {\n        self.active_excerpt(cx).and_then(|(_, buffer, _)| {\n            let buffer = buffer.read(cx);\n            if let Some(project_path) = buffer.project_path(cx) {\n                let project = self.project.as_ref()?.read(cx);\n                project.absolute_path(&project_path, cx)\n            } else {\n                buffer\n                    .file()\n                    .and_then(|file| file.as_local().map(|file| file.abs_path(cx)))\n            }\n        })\n    }\n\n    fn target_file_path(&self, cx: &mut Context<Self>) -> Option<PathBuf> {\n        self.active_excerpt(cx).and_then(|(_, buffer, _)| {\n            let project_path = buffer.read(cx).project_path(cx)?;\n            let project = self.project.as_ref()?.read(cx);\n            let entry = project.entry_for_path(&project_path, cx)?;\n            let path = entry.path.to_path_buf();\n            Some(path)\n        })\n    }\n\n    pub fn reveal_in_finder(\n        &mut self,\n        _: &RevealInFileManager,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(target) = self.target_file(cx) {\n            cx.reveal_path(&target.abs_path(cx));\n        }\n    }\n\n    pub fn copy_path(\n        &mut self,\n        _: &zed_actions::workspace::CopyPath,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(path) = self.target_file_abs_path(cx) {\n            if let Some(path) = path.to_str() {\n                cx.write_to_clipboard(ClipboardItem::new_string(path.to_string()));\n            }\n        }\n    }\n\n    pub fn copy_relative_path(\n        &mut self,\n        _: &zed_actions::workspace::CopyRelativePath,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(path) = self.target_file_path(cx) {\n            if let Some(path) = path.to_str() {\n                cx.write_to_clipboard(ClipboardItem::new_string(path.to_string()));\n            }\n        }\n    }\n\n    pub fn project_path(&self, cx: &App) -> Option<ProjectPath> {\n        if let Some(buffer) = self.buffer.read(cx).as_singleton() {\n            buffer.read(cx).project_path(cx)\n        } else {\n            None\n        }\n    }\n\n    // Returns true if the editor handled a go-to-line request\n    pub fn go_to_active_debug_line(&mut self, window: &mut Window, cx: &mut Context<Self>) -> bool {\n        maybe!({\n            let breakpoint_store = self.breakpoint_store.as_ref()?;\n\n            let Some(active_stack_frame) = breakpoint_store.read(cx).active_position().cloned()\n            else {\n                self.clear_row_highlights::<ActiveDebugLine>();\n                return None;\n            };\n\n            let position = active_stack_frame.position;\n            let buffer_id = position.buffer_id?;\n            let snapshot = self\n                .project\n                .as_ref()?\n                .read(cx)\n                .buffer_for_id(buffer_id, cx)?\n                .read(cx)\n                .snapshot();\n\n            let mut handled = false;\n            for (id, ExcerptRange { context, .. }) in\n                self.buffer.read(cx).excerpts_for_buffer(buffer_id, cx)\n            {\n                if context.start.cmp(&position, &snapshot).is_ge()\n                    || context.end.cmp(&position, &snapshot).is_lt()\n                {\n                    continue;\n                }\n                let snapshot = self.buffer.read(cx).snapshot(cx);\n                let multibuffer_anchor = snapshot.anchor_in_excerpt(id, position)?;\n\n                handled = true;\n                self.clear_row_highlights::<ActiveDebugLine>();\n\n                self.go_to_line::<ActiveDebugLine>(\n                    multibuffer_anchor,\n                    Some(cx.theme().colors().editor_debugger_active_line_background),\n                    window,\n                    cx,\n                );\n\n                cx.notify();\n            }\n\n            handled.then_some(())\n        })\n        .is_some()\n    }\n\n    pub fn copy_file_name_without_extension(\n        &mut self,\n        _: &CopyFileNameWithoutExtension,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(file) = self.target_file(cx) {\n            if let Some(file_stem) = file.path().file_stem() {\n                if let Some(name) = file_stem.to_str() {\n                    cx.write_to_clipboard(ClipboardItem::new_string(name.to_string()));\n                }\n            }\n        }\n    }\n\n    pub fn copy_file_name(&mut self, _: &CopyFileName, _: &mut Window, cx: &mut Context<Self>) {\n        if let Some(file) = self.target_file(cx) {\n            if let Some(file_name) = file.path().file_name() {\n                if let Some(name) = file_name.to_str() {\n                    cx.write_to_clipboard(ClipboardItem::new_string(name.to_string()));\n                }\n            }\n        }\n    }\n\n    pub fn toggle_git_blame(\n        &mut self,\n        _: &::git::Blame,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.show_git_blame_gutter = !self.show_git_blame_gutter;\n\n        if self.show_git_blame_gutter && !self.has_blame_entries(cx) {\n            self.start_git_blame(true, window, cx);\n        }\n\n        cx.notify();\n    }\n\n    pub fn toggle_git_blame_inline(\n        &mut self,\n        _: &ToggleGitBlameInline,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.toggle_git_blame_inline_internal(true, window, cx);\n        cx.notify();\n    }\n\n    pub fn open_git_blame_commit(\n        &mut self,\n        _: &OpenGitBlameCommit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.open_git_blame_commit_internal(window, cx);\n    }\n\n    fn open_git_blame_commit_internal(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        let blame = self.blame.as_ref()?;\n        let snapshot = self.snapshot(window, cx);\n        let cursor = self.selections.newest::<Point>(cx).head();\n        let (buffer, point, _) = snapshot.buffer_snapshot.point_to_buffer_point(cursor)?;\n        let blame_entry = blame\n            .update(cx, |blame, cx| {\n                blame\n                    .blame_for_rows(\n                        &[RowInfo {\n                            buffer_id: Some(buffer.remote_id()),\n                            buffer_row: Some(point.row),\n                            ..Default::default()\n                        }],\n                        cx,\n                    )\n                    .next()\n            })\n            .flatten()?;\n        let renderer = cx.global::<GlobalBlameRenderer>().0.clone();\n        let repo = blame.read(cx).repository(cx)?;\n        let workspace = self.workspace()?.downgrade();\n        renderer.open_blame_commit(blame_entry, repo, workspace, window, cx);\n        None\n    }\n\n    pub fn git_blame_inline_enabled(&self) -> bool {\n        self.git_blame_inline_enabled\n    }\n\n    pub fn toggle_selection_menu(\n        &mut self,\n        _: &ToggleSelectionMenu,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.show_selection_menu = self\n            .show_selection_menu\n            .map(|show_selections_menu| !show_selections_menu)\n            .or_else(|| Some(!EditorSettings::get_global(cx).toolbar.selections_menu));\n\n        cx.notify();\n    }\n\n    pub fn selection_menu_enabled(&self, cx: &App) -> bool {\n        self.show_selection_menu\n            .unwrap_or_else(|| EditorSettings::get_global(cx).toolbar.selections_menu)\n    }\n\n    fn start_git_blame(\n        &mut self,\n        user_triggered: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(project) = self.project.as_ref() {\n            let Some(buffer) = self.buffer().read(cx).as_singleton() else {\n                return;\n            };\n\n            if buffer.read(cx).file().is_none() {\n                return;\n            }\n\n            let focused = self.focus_handle(cx).contains_focused(window, cx);\n\n            let project = project.clone();\n            let blame = cx.new(|cx| GitBlame::new(buffer, project, user_triggered, focused, cx));\n            self.blame_subscription =\n                Some(cx.observe_in(&blame, window, |_, _, _, cx| cx.notify()));\n            self.blame = Some(blame);\n        }\n    }\n\n    fn toggle_git_blame_inline_internal(\n        &mut self,\n        user_triggered: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.git_blame_inline_enabled {\n            self.git_blame_inline_enabled = false;\n            self.show_git_blame_inline = false;\n            self.show_git_blame_inline_delay_task.take();\n        } else {\n            self.git_blame_inline_enabled = true;\n            self.start_git_blame_inline(user_triggered, window, cx);\n        }\n\n        cx.notify();\n    }\n\n    fn start_git_blame_inline(\n        &mut self,\n        user_triggered: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.start_git_blame(user_triggered, window, cx);\n\n        if ProjectSettings::get_global(cx)\n            .git\n            .inline_blame_delay()\n            .is_some()\n        {\n            self.start_inline_blame_timer(window, cx);\n        } else {\n            self.show_git_blame_inline = true\n        }\n    }\n\n    pub fn blame(&self) -> Option<&Entity<GitBlame>> {\n        self.blame.as_ref()\n    }\n\n    pub fn show_git_blame_gutter(&self) -> bool {\n        self.show_git_blame_gutter\n    }\n\n    pub fn render_git_blame_gutter(&self, cx: &App) -> bool {\n        !self.mode().is_minimap() && self.show_git_blame_gutter && self.has_blame_entries(cx)\n    }\n\n    pub fn render_git_blame_inline(&self, window: &Window, cx: &App) -> bool {\n        self.show_git_blame_inline\n            && (self.focus_handle.is_focused(window) || self.inline_blame_popover.is_some())\n            && !self.newest_selection_head_on_empty_line(cx)\n            && self.has_blame_entries(cx)\n    }\n\n    fn has_blame_entries(&self, cx: &App) -> bool {\n        self.blame()\n            .map_or(false, |blame| blame.read(cx).has_generated_entries())\n    }\n\n    fn newest_selection_head_on_empty_line(&self, cx: &App) -> bool {\n        let cursor_anchor = self.selections.newest_anchor().head();\n\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let buffer_row = MultiBufferRow(cursor_anchor.to_point(&snapshot).row);\n\n        snapshot.line_len(buffer_row) == 0\n    }\n\n    fn get_permalink_to_line(&self, cx: &mut Context<Self>) -> Task<Result<url::Url>> {\n        let buffer_and_selection = maybe!({\n            let selection = self.selections.newest::<Point>(cx);\n            let selection_range = selection.range();\n\n            let multi_buffer = self.buffer().read(cx);\n            let multi_buffer_snapshot = multi_buffer.snapshot(cx);\n            let buffer_ranges = multi_buffer_snapshot.range_to_buffer_ranges(selection_range);\n\n            let (buffer, range, _) = if selection.reversed {\n                buffer_ranges.first()\n            } else {\n                buffer_ranges.last()\n            }?;\n\n            let selection = text::ToPoint::to_point(&range.start, &buffer).row\n                ..text::ToPoint::to_point(&range.end, &buffer).row;\n            Some((\n                multi_buffer.buffer(buffer.remote_id()).unwrap().clone(),\n                selection,\n            ))\n        });\n\n        let Some((buffer, selection)) = buffer_and_selection else {\n            return Task::ready(Err(anyhow!(": "",
    ")));\n        };\n\n        let Some(project) = self.project.as_ref() else {\n            return Task::ready(Err(anyhow!(": "",
    ")));\n        };\n\n        project.update(cx, |project, cx| {\n            project.get_permalink_to_line(&buffer, selection, cx)\n        })\n    }\n\n    pub fn copy_permalink_to_line(\n        &mut self,\n        _: &CopyPermalinkToLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let permalink_task = self.get_permalink_to_line(cx);\n        let workspace = self.workspace();\n\n        cx.spawn_in(window, async move |_, cx| match permalink_task.await {\n            Ok(permalink) => {\n                cx.update(|_, cx| {\n                    cx.write_to_clipboard(ClipboardItem::new_string(permalink.to_string()));\n                })\n                .ok();\n            }\n            Err(err) => {\n                let message = format!(": "",
    ");\n\n                anyhow::Result::<()>::Err(err).log_err();\n\n                if let Some(workspace) = workspace {\n                    workspace\n                        .update_in(cx, |workspace, _, cx| {\n                            struct CopyPermalinkToLine;\n\n                            workspace.show_toast(\n                                Toast::new(\n                                    NotificationId::unique::<CopyPermalinkToLine>(),\n                                    message,\n                                ),\n                                cx,\n                            )\n                        })\n                        .ok();\n                }\n            }\n        })\n        .detach();\n    }\n\n    pub fn copy_file_location(\n        &mut self,\n        _: &CopyFileLocation,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let selection = self.selections.newest::<Point>(cx).start.row + 1;\n        if let Some(file) = self.target_file(cx) {\n            if let Some(path) = file.path().to_str() {\n                cx.write_to_clipboard(ClipboardItem::new_string(format!(": "",
    ")));\n            }\n        }\n    }\n\n    pub fn open_permalink_to_line(\n        &mut self,\n        _: &OpenPermalinkToLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let permalink_task = self.get_permalink_to_line(cx);\n        let workspace = self.workspace();\n\n        cx.spawn_in(window, async move |_, cx| match permalink_task.await {\n            Ok(permalink) => {\n                cx.update(|_, cx| {\n                    cx.open_url(permalink.as_ref());\n                })\n                .ok();\n            }\n            Err(err) => {\n                let message = format!(": "",
    ");\n\n                anyhow::Result::<()>::Err(err).log_err();\n\n                if let Some(workspace) = workspace {\n                    workspace\n                        .update(cx, |workspace, cx| {\n                            struct OpenPermalinkToLine;\n\n                            workspace.show_toast(\n                                Toast::new(\n                                    NotificationId::unique::<OpenPermalinkToLine>(),\n                                    message,\n                                ),\n                                cx,\n                            )\n                        })\n                        .ok();\n                }\n            }\n        })\n        .detach();\n    }\n\n    pub fn insert_uuid_v4(\n        &mut self,\n        _: &InsertUuidV4,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.insert_uuid(UuidVersion::V4, window, cx);\n    }\n\n    pub fn insert_uuid_v7(\n        &mut self,\n        _: &InsertUuidV7,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.insert_uuid(UuidVersion::V7, window, cx);\n    }\n\n    fn insert_uuid(&mut self, version: UuidVersion, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(&HideMouseCursorOrigin::TypingAction);\n        self.transact(window, cx, |this, window, cx| {\n            let edits = this\n                .selections\n                .all::<Point>(cx)\n                .into_iter()\n                .map(|selection| {\n                    let uuid = match version {\n                        UuidVersion::V4 => uuid::Uuid::new_v4(),\n                        UuidVersion::V7 => uuid::Uuid::now_v7(),\n                    };\n\n                    (selection.range(), uuid.to_string())\n                });\n            this.edit(edits, cx);\n            this.refresh_inline_completion(true, false, window, cx);\n        });\n    }\n\n    pub fn open_selections_in_multibuffer(\n        &mut self,\n        _: &OpenSelectionsInMultibuffer,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let multibuffer = self.buffer.read(cx);\n\n        let Some(buffer) = multibuffer.as_singleton() else {\n            return;\n        };\n\n        let Some(workspace) = self.workspace() else {\n            return;\n        };\n\n        let locations = self\n            .selections\n            .disjoint_anchors()\n            .iter()\n            .map(|range| Location {\n                buffer: buffer.clone(),\n                range: range.start.text_anchor..range.end.text_anchor,\n            })\n            .collect::<Vec<_>>();\n\n        let title = multibuffer.title(cx).to_string();\n\n        cx.spawn_in(window, async move |_, cx| {\n            workspace.update_in(cx, |workspace, window, cx| {\n                Self::open_locations_in_multibuffer(\n                    workspace,\n                    locations,\n                    format!(": "",
    "),\n                    false,\n                    MultibufferSelectionMode::All,\n                    window,\n                    cx,\n                );\n            })\n        })\n        .detach();\n    }\n\n    /// Adds a row highlight for the given range. If a row has multiple highlights, the\n    /// last highlight added will be used.\n    ///\n    /// If the range ends at the beginning of a line, then that line will not be highlighted.\n    pub fn highlight_rows<T: 'static>(\n        &mut self,\n        range: Range<Anchor>,\n        color: Hsla,\n        options: RowHighlightOptions,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n        let row_highlights = self.highlighted_rows.entry(TypeId::of::<T>()).or_default();\n        let ix = row_highlights.binary_search_by(|highlight| {\n            Ordering::Equal\n                .then_with(|| highlight.range.start.cmp(&range.start, &snapshot))\n                .then_with(|| highlight.range.end.cmp(&range.end, &snapshot))\n        });\n\n        if let Err(mut ix) = ix {\n            let index = post_inc(&mut self.highlight_order);\n\n            // If this range intersects with the preceding highlight, then merge it with\n            // the preceding highlight. Otherwise insert a new highlight.\n            let mut merged = false;\n            if ix > 0 {\n                let prev_highlight = &mut row_highlights[ix - 1];\n                if prev_highlight\n                    .range\n                    .end\n                    .cmp(&range.start, &snapshot)\n                    .is_ge()\n                {\n                    ix -= 1;\n                    if prev_highlight.range.end.cmp(&range.end, &snapshot).is_lt() {\n                        prev_highlight.range.end = range.end;\n                    }\n                    merged = true;\n                    prev_highlight.index = index;\n                    prev_highlight.color = color;\n                    prev_highlight.options = options;\n                }\n            }\n\n            if !merged {\n                row_highlights.insert(\n                    ix,\n                    RowHighlight {\n                        range: range.clone(),\n                        index,\n                        color,\n                        options,\n                        type_id: TypeId::of::<T>(),\n                    },\n                );\n            }\n\n            // If any of the following highlights intersect with this one, merge them.\n            while let Some(next_highlight) = row_highlights.get(ix + 1) {\n                let highlight = &row_highlights[ix];\n                if next_highlight\n                    .range\n                    .start\n                    .cmp(&highlight.range.end, &snapshot)\n                    .is_le()\n                {\n                    if next_highlight\n                        .range\n                        .end\n                        .cmp(&highlight.range.end, &snapshot)\n                        .is_gt()\n                    {\n                        row_highlights[ix].range.end = next_highlight.range.end;\n                    }\n                    row_highlights.remove(ix + 1);\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    /// Remove any highlighted row ranges of the given type that intersect the\n    /// given ranges.\n    pub fn remove_highlighted_rows<T: 'static>(\n        &mut self,\n        ranges_to_remove: Vec<Range<Anchor>>,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n        let row_highlights = self.highlighted_rows.entry(TypeId::of::<T>()).or_default();\n        let mut ranges_to_remove = ranges_to_remove.iter().peekable();\n        row_highlights.retain(|highlight| {\n            while let Some(range_to_remove) = ranges_to_remove.peek() {\n                match range_to_remove.end.cmp(&highlight.range.start, &snapshot) {\n                    Ordering::Less | Ordering::Equal => {\n                        ranges_to_remove.next();\n                    }\n                    Ordering::Greater => {\n                        match range_to_remove.start.cmp(&highlight.range.end, &snapshot) {\n                            Ordering::Less | Ordering::Equal => {\n                                return false;\n                            }\n                            Ordering::Greater => break,\n                        }\n                    }\n                }\n            }\n\n            true\n        })\n    }\n\n    /// Clear all anchor ranges for a certain highlight context type, so no corresponding rows will be highlighted.\n    pub fn clear_row_highlights<T: 'static>(&mut self) {\n        self.highlighted_rows.remove(&TypeId::of::<T>());\n    }\n\n    /// For a highlight given context type, gets all anchor ranges that will be used for row highlighting.\n    pub fn highlighted_rows<T: 'static>(&self) -> impl '_ + Iterator<Item = (Range<Anchor>, Hsla)> {\n        self.highlighted_rows\n            .get(&TypeId::of::<T>())\n            .map_or(&[] as &[_], |vec| vec.as_slice())\n            .iter()\n            .map(|highlight| (highlight.range.clone(), highlight.color))\n    }\n\n    /// Merges all anchor ranges for all context types ever set, picking the last highlight added in case of a row conflict.\n    /// Returns a map of display rows that are highlighted and their corresponding highlight color.\n    /// Allows to ignore certain kinds of highlights.\n    pub fn highlighted_display_rows(\n        &self,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> BTreeMap<DisplayRow, LineHighlight> {\n        let snapshot = self.snapshot(window, cx);\n        let mut used_highlight_orders = HashMap::default();\n        self.highlighted_rows\n            .iter()\n            .flat_map(|(_, highlighted_rows)| highlighted_rows.iter())\n            .fold(\n                BTreeMap::<DisplayRow, LineHighlight>::new(),\n                |mut unique_rows, highlight| {\n                    let start = highlight.range.start.to_display_point(&snapshot);\n                    let end = highlight.range.end.to_display_point(&snapshot);\n                    let start_row = start.row().0;\n                    let end_row = if highlight.range.end.text_anchor != text::Anchor::MAX\n                        && end.column() == 0\n                    {\n                        end.row().0.saturating_sub(1)\n                    } else {\n                        end.row().0\n                    };\n                    for row in start_row..=end_row {\n                        let used_index =\n                            used_highlight_orders.entry(row).or_insert(highlight.index);\n                        if highlight.index >= *used_index {\n                            *used_index = highlight.index;\n                            unique_rows.insert(\n                                DisplayRow(row),\n                                LineHighlight {\n                                    include_gutter: highlight.options.include_gutter,\n                                    border: None,\n                                    background: highlight.color.into(),\n                                    type_id: Some(highlight.type_id),\n                                },\n                            );\n                        }\n                    }\n                    unique_rows\n                },\n            )\n    }\n\n    pub fn highlighted_display_row_for_autoscroll(\n        &self,\n        snapshot: &DisplaySnapshot,\n    ) -> Option<DisplayRow> {\n        self.highlighted_rows\n            .values()\n            .flat_map(|highlighted_rows| highlighted_rows.iter())\n            .filter_map(|highlight| {\n                if highlight.options.autoscroll {\n                    Some(highlight.range.start.to_display_point(snapshot).row())\n                } else {\n                    None\n                }\n            })\n            .min()\n    }\n\n    pub fn set_search_within_ranges(&mut self, ranges: &[Range<Anchor>], cx: &mut Context<Self>) {\n        self.highlight_background::<SearchWithinRange>(\n            ranges,\n            |colors| colors.editor_document_highlight_read_background,\n            cx,\n        )\n    }\n\n    pub fn set_breadcrumb_header(&mut self, new_header: String) {\n        self.breadcrumb_header = Some(new_header);\n    }\n\n    pub fn clear_search_within_ranges(&mut self, cx: &mut Context<Self>) {\n        self.clear_background_highlights::<SearchWithinRange>(cx);\n    }\n\n    pub fn highlight_background<T: 'static>(\n        &mut self,\n        ranges: &[Range<Anchor>],\n        color_fetcher: fn(&ThemeColors) -> Hsla,\n        cx: &mut Context<Self>,\n    ) {\n        self.background_highlights\n            .insert(TypeId::of::<T>(), (color_fetcher, Arc::from(ranges)));\n        self.scrollbar_marker_state.dirty = true;\n        cx.notify();\n    }\n\n    pub fn clear_background_highlights<T: 'static>(\n        &mut self,\n        cx: &mut Context<Self>,\n    ) -> Option<BackgroundHighlight> {\n        let text_highlights = self.background_highlights.remove(&TypeId::of::<T>())?;\n        if !text_highlights.1.is_empty() {\n            self.scrollbar_marker_state.dirty = true;\n            cx.notify();\n        }\n        Some(text_highlights)\n    }\n\n    pub fn highlight_gutter<T: 'static>(\n        &mut self,\n        ranges: impl Into<Vec<Range<Anchor>>>,\n        color_fetcher: fn(&App) -> Hsla,\n        cx: &mut Context<Self>,\n    ) {\n        self.gutter_highlights\n            .insert(TypeId::of::<T>(), (color_fetcher, ranges.into()));\n        cx.notify();\n    }\n\n    pub fn clear_gutter_highlights<T: 'static>(\n        &mut self,\n        cx: &mut Context<Self>,\n    ) -> Option<GutterHighlight> {\n        cx.notify();\n        self.gutter_highlights.remove(&TypeId::of::<T>())\n    }\n\n    pub fn insert_gutter_highlight<T: 'static>(\n        &mut self,\n        range: Range<Anchor>,\n        color_fetcher: fn(&App) -> Hsla,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n        let mut highlights = self\n            .gutter_highlights\n            .remove(&TypeId::of::<T>())\n            .map(|(_, highlights)| highlights)\n            .unwrap_or_default();\n        let ix = highlights.binary_search_by(|highlight| {\n            Ordering::Equal\n                .then_with(|| highlight.start.cmp(&range.start, &snapshot))\n                .then_with(|| highlight.end.cmp(&range.end, &snapshot))\n        });\n        if let Err(ix) = ix {\n            highlights.insert(ix, range);\n        }\n        self.gutter_highlights\n            .insert(TypeId::of::<T>(), (color_fetcher, highlights));\n    }\n\n    pub fn remove_gutter_highlights<T: 'static>(\n        &mut self,\n        ranges_to_remove: Vec<Range<Anchor>>,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n        let Some((color_fetcher, mut gutter_highlights)) =\n            self.gutter_highlights.remove(&TypeId::of::<T>())\n        else {\n            return;\n        };\n        let mut ranges_to_remove = ranges_to_remove.iter().peekable();\n        gutter_highlights.retain(|highlight| {\n            while let Some(range_to_remove) = ranges_to_remove.peek() {\n                match range_to_remove.end.cmp(&highlight.start, &snapshot) {\n                    Ordering::Less | Ordering::Equal => {\n                        ranges_to_remove.next();\n                    }\n                    Ordering::Greater => {\n                        match range_to_remove.start.cmp(&highlight.end, &snapshot) {\n                            Ordering::Less | Ordering::Equal => {\n                                return false;\n                            }\n                            Ordering::Greater => break,\n                        }\n                    }\n                }\n            }\n\n            true\n        });\n        self.gutter_highlights\n            .insert(TypeId::of::<T>(), (color_fetcher, gutter_highlights));\n    }\n\n    #[cfg(feature = ": "",
    ")]\n    pub fn all_text_background_highlights(\n        &self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Vec<(Range<DisplayPoint>, Hsla)> {\n        let snapshot = self.snapshot(window, cx);\n        let buffer = &snapshot.buffer_snapshot;\n        let start = buffer.anchor_before(0);\n        let end = buffer.anchor_after(buffer.len());\n        let theme = cx.theme().colors();\n        self.background_highlights_in_range(start..end, &snapshot, theme)\n    }\n\n    #[cfg(feature = ": "",
    ")]\n    pub fn search_background_highlights(&mut self, cx: &mut Context<Self>) -> Vec<Range<Point>> {\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n\n        let highlights = self\n            .background_highlights\n            .get(&TypeId::of::<items::BufferSearchHighlights>());\n\n        if let Some((_color, ranges)) = highlights {\n            ranges\n                .iter()\n                .map(|range| range.start.to_point(&snapshot)..range.end.to_point(&snapshot))\n                .collect_vec()\n        } else {\n            vec![]\n        }\n    }\n\n    fn document_highlights_for_position<'a>(\n        &'a self,\n        position: Anchor,\n        buffer: &'a MultiBufferSnapshot,\n    ) -> impl 'a + Iterator<Item = &'a Range<Anchor>> {\n        let read_highlights = self\n            .background_highlights\n            .get(&TypeId::of::<DocumentHighlightRead>())\n            .map(|h| &h.1);\n        let write_highlights = self\n            .background_highlights\n            .get(&TypeId::of::<DocumentHighlightWrite>())\n            .map(|h| &h.1);\n        let left_position = position.bias_left(buffer);\n        let right_position = position.bias_right(buffer);\n        read_highlights\n            .into_iter()\n            .chain(write_highlights)\n            .flat_map(move |ranges| {\n                let start_ix = match ranges.binary_search_by(|probe| {\n                    let cmp = probe.end.cmp(&left_position, buffer);\n                    if cmp.is_ge() {\n                        Ordering::Greater\n                    } else {\n                        Ordering::Less\n                    }\n                }) {\n                    Ok(i) | Err(i) => i,\n                };\n\n                ranges[start_ix..]\n                    .iter()\n                    .take_while(move |range| range.start.cmp(&right_position, buffer).is_le())\n            })\n    }\n\n    pub fn has_background_highlights<T: 'static>(&self) -> bool {\n        self.background_highlights\n            .get(&TypeId::of::<T>())\n            .map_or(false, |(_, highlights)| !highlights.is_empty())\n    }\n\n    pub fn background_highlights_in_range(\n        &self,\n        search_range: Range<Anchor>,\n        display_snapshot: &DisplaySnapshot,\n        theme: &ThemeColors,\n    ) -> Vec<(Range<DisplayPoint>, Hsla)> {\n        let mut results = Vec::new();\n        for (color_fetcher, ranges) in self.background_highlights.values() {\n            let color = color_fetcher(theme);\n            let start_ix = match ranges.binary_search_by(|probe| {\n                let cmp = probe\n                    .end\n                    .cmp(&search_range.start, &display_snapshot.buffer_snapshot);\n                if cmp.is_gt() {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            }) {\n                Ok(i) | Err(i) => i,\n            };\n            for range in &ranges[start_ix..] {\n                if range\n                    .start\n                    .cmp(&search_range.end, &display_snapshot.buffer_snapshot)\n                    .is_ge()\n                {\n                    break;\n                }\n\n                let start = range.start.to_display_point(display_snapshot);\n                let end = range.end.to_display_point(display_snapshot);\n                results.push((start..end, color))\n            }\n        }\n        results\n    }\n\n    pub fn background_highlight_row_ranges<T: 'static>(\n        &self,\n        search_range: Range<Anchor>,\n        display_snapshot: &DisplaySnapshot,\n        count: usize,\n    ) -> Vec<RangeInclusive<DisplayPoint>> {\n        let mut results = Vec::new();\n        let Some((_, ranges)) = self.background_highlights.get(&TypeId::of::<T>()) else {\n            return vec![];\n        };\n\n        let start_ix = match ranges.binary_search_by(|probe| {\n            let cmp = probe\n                .end\n                .cmp(&search_range.start, &display_snapshot.buffer_snapshot);\n            if cmp.is_gt() {\n                Ordering::Greater\n            } else {\n                Ordering::Less\n            }\n        }) {\n            Ok(i) | Err(i) => i,\n        };\n        let mut push_region = |start: Option<Point>, end: Option<Point>| {\n            if let (Some(start_display), Some(end_display)) = (start, end) {\n                results.push(\n                    start_display.to_display_point(display_snapshot)\n                        ..=end_display.to_display_point(display_snapshot),\n                );\n            }\n        };\n        let mut start_row: Option<Point> = None;\n        let mut end_row: Option<Point> = None;\n        if ranges.len() > count {\n            return Vec::new();\n        }\n        for range in &ranges[start_ix..] {\n            if range\n                .start\n                .cmp(&search_range.end, &display_snapshot.buffer_snapshot)\n                .is_ge()\n            {\n                break;\n            }\n            let end = range.end.to_point(&display_snapshot.buffer_snapshot);\n            if let Some(current_row) = &end_row {\n                if end.row == current_row.row {\n                    continue;\n                }\n            }\n            let start = range.start.to_point(&display_snapshot.buffer_snapshot);\n            if start_row.is_none() {\n                assert_eq!(end_row, None);\n                start_row = Some(start);\n                end_row = Some(end);\n                continue;\n            }\n            if let Some(current_end) = end_row.as_mut() {\n                if start.row > current_end.row + 1 {\n                    push_region(start_row, end_row);\n                    start_row = Some(start);\n                    end_row = Some(end);\n                } else {\n                    // Merge two hunks.\n                    *current_end = end;\n                }\n            } else {\n                unreachable!();\n            }\n        }\n        // We might still have a hunk that was not rendered (if there was a search hit on the last line)\n        push_region(start_row, end_row);\n        results\n    }\n\n    pub fn gutter_highlights_in_range(\n        &self,\n        search_range: Range<Anchor>,\n        display_snapshot: &DisplaySnapshot,\n        cx: &App,\n    ) -> Vec<(Range<DisplayPoint>, Hsla)> {\n        let mut results = Vec::new();\n        for (color_fetcher, ranges) in self.gutter_highlights.values() {\n            let color = color_fetcher(cx);\n            let start_ix = match ranges.binary_search_by(|probe| {\n                let cmp = probe\n                    .end\n                    .cmp(&search_range.start, &display_snapshot.buffer_snapshot);\n                if cmp.is_gt() {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            }) {\n                Ok(i) | Err(i) => i,\n            };\n            for range in &ranges[start_ix..] {\n                if range\n                    .start\n                    .cmp(&search_range.end, &display_snapshot.buffer_snapshot)\n                    .is_ge()\n                {\n                    break;\n                }\n\n                let start = range.start.to_display_point(display_snapshot);\n                let end = range.end.to_display_point(display_snapshot);\n                results.push((start..end, color))\n            }\n        }\n        results\n    }\n\n    /// Get the text ranges corresponding to the redaction query\n    pub fn redacted_ranges(\n        &self,\n        search_range: Range<Anchor>,\n        display_snapshot: &DisplaySnapshot,\n        cx: &App,\n    ) -> Vec<Range<DisplayPoint>> {\n        display_snapshot\n            .buffer_snapshot\n            .redacted_ranges(search_range, |file| {\n                if let Some(file) = file {\n                    file.is_private()\n                        && EditorSettings::get(\n                            Some(SettingsLocation {\n                                worktree_id: file.worktree_id(cx),\n                                path: file.path().as_ref(),\n                            }),\n                            cx,\n                        )\n                        .redact_private_values\n                } else {\n                    false\n                }\n            })\n            .map(|range| {\n                range.start.to_display_point(display_snapshot)\n                    ..range.end.to_display_point(display_snapshot)\n            })\n            .collect()\n    }\n\n    pub fn highlight_text<T: 'static>(\n        &mut self,\n        ranges: Vec<Range<Anchor>>,\n        style: HighlightStyle,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map.update(cx, |map, _| {\n            map.highlight_text(TypeId::of::<T>(), ranges, style)\n        });\n        cx.notify();\n    }\n\n    pub(crate) fn highlight_inlays<T: 'static>(\n        &mut self,\n        highlights: Vec<InlayHighlight>,\n        style: HighlightStyle,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map.update(cx, |map, _| {\n            map.highlight_inlays(TypeId::of::<T>(), highlights, style)\n        });\n        cx.notify();\n    }\n\n    pub fn text_highlights<'a, T: 'static>(\n        &'a self,\n        cx: &'a App,\n    ) -> Option<(HighlightStyle, &'a [Range<Anchor>])> {\n        self.display_map.read(cx).text_highlights(TypeId::of::<T>())\n    }\n\n    pub fn clear_highlights<T: 'static>(&mut self, cx: &mut Context<Self>) {\n        let cleared = self\n            .display_map\n            .update(cx, |map, _| map.clear_highlights(TypeId::of::<T>()));\n        if cleared {\n            cx.notify();\n        }\n    }\n\n    pub fn show_local_cursors(&self, window: &mut Window, cx: &mut App) -> bool {\n        (self.read_only(cx) || self.blink_manager.read(cx).visible())\n            && self.focus_handle.is_focused(window)\n    }\n\n    pub fn set_show_cursor_when_unfocused(&mut self, is_enabled: bool, cx: &mut Context<Self>) {\n        self.show_cursor_when_unfocused = is_enabled;\n        cx.notify();\n    }\n\n    fn on_buffer_changed(&mut self, _: Entity<MultiBuffer>, cx: &mut Context<Self>) {\n        cx.notify();\n    }\n\n    fn on_debug_session_event(\n        &mut self,\n        _session: Entity<Session>,\n        event: &SessionEvent,\n        cx: &mut Context<Self>,\n    ) {\n        match event {\n            SessionEvent::InvalidateInlineValue => {\n                self.refresh_inline_values(cx);\n            }\n            _ => {}\n        }\n    }\n\n    pub fn refresh_inline_values(&mut self, cx: &mut Context<Self>) {\n        let Some(project) = self.project.clone() else {\n            return;\n        };\n\n        if !self.inline_value_cache.enabled {\n            let inlays = std::mem::take(&mut self.inline_value_cache.inlays);\n            self.splice_inlays(&inlays, Vec::new(), cx);\n            return;\n        }\n\n        let current_execution_position = self\n            .highlighted_rows\n            .get(&TypeId::of::<ActiveDebugLine>())\n            .and_then(|lines| lines.last().map(|line| line.range.start));\n\n        self.inline_value_cache.refresh_task = cx.spawn(async move |editor, cx| {\n            let inline_values = editor\n                .update(cx, |editor, cx| {\n                    let Some(current_execution_position) = current_execution_position else {\n                        return Some(Task::ready(Ok(Vec::new())));\n                    };\n\n                    let buffer = editor.buffer.read_with(cx, |buffer, cx| {\n                        let snapshot = buffer.snapshot(cx);\n\n                        let excerpt = snapshot.excerpt_containing(\n                            current_execution_position..current_execution_position,\n                        )?;\n\n                        editor.buffer.read(cx).buffer(excerpt.buffer_id())\n                    })?;\n\n                    let range =\n                        buffer.read(cx).anchor_before(0)..current_execution_position.text_anchor;\n\n                    project.inline_values(buffer, range, cx)\n                })\n                .ok()\n                .flatten()?\n                .await\n                .context(": "",
    ")\n                .log_err()?;\n\n            let mut buffer_inline_values: HashMap<BufferId, Vec<InlayHint>> = HashMap::default();\n\n            for (buffer_id, inline_value) in inline_values\n                .into_iter()\n                .filter_map(|hint| Some((hint.position.buffer_id?, hint)))\n            {\n                buffer_inline_values\n                    .entry(buffer_id)\n                    .or_default()\n                    .push(inline_value);\n            }\n\n            editor\n                .update(cx, |editor, cx| {\n                    let snapshot = editor.buffer.read(cx).snapshot(cx);\n                    let mut new_inlays = Vec::default();\n\n                    for (excerpt_id, buffer_snapshot, _) in snapshot.excerpts() {\n                        let buffer_id = buffer_snapshot.remote_id();\n                        buffer_inline_values\n                            .get(&buffer_id)\n                            .into_iter()\n                            .flatten()\n                            .for_each(|hint| {\n                                let inlay = Inlay::debugger_hint(\n                                    post_inc(&mut editor.next_inlay_id),\n                                    Anchor::in_buffer(excerpt_id, buffer_id, hint.position),\n                                    hint.text(),\n                                );\n\n                                new_inlays.push(inlay);\n                            });\n                    }\n\n                    let mut inlay_ids = new_inlays.iter().map(|inlay| inlay.id).collect();\n                    std::mem::swap(&mut editor.inline_value_cache.inlays, &mut inlay_ids);\n\n                    editor.splice_inlays(&inlay_ids, new_inlays, cx);\n                })\n                .ok()?;\n            Some(())\n        });\n    }\n\n    fn on_buffer_event(\n        &mut self,\n        multibuffer: &Entity<MultiBuffer>,\n        event: &multi_buffer::Event,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        match event {\n            multi_buffer::Event::Edited {\n                singleton_buffer_edited,\n                edited_buffer,\n            } => {\n                self.scrollbar_marker_state.dirty = true;\n                self.active_indent_guides_state.dirty = true;\n                self.refresh_active_diagnostics(cx);\n                self.refresh_code_actions(window, cx);\n                self.refresh_selected_text_highlights(true, window, cx);\n                refresh_matching_bracket_highlights(self, window, cx);\n                if self.has_active_inline_completion() {\n                    self.update_visible_inline_completion(window, cx);\n                }\n                if let Some(project) = self.project.as_ref() {\n                    if let Some(edited_buffer) = edited_buffer {\n                        project.update(cx, |project, cx| {\n                            self.registered_buffers\n                                .entry(edited_buffer.read(cx).remote_id())\n                                .or_insert_with(|| {\n                                    project\n                                        .register_buffer_with_language_servers(&edited_buffer, cx)\n                                });\n                        });\n                        if edited_buffer.read(cx).file().is_some() {\n                            self.pull_diagnostics(\n                                Some(edited_buffer.read(cx).remote_id()),\n                                window,\n                                cx,\n                            );\n                        }\n                    }\n                }\n                cx.emit(EditorEvent::BufferEdited);\n                cx.emit(SearchEvent::MatchesInvalidated);\n                if *singleton_buffer_edited {\n                    if let Some(buffer) = edited_buffer {\n                        if buffer.read(cx).file().is_none() {\n                            cx.emit(EditorEvent::TitleChanged);\n                        }\n                    }\n                    if let Some(project) = &self.project {\n                        #[allow(clippy::mutable_key_type)]\n                        let languages_affected = multibuffer.update(cx, |multibuffer, cx| {\n                            multibuffer\n                                .all_buffers()\n                                .into_iter()\n                                .filter_map(|buffer| {\n                                    buffer.update(cx, |buffer, cx| {\n                                        let language = buffer.language()?;\n                                        let should_discard = project.update(cx, |project, cx| {\n                                            project.is_local()\n                                                && !project.has_language_servers_for(buffer, cx)\n                                        });\n                                        should_discard.not().then_some(language.clone())\n                                    })\n                                })\n                                .collect::<HashSet<_>>()\n                        });\n                        if !languages_affected.is_empty() {\n                            self.refresh_inlay_hints(\n                                InlayHintRefreshReason::BufferEdited(languages_affected),\n                                cx,\n                            );\n                        }\n                    }\n                }\n\n                let Some(project) = &self.project else { return };\n                let (telemetry, is_via_ssh) = {\n                    let project = project.read(cx);\n                    let telemetry = project.client().telemetry().clone();\n                    let is_via_ssh = project.is_via_ssh();\n                    (telemetry, is_via_ssh)\n                };\n                refresh_linked_ranges(self, window, cx);\n                telemetry.log_edit_event(": "",
    ", is_via_ssh);\n            }\n            multi_buffer::Event::ExcerptsAdded {\n                buffer,\n                predecessor,\n                excerpts,\n            } => {\n                self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n                let buffer_id = buffer.read(cx).remote_id();\n                if self.buffer.read(cx).diff_for(buffer_id).is_none() {\n                    if let Some(project) = &self.project {\n                        update_uncommitted_diff_for_buffer(\n                            cx.entity(),\n                            project,\n                            [buffer.clone()],\n                            self.buffer.clone(),\n                            cx,\n                        )\n                        .detach();\n                    }\n                }\n                cx.emit(EditorEvent::ExcerptsAdded {\n                    buffer: buffer.clone(),\n                    predecessor: *predecessor,\n                    excerpts: excerpts.clone(),\n                });\n                self.refresh_inlay_hints(InlayHintRefreshReason::NewLinesShown, cx);\n            }\n            multi_buffer::Event::ExcerptsRemoved {\n                ids,\n                removed_buffer_ids,\n            } => {\n                self.refresh_inlay_hints(InlayHintRefreshReason::ExcerptsRemoved(ids.clone()), cx);\n                let buffer = self.buffer.read(cx);\n                self.registered_buffers\n                    .retain(|buffer_id, _| buffer.buffer(*buffer_id).is_some());\n                jsx_tag_auto_close::refresh_enabled_in_any_buffer(self, multibuffer, cx);\n                cx.emit(EditorEvent::ExcerptsRemoved {\n                    ids: ids.clone(),\n                    removed_buffer_ids: removed_buffer_ids.clone(),\n                })\n            }\n            multi_buffer::Event::ExcerptsEdited {\n                excerpt_ids,\n                buffer_ids,\n            } => {\n                self.display_map.update(cx, |map, cx| {\n                    map.unfold_buffers(buffer_ids.iter().copied(), cx)\n                });\n                cx.emit(EditorEvent::ExcerptsEdited {\n                    ids: excerpt_ids.clone(),\n                })\n            }\n            multi_buffer::Event::ExcerptsExpanded { ids } => {\n                self.refresh_inlay_hints(InlayHintRefreshReason::NewLinesShown, cx);\n                cx.emit(EditorEvent::ExcerptsExpanded { ids: ids.clone() })\n            }\n            multi_buffer::Event::Reparsed(buffer_id) => {\n                self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n                jsx_tag_auto_close::refresh_enabled_in_any_buffer(self, multibuffer, cx);\n\n                cx.emit(EditorEvent::Reparsed(*buffer_id));\n            }\n            multi_buffer::Event::DiffHunksToggled => {\n                self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n            }\n            multi_buffer::Event::LanguageChanged(buffer_id) => {\n                linked_editing_ranges::refresh_linked_ranges(self, window, cx);\n                jsx_tag_auto_close::refresh_enabled_in_any_buffer(self, multibuffer, cx);\n                cx.emit(EditorEvent::Reparsed(*buffer_id));\n                cx.notify();\n            }\n            multi_buffer::Event::DirtyChanged => cx.emit(EditorEvent::DirtyChanged),\n            multi_buffer::Event::Saved => cx.emit(EditorEvent::Saved),\n            multi_buffer::Event::FileHandleChanged\n            | multi_buffer::Event::Reloaded\n            | multi_buffer::Event::BufferDiffChanged => cx.emit(EditorEvent::TitleChanged),\n            multi_buffer::Event::Closed => cx.emit(EditorEvent::Closed),\n            multi_buffer::Event::DiagnosticsUpdated => {\n                self.update_diagnostics_state(window, cx);\n            }\n            _ => {}\n        };\n    }\n\n    fn update_diagnostics_state(&mut self, window: &mut Window, cx: &mut Context<'_, Editor>) {\n        self.refresh_active_diagnostics(cx);\n        self.refresh_inline_diagnostics(true, window, cx);\n        self.scrollbar_marker_state.dirty = true;\n        cx.notify();\n    }\n\n    pub fn start_temporary_diff_override(&mut self) {\n        self.load_diff_task.take();\n        self.temporary_diff_override = true;\n    }\n\n    pub fn end_temporary_diff_override(&mut self, cx: &mut Context<Self>) {\n        self.temporary_diff_override = false;\n        self.set_render_diff_hunk_controls(Arc::new(render_diff_hunk_controls), cx);\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.set_all_diff_hunks_collapsed(cx);\n        });\n\n        if let Some(project) = self.project.clone() {\n            self.load_diff_task = Some(\n                update_uncommitted_diff_for_buffer(\n                    cx.entity(),\n                    &project,\n                    self.buffer.read(cx).all_buffers(),\n                    self.buffer.clone(),\n                    cx,\n                )\n                .shared(),\n            );\n        }\n    }\n\n    fn on_display_map_changed(\n        &mut self,\n        _: Entity<DisplayMap>,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        cx.notify();\n    }\n\n    fn settings_changed(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        let new_severity = if self.diagnostics_enabled() {\n            EditorSettings::get_global(cx)\n                .diagnostics_max_severity\n                .unwrap_or(DiagnosticSeverity::Hint)\n        } else {\n            DiagnosticSeverity::Off\n        };\n        self.set_max_diagnostics_severity(new_severity, cx);\n        self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n        self.update_edit_prediction_settings(cx);\n        self.refresh_inline_completion(true, false, window, cx);\n        self.refresh_inlay_hints(\n            InlayHintRefreshReason::SettingsChange(inlay_hint_settings(\n                self.selections.newest_anchor().head(),\n                &self.buffer.read(cx).snapshot(cx),\n                cx,\n            )),\n            cx,\n        );\n\n        let old_cursor_shape = self.cursor_shape;\n\n        {\n            let editor_settings = EditorSettings::get_global(cx);\n            self.scroll_manager.vertical_scroll_margin = editor_settings.vertical_scroll_margin;\n            self.show_breadcrumbs = editor_settings.toolbar.breadcrumbs;\n            self.cursor_shape = editor_settings.cursor_shape.unwrap_or_default();\n            self.hide_mouse_mode = editor_settings.hide_mouse.unwrap_or_default();\n            self.drag_and_drop_selection_enabled = editor_settings.drag_and_drop_selection;\n        }\n\n        if old_cursor_shape != self.cursor_shape {\n            cx.emit(EditorEvent::CursorShapeChanged);\n        }\n\n        let project_settings = ProjectSettings::get_global(cx);\n        self.serialize_dirty_buffers =\n            !self.mode.is_minimap() && project_settings.session.restore_unsaved_buffers;\n\n        if self.mode.is_full() {\n            let show_inline_diagnostics = project_settings.diagnostics.inline.enabled;\n            let inline_blame_enabled = project_settings.git.inline_blame_enabled();\n            if self.show_inline_diagnostics != show_inline_diagnostics {\n                self.show_inline_diagnostics = show_inline_diagnostics;\n                self.refresh_inline_diagnostics(false, window, cx);\n            }\n\n            if self.git_blame_inline_enabled != inline_blame_enabled {\n                self.toggle_git_blame_inline_internal(false, window, cx);\n            }\n\n            let minimap_settings = EditorSettings::get_global(cx).minimap;\n            if self.minimap_visibility != MinimapVisibility::Disabled {\n                if self.minimap_visibility.settings_visibility()\n                    != minimap_settings.minimap_enabled()\n                {\n                    self.set_minimap_visibility(\n                        MinimapVisibility::for_mode(self.mode(), cx),\n                        window,\n                        cx,\n                    );\n                } else if let Some(minimap_entity) = self.minimap.as_ref() {\n                    minimap_entity.update(cx, |minimap_editor, cx| {\n                        minimap_editor.update_minimap_configuration(minimap_settings, cx)\n                    })\n                }\n            }\n        }\n\n        cx.notify();\n    }\n\n    pub fn set_searchable(&mut self, searchable: bool) {\n        self.searchable = searchable;\n    }\n\n    pub fn searchable(&self) -> bool {\n        self.searchable\n    }\n\n    fn open_proposed_changes_editor(\n        &mut self,\n        _: &OpenProposedChangesEditor,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(workspace) = self.workspace() else {\n            cx.propagate();\n            return;\n        };\n\n        let selections = self.selections.all::<usize>(cx);\n        let multi_buffer = self.buffer.read(cx);\n        let multi_buffer_snapshot = multi_buffer.snapshot(cx);\n        let mut new_selections_by_buffer = HashMap::default();\n        for selection in selections {\n            for (buffer, range, _) in\n                multi_buffer_snapshot.range_to_buffer_ranges(selection.start..selection.end)\n            {\n                let mut range = range.to_point(buffer);\n                range.start.column = 0;\n                range.end.column = buffer.line_len(range.end.row);\n                new_selections_by_buffer\n                    .entry(multi_buffer.buffer(buffer.remote_id()).unwrap())\n                    .or_insert(Vec::new())\n                    .push(range)\n            }\n        }\n\n        let proposed_changes_buffers = new_selections_by_buffer\n            .into_iter()\n            .map(|(buffer, ranges)| ProposedChangeLocation { buffer, ranges })\n            .collect::<Vec<_>>();\n        let proposed_changes_editor = cx.new(|cx| {\n            ProposedChangesEditor::new(\n                ": "",
    ",\n                proposed_changes_buffers,\n                self.project.clone(),\n                window,\n                cx,\n            )\n        });\n\n        window.defer(cx, move |window, cx| {\n            workspace.update(cx, |workspace, cx| {\n                workspace.active_pane().update(cx, |pane, cx| {\n                    pane.add_item(\n                        Box::new(proposed_changes_editor),\n                        true,\n                        true,\n                        None,\n                        window,\n                        cx,\n                    );\n                });\n            });\n        });\n    }\n\n    pub fn open_excerpts_in_split(\n        &mut self,\n        _: &OpenExcerptsSplit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.open_excerpts_common(None, true, window, cx)\n    }\n\n    pub fn open_excerpts(&mut self, _: &OpenExcerpts, window: &mut Window, cx: &mut Context<Self>) {\n        self.open_excerpts_common(None, false, window, cx)\n    }\n\n    fn open_excerpts_common(\n        &mut self,\n        jump_data: Option<JumpData>,\n        split: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(workspace) = self.workspace() else {\n            cx.propagate();\n            return;\n        };\n\n        if self.buffer.read(cx).is_singleton() {\n            cx.propagate();\n            return;\n        }\n\n        let mut new_selections_by_buffer = HashMap::default();\n        match &jump_data {\n            Some(JumpData::MultiBufferPoint {\n                excerpt_id,\n                position,\n                anchor,\n                line_offset_from_top,\n            }) => {\n                let multi_buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n                if let Some(buffer) = multi_buffer_snapshot\n                    .buffer_id_for_excerpt(*excerpt_id)\n                    .and_then(|buffer_id| self.buffer.read(cx).buffer(buffer_id))\n                {\n                    let buffer_snapshot = buffer.read(cx).snapshot();\n                    let jump_to_point = if buffer_snapshot.can_resolve(anchor) {\n                        language::ToPoint::to_point(anchor, &buffer_snapshot)\n                    } else {\n                        buffer_snapshot.clip_point(*position, Bias::Left)\n                    };\n                    let jump_to_offset = buffer_snapshot.point_to_offset(jump_to_point);\n                    new_selections_by_buffer.insert(\n                        buffer,\n                        (\n                            vec![jump_to_offset..jump_to_offset],\n                            Some(*line_offset_from_top),\n                        ),\n                    );\n                }\n            }\n            Some(JumpData::MultiBufferRow {\n                row,\n                line_offset_from_top,\n            }) => {\n                let point = MultiBufferPoint::new(row.0, 0);\n                if let Some((buffer, buffer_point, _)) =\n                    self.buffer.read(cx).point_to_buffer_point(point, cx)\n                {\n                    let buffer_offset = buffer.read(cx).point_to_offset(buffer_point);\n                    new_selections_by_buffer\n                        .entry(buffer)\n                        .or_insert((Vec::new(), Some(*line_offset_from_top)))\n                        .0\n                        .push(buffer_offset..buffer_offset)\n                }\n            }\n            None => {\n                let selections = self.selections.all::<usize>(cx);\n                let multi_buffer = self.buffer.read(cx);\n                for selection in selections {\n                    for (snapshot, range, _, anchor) in multi_buffer\n                        .snapshot(cx)\n                        .range_to_buffer_ranges_with_deleted_hunks(selection.range())\n                    {\n                        if let Some(anchor) = anchor {\n                            // selection is in a deleted hunk\n                            let Some(buffer_id) = anchor.buffer_id else {\n                                continue;\n                            };\n                            let Some(buffer_handle) = multi_buffer.buffer(buffer_id) else {\n                                continue;\n                            };\n                            let offset = text::ToOffset::to_offset(\n                                &anchor.text_anchor,\n                                &buffer_handle.read(cx).snapshot(),\n                            );\n                            let range = offset..offset;\n                            new_selections_by_buffer\n                                .entry(buffer_handle)\n                                .or_insert((Vec::new(), None))\n                                .0\n                                .push(range)\n                        } else {\n                            let Some(buffer_handle) = multi_buffer.buffer(snapshot.remote_id())\n                            else {\n                                continue;\n                            };\n                            new_selections_by_buffer\n                                .entry(buffer_handle)\n                                .or_insert((Vec::new(), None))\n                                .0\n                                .push(range)\n                        }\n                    }\n                }\n            }\n        }\n\n        new_selections_by_buffer\n            .retain(|buffer, _| Self::can_open_excerpts_in_file(buffer.read(cx).file()));\n\n        if new_selections_by_buffer.is_empty() {\n            return;\n        }\n\n        // We defer the pane interaction because we ourselves are a workspace item\n        // and activating a new item causes the pane to call a method on us reentrantly,\n        // which panics if we're on the stack.\n        window.defer(cx, move |window, cx| {\n            workspace.update(cx, |workspace, cx| {\n                let pane = if split {\n                    workspace.adjacent_pane(window, cx)\n                } else {\n                    workspace.active_pane().clone()\n                };\n\n                for (buffer, (ranges, scroll_offset)) in new_selections_by_buffer {\n                    let editor = buffer\n                        .read(cx)\n                        .file()\n                        .is_none()\n                        .then(|| {\n                            // Handle file-less buffers separately: those are not really the project items, so won't have a project path or entity id,\n                            // so `workspace.open_project_item` will never find them, always opening a new editor.\n                            // Instead, we try to activate the existing editor in the pane first.\n                            let (editor, pane_item_index) =\n                                pane.read(cx).items().enumerate().find_map(|(i, item)| {\n                                    let editor = item.downcast::<Editor>()?;\n                                    let singleton_buffer =\n                                        editor.read(cx).buffer().read(cx).as_singleton()?;\n                                    if singleton_buffer == buffer {\n                                        Some((editor, i))\n                                    } else {\n                                        None\n                                    }\n                                })?;\n                            pane.update(cx, |pane, cx| {\n                                pane.activate_item(pane_item_index, true, true, window, cx)\n                            });\n                            Some(editor)\n                        })\n                        .flatten()\n                        .unwrap_or_else(|| {\n                            workspace.open_project_item::<Self>(\n                                pane.clone(),\n                                buffer,\n                                true,\n                                true,\n                                window,\n                                cx,\n                            )\n                        });\n\n                    editor.update(cx, |editor, cx| {\n                        let autoscroll = match scroll_offset {\n                            Some(scroll_offset) => Autoscroll::top_relative(scroll_offset as usize),\n                            None => Autoscroll::newest(),\n                        };\n                        let nav_history = editor.nav_history.take();\n                        editor.change_selections(Some(autoscroll), window, cx, |s| {\n                            s.select_ranges(ranges);\n                        });\n                        editor.nav_history = nav_history;\n                    });\n                }\n            })\n        });\n    }\n\n    // For now, don't allow opening excerpts in buffers that aren't backed by\n    // regular project files.\n    fn can_open_excerpts_in_file(file: Option<&Arc<dyn language::File>>) -> bool {\n        file.map_or(true, |file| project::File::from_dyn(Some(file)).is_some())\n    }\n\n    fn marked_text_ranges(&self, cx: &App) -> Option<Vec<Range<OffsetUtf16>>> {\n        let snapshot = self.buffer.read(cx).read(cx);\n        let (_, ranges) = self.text_highlights::<InputComposition>(cx)?;\n        Some(\n            ranges\n                .iter()\n                .map(move |range| {\n                    range.start.to_offset_utf16(&snapshot)..range.end.to_offset_utf16(&snapshot)\n                })\n                .collect(),\n        )\n    }\n\n    fn selection_replacement_ranges(\n        &self,\n        range: Range<OffsetUtf16>,\n        cx: &mut App,\n    ) -> Vec<Range<OffsetUtf16>> {\n        let selections = self.selections.all::<OffsetUtf16>(cx);\n        let newest_selection = selections\n            .iter()\n            .max_by_key(|selection| selection.id)\n            .unwrap();\n        let start_delta = range.start.0 as isize - newest_selection.start.0 as isize;\n        let end_delta = range.end.0 as isize - newest_selection.end.0 as isize;\n        let snapshot = self.buffer.read(cx).read(cx);\n        selections\n            .into_iter()\n            .map(|mut selection| {\n                selection.start.0 =\n                    (selection.start.0 as isize).saturating_add(start_delta) as usize;\n                selection.end.0 = (selection.end.0 as isize).saturating_add(end_delta) as usize;\n                snapshot.clip_offset_utf16(selection.start, Bias::Left)\n                    ..snapshot.clip_offset_utf16(selection.end, Bias::Right)\n            })\n            .collect()\n    }\n\n    fn report_editor_event(\n        &self,\n        event_type: &'static str,\n        file_extension: Option<String>,\n        cx: &App,\n    ) {\n        if cfg!(any(test, feature = ": "",
    ")) {\n            return;\n        }\n\n        let Some(project) = &self.project else { return };\n\n        // If None, we are in a file without an extension\n        let file = self\n            .buffer\n            .read(cx)\n            .as_singleton()\n            .and_then(|b| b.read(cx).file());\n        let file_extension = file_extension.or(file\n            .as_ref()\n            .and_then(|file| Path::new(file.file_name(cx)).extension())\n            .and_then(|e| e.to_str())\n            .map(|a| a.to_string()));\n\n        let vim_mode = vim_enabled(cx);\n\n        let edit_predictions_provider = all_language_settings(file, cx).edit_predictions.provider;\n        let copilot_enabled = edit_predictions_provider\n            == language::language_settings::EditPredictionProvider::Copilot;\n        let copilot_enabled_for_language = self\n            .buffer\n            .read(cx)\n            .language_settings(cx)\n            .show_edit_predictions;\n\n        let project = project.read(cx);\n        telemetry::event!(\n            event_type,\n            file_extension,\n            vim_mode,\n            copilot_enabled,\n            copilot_enabled_for_language,\n            edit_predictions_provider,\n            is_via_ssh = project.is_via_ssh(),\n        );\n    }\n\n    /// Copy the highlighted chunks to the clipboard as JSON. The format is an array of lines,\n    /// with each line being an array of {text, highlight} objects.\n    fn copy_highlight_json(\n        &mut self,\n        _: &CopyHighlightJson,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        #[derive(Serialize)]\n        struct Chunk<'a> {\n            text: String,\n            highlight: Option<&'a str>,\n        }\n\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let range = self\n            .selected_text_range(false, window, cx)\n            .and_then(|selection| {\n                if selection.range.is_empty() {\n                    None\n                } else {\n                    Some(selection.range)\n                }\n            })\n            .unwrap_or_else(|| 0..snapshot.len());\n\n        let chunks = snapshot.chunks(range, true);\n        let mut lines = Vec::new();\n        let mut line: VecDeque<Chunk> = VecDeque::new();\n\n        let Some(style) = self.style.as_ref() else {\n            return;\n        };\n\n        for chunk in chunks {\n            let highlight = chunk\n                .syntax_highlight_id\n                .and_then(|id| id.name(&style.syntax));\n            let mut chunk_lines = chunk.text.split('\\n').peekable();\n            while let Some(text) = chunk_lines.next() {\n                let mut merged_with_last_token = false;\n                if let Some(last_token) = line.back_mut() {\n                    if last_token.highlight == highlight {\n                        last_token.text.push_str(text);\n                        merged_with_last_token = true;\n                    }\n                }\n\n                if !merged_with_last_token {\n                    line.push_back(Chunk {\n                        text: text.into(),\n                        highlight,\n                    });\n                }\n\n                if chunk_lines.peek().is_some() {\n                    if line.len() > 1 && line.front().unwrap().text.is_empty() {\n                        line.pop_front();\n                    }\n                    if line.len() > 1 && line.back().unwrap().text.is_empty() {\n                        line.pop_back();\n                    }\n\n                    lines.push(mem::take(&mut line));\n                }\n            }\n        }\n\n        let Some(lines) = serde_json::to_string_pretty(&lines).log_err() else {\n            return;\n        };\n        cx.write_to_clipboard(ClipboardItem::new_string(lines));\n    }\n\n    pub fn open_context_menu(\n        &mut self,\n        _: &OpenContextMenu,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.request_autoscroll(Autoscroll::newest(), cx);\n        let position = self.selections.newest_display(cx).start;\n        mouse_context_menu::deploy_context_menu(self, None, position, window, cx);\n    }\n\n    pub fn inlay_hint_cache(&self) -> &InlayHintCache {\n        &self.inlay_hint_cache\n    }\n\n    pub fn replay_insert_event(\n        &mut self,\n        text: &str,\n        relative_utf16_range: Option<Range<isize>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.input_enabled {\n            cx.emit(EditorEvent::InputIgnored { text: text.into() });\n            return;\n        }\n        if let Some(relative_utf16_range) = relative_utf16_range {\n            let selections = self.selections.all::<OffsetUtf16>(cx);\n            self.change_selections(None, window, cx, |s| {\n                let new_ranges = selections.into_iter().map(|range| {\n                    let start = OffsetUtf16(\n                        range\n                            .head()\n                            .0\n                            .saturating_add_signed(relative_utf16_range.start),\n                    );\n                    let end = OffsetUtf16(\n                        range\n                            .head()\n                            .0\n                            .saturating_add_signed(relative_utf16_range.end),\n                    );\n                    start..end\n                });\n                s.select_ranges(new_ranges);\n            });\n        }\n\n        self.handle_input(text, window, cx);\n    }\n\n    pub fn supports_inlay_hints(&self, cx: &mut App) -> bool {\n        let Some(provider) = self.semantics_provider.as_ref() else {\n            return false;\n        };\n\n        let mut supports = false;\n        self.buffer().update(cx, |this, cx| {\n            this.for_each_buffer(|buffer| {\n                supports |= provider.supports_inlay_hints(buffer, cx);\n            });\n        });\n\n        supports\n    }\n\n    pub fn is_focused(&self, window: &Window) -> bool {\n        self.focus_handle.is_focused(window)\n    }\n\n    fn handle_focus(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        cx.emit(EditorEvent::Focused);\n\n        if let Some(descendant) = self\n            .last_focused_descendant\n            .take()\n            .and_then(|descendant| descendant.upgrade())\n        {\n            window.focus(&descendant);\n        } else {\n            if let Some(blame) = self.blame.as_ref() {\n                blame.update(cx, GitBlame::focus)\n            }\n\n            self.blink_manager.update(cx, BlinkManager::enable);\n            self.show_cursor_names(window, cx);\n            self.buffer.update(cx, |buffer, cx| {\n                buffer.finalize_last_transaction(cx);\n                if self.leader_id.is_none() {\n                    buffer.set_active_selections(\n                        &self.selections.disjoint_anchors(),\n                        self.selections.line_mode,\n                        self.cursor_shape,\n                        cx,\n                    );\n                }\n            });\n        }\n    }\n\n    fn handle_focus_in(&mut self, _: &mut Window, cx: &mut Context<Self>) {\n        cx.emit(EditorEvent::FocusedIn)\n    }\n\n    fn handle_focus_out(\n        &mut self,\n        event: FocusOutEvent,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if event.blurred != self.focus_handle {\n            self.last_focused_descendant = Some(event.blurred);\n        }\n        self.refresh_inlay_hints(InlayHintRefreshReason::ModifiersChanged(false), cx);\n    }\n\n    pub fn handle_blur(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.blink_manager.update(cx, BlinkManager::disable);\n        self.buffer\n            .update(cx, |buffer, cx| buffer.remove_active_selections(cx));\n\n        if let Some(blame) = self.blame.as_ref() {\n            blame.update(cx, GitBlame::blur)\n        }\n        if !self.hover_state.focused(window, cx) {\n            hide_hover(self, cx);\n        }\n        if !self\n            .context_menu\n            .borrow()\n            .as_ref()\n            .is_some_and(|context_menu| context_menu.focused(window, cx))\n        {\n            self.hide_context_menu(window, cx);\n        }\n        self.discard_inline_completion(false, cx);\n        cx.emit(EditorEvent::Blurred);\n        cx.notify();\n    }\n\n    pub fn observe_pending_input(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        let mut pending: String = window\n            .pending_input_keystrokes()\n            .into_iter()\n            .flatten()\n            .filter_map(|keystroke| {\n                if keystroke.modifiers.is_subset_of(&Modifiers::shift()) {\n                    keystroke.key_char.clone()\n                } else {\n                    None\n                }\n            })\n            .collect();\n\n        if !self.input_enabled || self.read_only || !self.focus_handle.is_focused(window) {\n            pending = ": "",
    ".to_string();\n        }\n\n        let existing_pending = self\n            .text_highlights::<PendingInput>(cx)\n            .map(|(_, ranges)| ranges.iter().cloned().collect::<Vec<_>>());\n        if existing_pending.is_none() && pending.is_empty() {\n            return;\n        }\n        let transaction =\n            self.transact(window, cx, |this, window, cx| {\n                let selections = this.selections.all::<usize>(cx);\n                let edits = selections\n                    .iter()\n                    .map(|selection| (selection.end..selection.end, pending.clone()));\n                this.edit(edits, cx);\n                this.change_selections(None, window, cx, |s| {\n                    s.select_ranges(selections.into_iter().enumerate().map(|(ix, sel)| {\n                        sel.start + ix * pending.len()..sel.end + ix * pending.len()\n                    }));\n                });\n                if let Some(existing_ranges) = existing_pending {\n                    let edits = existing_ranges.iter().map(|range| (range.clone(), ": "",
    "));\n                    this.edit(edits, cx);\n                }\n            });\n\n        let snapshot = self.snapshot(window, cx);\n        let ranges = self\n            .selections\n            .all::<usize>(cx)\n            .into_iter()\n            .map(|selection| {\n                snapshot.buffer_snapshot.anchor_after(selection.end)\n                    ..snapshot\n                        .buffer_snapshot\n                        .anchor_before(selection.end + pending.len())\n            })\n            .collect();\n\n        if pending.is_empty() {\n            self.clear_highlights::<PendingInput>(cx);\n        } else {\n            self.highlight_text::<PendingInput>(\n                ranges,\n                HighlightStyle {\n                    underline: Some(UnderlineStyle {\n                        thickness: px(1.),\n                        color: None,\n                        wavy: false,\n                    }),\n                    ..Default::default()\n                },\n                cx,\n            );\n        }\n\n        self.ime_transaction = self.ime_transaction.or(transaction);\n        if let Some(transaction) = self.ime_transaction {\n            self.buffer.update(cx, |buffer, cx| {\n                buffer.group_until_transaction(transaction, cx);\n            });\n        }\n\n        if self.text_highlights::<PendingInput>(cx).is_none() {\n            self.ime_transaction.take();\n        }\n    }\n\n    pub fn register_action_renderer(\n        &mut self,\n        listener: impl Fn(&Editor, &mut Window, &mut Context<Editor>) + 'static,\n    ) -> Subscription {\n        let id = self.next_editor_action_id.post_inc();\n        self.editor_actions\n            .borrow_mut()\n            .insert(id, Box::new(listener));\n\n        let editor_actions = self.editor_actions.clone();\n        Subscription::new(move || {\n            editor_actions.borrow_mut().remove(&id);\n        })\n    }\n\n    pub fn register_action<A: Action>(\n        &mut self,\n        listener: impl Fn(&A, &mut Window, &mut App) + 'static,\n    ) -> Subscription {\n        let id = self.next_editor_action_id.post_inc();\n        let listener = Arc::new(listener);\n        self.editor_actions.borrow_mut().insert(\n            id,\n            Box::new(move |_, window, _| {\n                let listener = listener.clone();\n                window.on_action(TypeId::of::<A>(), move |action, phase, window, cx| {\n                    let action = action.downcast_ref().unwrap();\n                    if phase == DispatchPhase::Bubble {\n                        listener(action, window, cx)\n                    }\n                })\n            }),\n        );\n\n        let editor_actions = self.editor_actions.clone();\n        Subscription::new(move || {\n            editor_actions.borrow_mut().remove(&id);\n        })\n    }\n\n    pub fn file_header_size(&self) -> u32 {\n        FILE_HEADER_HEIGHT\n    }\n\n    pub fn restore(\n        &mut self,\n        revert_changes: HashMap<BufferId, Vec<(Range<text::Anchor>, Rope)>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let workspace = self.workspace();\n        let project = self.project.as_ref();\n        let save_tasks = self.buffer().update(cx, |multi_buffer, cx| {\n            let mut tasks = Vec::new();\n            for (buffer_id, changes) in revert_changes {\n                if let Some(buffer) = multi_buffer.buffer(buffer_id) {\n                    buffer.update(cx, |buffer, cx| {\n                        buffer.edit(\n                            changes\n                                .into_iter()\n                                .map(|(range, text)| (range, text.to_string())),\n                            None,\n                            cx,\n                        );\n                    });\n\n                    if let Some(project) =\n                        project.filter(|_| multi_buffer.all_diff_hunks_expanded())\n                    {\n                        project.update(cx, |project, cx| {\n                            tasks.push((buffer.clone(), project.save_buffer(buffer, cx)));\n                        })\n                    }\n                }\n            }\n            tasks\n        });\n        cx.spawn_in(window, async move |_, cx| {\n            for (buffer, task) in save_tasks {\n                let result = task.await;\n                if result.is_err() {\n                    let Some(path) = buffer\n                        .read_with(cx, |buffer, cx| buffer.project_path(cx))\n                        .ok()\n                    else {\n                        continue;\n                    };\n                    if let Some((workspace, path)) = workspace.as_ref().zip(path) {\n                        let Some(task) = cx\n                            .update_window_entity(&workspace, |workspace, window, cx| {\n                                workspace\n                                    .open_path_preview(path, None, false, false, false, window, cx)\n                            })\n                            .ok()\n                        else {\n                            continue;\n                        };\n                        task.await.log_err();\n                    }\n                }\n            }\n        })\n        .detach();\n        self.change_selections(None, window, cx, |selections| selections.refresh());\n    }\n\n    pub fn to_pixel_point(\n        &self,\n        source: multi_buffer::Anchor,\n        editor_snapshot: &EditorSnapshot,\n        window: &mut Window,\n    ) -> Option<gpui::Point<Pixels>> {\n        let source_point = source.to_display_point(editor_snapshot);\n        self.display_to_pixel_point(source_point, editor_snapshot, window)\n    }\n\n    pub fn display_to_pixel_point(\n        &self,\n        source: DisplayPoint,\n        editor_snapshot: &EditorSnapshot,\n        window: &mut Window,\n    ) -> Option<gpui::Point<Pixels>> {\n        let line_height = self.style()?.text.line_height_in_pixels(window.rem_size());\n        let text_layout_details = self.text_layout_details(window);\n        let scroll_top = text_layout_details\n            .scroll_anchor\n            .scroll_position(editor_snapshot)\n            .y;\n\n        if source.row().as_f32() < scroll_top.floor() {\n            return None;\n        }\n        let source_x = editor_snapshot.x_for_display_point(source, &text_layout_details);\n        let source_y = line_height * (source.row().as_f32() - scroll_top);\n        Some(gpui::Point::new(source_x, source_y))\n    }\n\n    pub fn has_visible_completions_menu(&self) -> bool {\n        !self.edit_prediction_preview_is_active()\n            && self.context_menu.borrow().as_ref().map_or(false, |menu| {\n                menu.visible() && matches!(menu, CodeContextMenu::Completions(_))\n            })\n    }\n\n    pub fn register_addon<T: Addon>(&mut self, instance: T) {\n        if self.mode.is_minimap() {\n            return;\n        }\n        self.addons\n            .insert(std::any::TypeId::of::<T>(), Box::new(instance));\n    }\n\n    pub fn unregister_addon<T: Addon>(&mut self) {\n        self.addons.remove(&std::any::TypeId::of::<T>());\n    }\n\n    pub fn addon<T: Addon>(&self) -> Option<&T> {\n        let type_id = std::any::TypeId::of::<T>();\n        self.addons\n            .get(&type_id)\n            .and_then(|item| item.to_any().downcast_ref::<T>())\n    }\n\n    pub fn addon_mut<T: Addon>(&mut self) -> Option<&mut T> {\n        let type_id = std::any::TypeId::of::<T>();\n        self.addons\n            .get_mut(&type_id)\n            .and_then(|item| item.to_any_mut()?.downcast_mut::<T>())\n    }\n\n    fn character_size(&self, window: &mut Window) -> gpui::Size<Pixels> {\n        let text_layout_details = self.text_layout_details(window);\n        let style = &text_layout_details.editor_style;\n        let font_id = window.text_system().resolve_font(&style.text.font());\n        let font_size = style.text.font_size.to_pixels(window.rem_size());\n        let line_height = style.text.line_height_in_pixels(window.rem_size());\n        let em_width = window.text_system().em_width(font_id, font_size).unwrap();\n\n        gpui::Size::new(em_width, line_height)\n    }\n\n    pub fn wait_for_diff_to_load(&self) -> Option<Shared<Task<()>>> {\n        self.load_diff_task.clone()\n    }\n\n    fn read_metadata_from_db(\n        &mut self,\n        item_id: u64,\n        workspace_id: WorkspaceId,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        if self.is_singleton(cx)\n            && !self.mode.is_minimap()\n            && WorkspaceSettings::get(None, cx).restore_on_startup != RestoreOnStartupBehavior::None\n        {\n            let buffer_snapshot = OnceCell::new();\n\n            if let Some(folds) = DB.get_editor_folds(item_id, workspace_id).log_err() {\n                if !folds.is_empty() {\n                    let snapshot =\n                        buffer_snapshot.get_or_init(|| self.buffer.read(cx).snapshot(cx));\n                    self.fold_ranges(\n                        folds\n                            .into_iter()\n                            .map(|(start, end)| {\n                                snapshot.clip_offset(start, Bias::Left)\n                                    ..snapshot.clip_offset(end, Bias::Right)\n                            })\n                            .collect(),\n                        false,\n                        window,\n                        cx,\n                    );\n                }\n            }\n\n            if let Some(selections) = DB.get_editor_selections(item_id, workspace_id).log_err() {\n                if !selections.is_empty() {\n                    let snapshot =\n                        buffer_snapshot.get_or_init(|| self.buffer.read(cx).snapshot(cx));\n                    // skip adding the initial selection to selection history\n                    self.selection_history.mode = SelectionHistoryMode::Skipping;\n                    self.change_selections(None, window, cx, |s| {\n                        s.select_ranges(selections.into_iter().map(|(start, end)| {\n                            snapshot.clip_offset(start, Bias::Left)\n                                ..snapshot.clip_offset(end, Bias::Right)\n                        }));\n                    });\n                    self.selection_history.mode = SelectionHistoryMode::Normal;\n                }\n            };\n        }\n\n        self.read_scroll_position_from_db(item_id, workspace_id, window, cx);\n    }\n}\n\nfn vim_enabled(cx: &App) -> bool {\n    cx.global::<SettingsStore>()\n        .raw_user_settings()\n        .get(": "",
    ")\n        == Some(&serde_json::Value::Bool(true))\n}\n\nfn process_completion_for_edit(\n    completion: &Completion,\n    intent: CompletionIntent,\n    buffer: &Entity<Buffer>,\n    cursor_position: &text::Anchor,\n    cx: &mut Context<Editor>,\n) -> CompletionEdit {\n    let buffer = buffer.read(cx);\n    let buffer_snapshot = buffer.snapshot();\n    let (snippet, new_text) = if completion.is_snippet() {\n        // Workaround for typescript language server issues so that methods don't expand within\n        // strings and functions with type expressions. The previous point is used because the query\n        // for function identifier doesn't match when the cursor is immediately after. See PR #30312\n        let mut snippet_source = completion.new_text.clone();\n        let mut previous_point = text::ToPoint::to_point(cursor_position, buffer);\n        previous_point.column = previous_point.column.saturating_sub(1);\n        if let Some(scope) = buffer_snapshot.language_scope_at(previous_point) {\n            if scope.prefers_label_for_snippet_in_completion() {\n                if let Some(label) = completion.label() {\n                    if matches!(\n                        completion.kind(),\n                        Some(CompletionItemKind::FUNCTION) | Some(CompletionItemKind::METHOD)\n                    ) {\n                        snippet_source = label;\n                    }\n                }\n            }\n        }\n        match Snippet::parse(&snippet_source).log_err() {\n            Some(parsed_snippet) => (Some(parsed_snippet.clone()), parsed_snippet.text),\n            None => (None, completion.new_text.clone()),\n        }\n    } else {\n        (None, completion.new_text.clone())\n    };\n\n    let mut range_to_replace = {\n        let replace_range = &completion.replace_range;\n        if let CompletionSource::Lsp {\n            insert_range: Some(insert_range),\n            ..\n        } = &completion.source\n        {\n            debug_assert_eq!(\n                insert_range.start, replace_range.start,\n                ": "",
    "\n            );\n            debug_assert!(\n                insert_range\n                    .start\n                    .cmp(&cursor_position, &buffer_snapshot)\n                    .is_le(),\n                ": "",
    "\n            );\n            debug_assert!(\n                replace_range\n                    .start\n                    .cmp(&cursor_position, &buffer_snapshot)\n                    .is_le(),\n                ": "",
    "\n            );\n            debug_assert!(\n                insert_range\n                    .end\n                    .cmp(&cursor_position, &buffer_snapshot)\n                    .is_le(),\n                ": "",
    "\n            );\n\n            let should_replace = match intent {\n                CompletionIntent::CompleteWithInsert => false,\n                CompletionIntent::CompleteWithReplace => true,\n                CompletionIntent::Complete | CompletionIntent::Compose => {\n                    let insert_mode =\n                        language_settings(buffer.language().map(|l| l.name()), buffer.file(), cx)\n                            .completions\n                            .lsp_insert_mode;\n                    match insert_mode {\n                        LspInsertMode::Insert => false,\n                        LspInsertMode::Replace => true,\n                        LspInsertMode::ReplaceSubsequence => {\n                            let mut text_to_replace = buffer.chars_for_range(\n                                buffer.anchor_before(replace_range.start)\n                                    ..buffer.anchor_after(replace_range.end),\n                            );\n                            let mut current_needle = text_to_replace.next();\n                            for haystack_ch in completion.label.text.chars() {\n                                if let Some(needle_ch) = current_needle {\n                                    if haystack_ch.eq_ignore_ascii_case(&needle_ch) {\n                                        current_needle = text_to_replace.next();\n                                    }\n                                }\n                            }\n                            current_needle.is_none()\n                        }\n                        LspInsertMode::ReplaceSuffix => {\n                            if replace_range\n                                .end\n                                .cmp(&cursor_position, &buffer_snapshot)\n                                .is_gt()\n                            {\n                                let range_after_cursor = *cursor_position..replace_range.end;\n                                let text_after_cursor = buffer\n                                    .text_for_range(\n                                        buffer.anchor_before(range_after_cursor.start)\n                                            ..buffer.anchor_after(range_after_cursor.end),\n                                    )\n                                    .collect::<String>()\n                                    .to_ascii_lowercase();\n                                completion\n                                    .label\n                                    .text\n                                    .to_ascii_lowercase()\n                                    .ends_with(&text_after_cursor)\n                            } else {\n                                true\n                            }\n                        }\n                    }\n                }\n            };\n\n            if should_replace {\n                replace_range.clone()\n            } else {\n                insert_range.clone()\n            }\n        } else {\n            replace_range.clone()\n        }\n    };\n\n    if range_to_replace\n        .end\n        .cmp(&cursor_position, &buffer_snapshot)\n        .is_lt()\n    {\n        range_to_replace.end = *cursor_position;\n    }\n\n    CompletionEdit {\n        new_text,\n        replace_range: range_to_replace.to_offset(&buffer),\n        snippet,\n    }\n}\n\nstruct CompletionEdit {\n    new_text: String,\n    replace_range: Range<usize>,\n    snippet: Option<Snippet>,\n}\n\nfn insert_extra_newline_brackets(\n    buffer: &MultiBufferSnapshot,\n    range: Range<usize>,\n    language: &language::LanguageScope,\n) -> bool {\n    let leading_whitespace_len = buffer\n        .reversed_chars_at(range.start)\n        .take_while(|c| c.is_whitespace() && *c != '\\n')\n        .map(|c| c.len_utf8())\n        .sum::<usize>();\n    let trailing_whitespace_len = buffer\n        .chars_at(range.end)\n        .take_while(|c| c.is_whitespace() && *c != '\\n')\n        .map(|c| c.len_utf8())\n        .sum::<usize>();\n    let range = range.start - leading_whitespace_len..range.end + trailing_whitespace_len;\n\n    language.brackets().any(|(pair, enabled)| {\n        let pair_start = pair.start.trim_end();\n        let pair_end = pair.end.trim_start();\n\n        enabled\n            && pair.newline\n            && buffer.contains_str_at(range.end, pair_end)\n            && buffer.contains_str_at(range.start.saturating_sub(pair_start.len()), pair_start)\n    })\n}\n\nfn insert_extra_newline_tree_sitter(buffer: &MultiBufferSnapshot, range: Range<usize>) -> bool {\n    let (buffer, range) = match buffer.range_to_buffer_ranges(range).as_slice() {\n        [(buffer, range, _)] => (*buffer, range.clone()),\n        _ => return false,\n    };\n    let pair = {\n        let mut result: Option<BracketMatch> = None;\n\n        for pair in buffer\n            .all_bracket_ranges(range.clone())\n            .filter(move |pair| {\n                pair.open_range.start <= range.start && pair.close_range.end >= range.end\n            })\n        {\n            let len = pair.close_range.end - pair.open_range.start;\n\n            if let Some(existing) = &result {\n                let existing_len = existing.close_range.end - existing.open_range.start;\n                if len > existing_len {\n                    continue;\n                }\n            }\n\n            result = Some(pair);\n        }\n\n        result\n    };\n    let Some(pair) = pair else {\n        return false;\n    };\n    pair.newline_only\n        && buffer\n            .chars_for_range(pair.open_range.end..range.start)\n            .chain(buffer.chars_for_range(range.end..pair.close_range.start))\n            .all(|c| c.is_whitespace() && c != '\\n')\n}\n\nfn update_uncommitted_diff_for_buffer(\n    editor: Entity<Editor>,\n    project: &Entity<Project>,\n    buffers: impl IntoIterator<Item = Entity<Buffer>>,\n    buffer: Entity<MultiBuffer>,\n    cx: &mut App,\n) -> Task<()> {\n    let mut tasks = Vec::new();\n    project.update(cx, |project, cx| {\n        for buffer in buffers {\n            if project::File::from_dyn(buffer.read(cx).file()).is_some() {\n                tasks.push(project.open_uncommitted_diff(buffer.clone(), cx))\n            }\n        }\n    });\n    cx.spawn(async move |cx| {\n        let diffs = future::join_all(tasks).await;\n        if editor\n            .read_with(cx, |editor, _cx| editor.temporary_diff_override)\n            .unwrap_or(false)\n        {\n            return;\n        }\n\n        buffer\n            .update(cx, |buffer, cx| {\n                for diff in diffs.into_iter().flatten() {\n                    buffer.add_diff(diff, cx);\n                }\n            })\n            .ok();\n    })\n}\n\nfn char_len_with_expanded_tabs(offset: usize, text: &str, tab_size: NonZeroU32) -> usize {\n    let tab_size = tab_size.get() as usize;\n    let mut width = offset;\n\n    for ch in text.chars() {\n        width += if ch == '\\t' {\n            tab_size - (width % tab_size)\n        } else {\n            1\n        };\n    }\n\n    width - offset\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_string_size_with_expanded_tabs() {\n        let nz = |val| NonZeroU32::new(val).unwrap();\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
    ", nz(4)), 0);\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
    ", nz(4)), 5);\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
    ", nz(4)), 9);\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
    ", nz(4)), 6);\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
    ", nz(4)), 8);\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
    ", nz(8)), 16);\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
    ", nz(8)), 8);\n        assert_eq!(char_len_with_expanded_tabs(7, ": "",
    ", nz(8)), 9);\n    }\n}\n\n/// Tokenizes a string into runs of text that should stick together, or that is whitespace.\nstruct WordBreakingTokenizer<'a> {\n    input: &'a str,\n}\n\nimpl<'a> WordBreakingTokenizer<'a> {\n    fn new(input: &'a str) -> Self {\n        Self { input }\n    }\n}\n\nfn is_char_ideographic(ch: char) -> bool {\n    use unicode_script::Script::*;\n    use unicode_script::UnicodeScript;\n    matches!(ch.script(), Han | Tangut | Yi)\n}\n\nfn is_grapheme_ideographic(text: &str) -> bool {\n    text.chars().any(is_char_ideographic)\n}\n\nfn is_grapheme_whitespace(text: &str) -> bool {\n    text.chars().any(|x| x.is_whitespace())\n}\n\nfn should_stay_with_preceding_ideograph(text: &str) -> bool {\n    text.chars().next().map_or(false, |ch| {\n        matches!(ch, '。' | '、' | '，' | '？' | '！' | '：' | '；' | '…')\n    })\n}\n\n#[derive(PartialEq, Eq, Debug, Clone, Copy)]\nenum WordBreakToken<'a> {\n    Word { token: &'a str, grapheme_len: usize },\n    InlineWhitespace { token: &'a str, grapheme_len: usize },\n    Newline,\n}\n\nimpl<'a> Iterator for WordBreakingTokenizer<'a> {\n    /// Yields a span, the count of graphemes in the token, and whether it was\n    /// whitespace. Note that it also breaks at word boundaries.\n    type Item = WordBreakToken<'a>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        use unicode_segmentation::UnicodeSegmentation;\n        if self.input.is_empty() {\n            return None;\n        }\n\n        let mut iter = self.input.graphemes(true).peekable();\n        let mut offset = 0;\n        let mut grapheme_len = 0;\n        if let Some(first_grapheme) = iter.next() {\n            let is_newline = first_grapheme == ": "",
    ";\n            let is_whitespace = is_grapheme_whitespace(first_grapheme);\n            offset += first_grapheme.len();\n            grapheme_len += 1;\n            if is_grapheme_ideographic(first_grapheme) && !is_whitespace {\n                if let Some(grapheme) = iter.peek().copied() {\n                    if should_stay_with_preceding_ideograph(grapheme) {\n                        offset += grapheme.len();\n                        grapheme_len += 1;\n                    }\n                }\n            } else {\n                let mut words = self.input[offset..].split_word_bound_indices().peekable();\n                let mut next_word_bound = words.peek().copied();\n                if next_word_bound.map_or(false, |(i, _)| i == 0) {\n                    next_word_bound = words.next();\n                }\n                while let Some(grapheme) = iter.peek().copied() {\n                    if next_word_bound.map_or(false, |(i, _)| i == offset) {\n                        break;\n                    };\n                    if is_grapheme_whitespace(grapheme) != is_whitespace\n                        || (grapheme == ": "",
    ") != is_newline\n                    {\n                        break;\n                    };\n                    offset += grapheme.len();\n                    grapheme_len += 1;\n                    iter.next();\n                }\n            }\n            let token = &self.input[..offset];\n            self.input = &self.input[offset..];\n            if token == ": "",
    " {\n                Some(WordBreakToken::Newline)\n            } else if is_whitespace {\n                Some(WordBreakToken::InlineWhitespace {\n                    token,\n                    grapheme_len,\n                })\n            } else {\n                Some(WordBreakToken::Word {\n                    token,\n                    grapheme_len,\n                })\n            }\n        } else {\n            None\n        }\n    }\n}\n\n#[test]\nfn test_word_breaking_tokenizer() {\n    let tests: &[(&str, &[WordBreakToken<'static>])] = &[\n        (": "",
    ", &[]),\n        (": "",
    ", &[whitespace(": "",
    ", 2)]),\n        (": "",
    ", &[word(": "",
    ", 1)]),\n        (": "",
    ", 2)]),\n        (\n            ": "",
    ",\n            &[word(": "",
    ", 1), word(": "",
    ", 2), word(": "",
    ", 1)],\n        ),\n        (\n            ": "",
    ", 5), whitespace(": "",
    ", 5)],\n        ),\n        (\n            ": "",
    ", 6), whitespace(": "",
    ",\n            &[\n                whitespace(": "",
    ", 2),\n                word(": "",
    ", 5),\n                whitespace(": "",
    ", 1),\n                word(": "",
    ", 5),\n            ],\n        ),\n        (\n            ": "",
    ",\n            &[\n                word(": "",
    ", 1),\n                whitespace(": "",
    ", 1),\n                newline(),\n                whitespace(": "",
    ", 1),\n            ],\n        ),\n        (": "",
    ", 6)]),\n    ];\n\n    fn word(token: &'static str, grapheme_len: usize) -> WordBreakToken<'static> {\n        WordBreakToken::Word {\n            token,\n            grapheme_len,\n        }\n    }\n\n    fn whitespace(token: &'static str, grapheme_len: usize) -> WordBreakToken<'static> {\n        WordBreakToken::InlineWhitespace {\n            token,\n            grapheme_len,\n        }\n    }\n\n    fn newline() -> WordBreakToken<'static> {\n        WordBreakToken::Newline\n    }\n\n    for (input, result) in tests {\n        assert_eq!(\n            WordBreakingTokenizer::new(input)\n                .collect::<Vec<_>>()\n                .as_slice(),\n            *result,\n        );\n    }\n}\n\nfn wrap_with_prefix(\n    line_prefix: String,\n    unwrapped_text: String,\n    wrap_column: usize,\n    tab_size: NonZeroU32,\n    preserve_existing_whitespace: bool,\n) -> String {\n    let line_prefix_len = char_len_with_expanded_tabs(0, &line_prefix, tab_size);\n    let mut wrapped_text = String::new();\n    let mut current_line = line_prefix.clone();\n\n    let tokenizer = WordBreakingTokenizer::new(&unwrapped_text);\n    let mut current_line_len = line_prefix_len;\n    let mut in_whitespace = false;\n    for token in tokenizer {\n        let have_preceding_whitespace = in_whitespace;\n        match token {\n            WordBreakToken::Word {\n                token,\n                grapheme_len,\n            } => {\n                in_whitespace = false;\n                if current_line_len + grapheme_len > wrap_column\n                    && current_line_len != line_prefix_len\n                {\n                    wrapped_text.push_str(current_line.trim_end());\n                    wrapped_text.push('\\n');\n                    current_line.truncate(line_prefix.len());\n                    current_line_len = line_prefix_len;\n                }\n                current_line.push_str(token);\n                current_line_len += grapheme_len;\n            }\n            WordBreakToken::InlineWhitespace {\n                mut token,\n                mut grapheme_len,\n            } => {\n                in_whitespace = true;\n                if have_preceding_whitespace && !preserve_existing_whitespace {\n                    continue;\n                }\n                if !preserve_existing_whitespace {\n                    token = ": "",
    ";\n                    grapheme_len = 1;\n                }\n                if current_line_len + grapheme_len > wrap_column {\n                    wrapped_text.push_str(current_line.trim_end());\n                    wrapped_text.push('\\n');\n                    current_line.truncate(line_prefix.len());\n                    current_line_len = line_prefix_len;\n                } else if current_line_len != line_prefix_len || preserve_existing_whitespace {\n                    current_line.push_str(token);\n                    current_line_len += grapheme_len;\n                }\n            }\n            WordBreakToken::Newline => {\n                in_whitespace = true;\n                if preserve_existing_whitespace {\n                    wrapped_text.push_str(current_line.trim_end());\n                    wrapped_text.push('\\n');\n                    current_line.truncate(line_prefix.len());\n                    current_line_len = line_prefix_len;\n                } else if have_preceding_whitespace {\n                    continue;\n                } else if current_line_len + 1 > wrap_column && current_line_len != line_prefix_len\n                {\n                    wrapped_text.push_str(current_line.trim_end());\n                    wrapped_text.push('\\n');\n                    current_line.truncate(line_prefix.len());\n                    current_line_len = line_prefix_len;\n                } else if current_line_len != line_prefix_len {\n                    current_line.push(' ');\n                    current_line_len += 1;\n                }\n            }\n        }\n    }\n\n    if !current_line.is_empty() {\n        wrapped_text.push_str(&current_line);\n    }\n    wrapped_text\n}\n\n#[test]\nfn test_wrap_with_prefix() {\n    assert_eq!(\n        wrap_with_prefix(\n            ": "",
    ".to_string(),\n            ": "",
    ".to_string(),\n            4,\n            NonZeroU32::new(4).unwrap(),\n            false,\n        ),\n        ": "",
    "\n    );\n    assert_eq!(\n        wrap_with_prefix(\n            ": "",
    ".to_string(),\n            8,\n            NonZeroU32::new(4).unwrap(),\n            false,\n        ),\n        ": "",
    ".to_string(),\n            12,\n            NonZeroU32::new(4).unwrap(),\n            false,\n        ),\n        ": "",
    "\n    );\n    assert_eq!(\n        wrap_with_prefix(\n            String::new(),\n            ": "",
    ".to_string(),\n            3,\n            NonZeroU32::new(4).unwrap(),\n            false,\n        ),\n        ": "",
    "\n    );\n}\n\npub trait CollaborationHub {\n    fn collaborators<'a>(&self, cx: &'a App) -> &'a HashMap<PeerId, Collaborator>;\n    fn user_participant_indices<'a>(&self, cx: &'a App) -> &'a HashMap<u64, ParticipantIndex>;\n    fn user_names(&self, cx: &App) -> HashMap<u64, SharedString>;\n}\n\nimpl CollaborationHub for Entity<Project> {\n    fn collaborators<'a>(&self, cx: &'a App) -> &'a HashMap<PeerId, Collaborator> {\n        self.read(cx).collaborators()\n    }\n\n    fn user_participant_indices<'a>(&self, cx: &'a App) -> &'a HashMap<u64, ParticipantIndex> {\n        self.read(cx).user_store().read(cx).participant_indices()\n    }\n\n    fn user_names(&self, cx: &App) -> HashMap<u64, SharedString> {\n        let this = self.read(cx);\n        let user_ids = this.collaborators().values().map(|c| c.user_id);\n        this.user_store().read(cx).participant_names(user_ids, cx)\n    }\n}\n\npub trait SemanticsProvider {\n    fn hover(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Vec<project::Hover>>>;\n\n    fn inline_values(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        range: Range<text::Anchor>,\n        cx: &mut App,\n    ) -> Option<Task<anyhow::Result<Vec<InlayHint>>>>;\n\n    fn inlay_hints(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        range: Range<text::Anchor>,\n        cx: &mut App,\n    ) -> Option<Task<anyhow::Result<Vec<InlayHint>>>>;\n\n    fn resolve_inlay_hint(\n        &self,\n        hint: InlayHint,\n        buffer_handle: Entity<Buffer>,\n        server_id: LanguageServerId,\n        cx: &mut App,\n    ) -> Option<Task<anyhow::Result<InlayHint>>>;\n\n    fn supports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &mut App) -> bool;\n\n    fn document_highlights(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Result<Vec<DocumentHighlight>>>>;\n\n    fn definitions(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        kind: GotoDefinitionKind,\n        cx: &mut App,\n    ) -> Option<Task<Result<Vec<LocationLink>>>>;\n\n    fn range_for_rename(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Result<Option<Range<text::Anchor>>>>>;\n\n    fn perform_rename(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        new_name: String,\n        cx: &mut App,\n    ) -> Option<Task<Result<ProjectTransaction>>>;\n\n    fn pull_diagnostics_for_buffer(\n        &self,\n        buffer: Entity<Buffer>,\n        cx: &mut App,\n    ) -> Task<anyhow::Result<()>>;\n}\n\npub trait CompletionProvider {\n    fn completions(\n        &self,\n        excerpt_id: ExcerptId,\n        buffer: &Entity<Buffer>,\n        buffer_position: text::Anchor,\n        trigger: CompletionContext,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<Vec<CompletionResponse>>>;\n\n    fn resolve_completions(\n        &self,\n        _buffer: Entity<Buffer>,\n        _completion_indices: Vec<usize>,\n        _completions: Rc<RefCell<Box<[Completion]>>>,\n        _cx: &mut Context<Editor>,\n    ) -> Task<Result<bool>> {\n        Task::ready(Ok(false))\n    }\n\n    fn apply_additional_edits_for_completion(\n        &self,\n        _buffer: Entity<Buffer>,\n        _completions: Rc<RefCell<Box<[Completion]>>>,\n        _completion_index: usize,\n        _push_to_history: bool,\n        _cx: &mut Context<Editor>,\n    ) -> Task<Result<Option<language::Transaction>>> {\n        Task::ready(Ok(None))\n    }\n\n    fn is_completion_trigger(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: language::Anchor,\n        text: &str,\n        trigger_in_words: bool,\n        menu_is_open: bool,\n        cx: &mut Context<Editor>,\n    ) -> bool;\n\n    fn selection_changed(&self, _mat: Option<&StringMatch>, _window: &mut Window, _cx: &mut App) {}\n\n    fn sort_completions(&self) -> bool {\n        true\n    }\n\n    fn filter_completions(&self) -> bool {\n        true\n    }\n}\n\npub trait CodeActionProvider {\n    fn id(&self) -> Arc<str>;\n\n    fn code_actions(\n        &self,\n        buffer: &Entity<Buffer>,\n        range: Range<text::Anchor>,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Task<Result<Vec<CodeAction>>>;\n\n    fn apply_code_action(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        action: CodeAction,\n        excerpt_id: ExcerptId,\n        push_to_history: bool,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Task<Result<ProjectTransaction>>;\n}\n\nimpl CodeActionProvider for Entity<Project> {\n    fn id(&self) -> Arc<str> {\n        ": "",
    ".into()\n    }\n\n    fn code_actions(\n        &self,\n        buffer: &Entity<Buffer>,\n        range: Range<text::Anchor>,\n        _window: &mut Window,\n        cx: &mut App,\n    ) -> Task<Result<Vec<CodeAction>>> {\n        self.update(cx, |project, cx| {\n            let code_lens = project.code_lens(buffer, range.clone(), cx);\n            let code_actions = project.code_actions(buffer, range, None, cx);\n            cx.background_spawn(async move {\n                let (code_lens, code_actions) = join(code_lens, code_actions).await;\n                Ok(code_lens\n                    .context(": "",
    ")?\n                    .into_iter()\n                    .chain(code_actions.context(": "",
    ")?)\n                    .collect())\n            })\n        })\n    }\n\n    fn apply_code_action(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        action: CodeAction,\n        _excerpt_id: ExcerptId,\n        push_to_history: bool,\n        _window: &mut Window,\n        cx: &mut App,\n    ) -> Task<Result<ProjectTransaction>> {\n        self.update(cx, |project, cx| {\n            project.apply_code_action(buffer_handle, action, push_to_history, cx)\n        })\n    }\n}\n\nfn snippet_completions(\n    project: &Project,\n    buffer: &Entity<Buffer>,\n    buffer_position: text::Anchor,\n    cx: &mut App,\n) -> Task<Result<CompletionResponse>> {\n    let languages = buffer.read(cx).languages_at(buffer_position);\n    let snippet_store = project.snippets().read(cx);\n\n    let scopes: Vec<_> = languages\n        .iter()\n        .filter_map(|language| {\n            let language_name = language.lsp_id();\n            let snippets = snippet_store.snippets_for(Some(language_name), cx);\n\n            if snippets.is_empty() {\n                None\n            } else {\n                Some((language.default_scope(), snippets))\n            }\n        })\n        .collect();\n\n    if scopes.is_empty() {\n        return Task::ready(Ok(CompletionResponse {\n            completions: vec![],\n            is_incomplete: false,\n        }));\n    }\n\n    let snapshot = buffer.read(cx).text_snapshot();\n    let chars: String = snapshot\n        .reversed_chars_for_range(text::Anchor::MIN..buffer_position)\n        .collect();\n    let executor = cx.background_executor().clone();\n\n    cx.background_spawn(async move {\n        let mut is_incomplete = false;\n        let mut completions: Vec<Completion> = Vec::new();\n        for (scope, snippets) in scopes.into_iter() {\n            let classifier = CharClassifier::new(Some(scope)).for_completion(true);\n            let mut last_word = chars\n                .chars()\n                .take_while(|c| classifier.is_word(*c))\n                .collect::<String>();\n            last_word = last_word.chars().rev().collect();\n\n            if last_word.is_empty() {\n                return Ok(CompletionResponse {\n                    completions: vec![],\n                    is_incomplete: true,\n                });\n            }\n\n            let as_offset = text::ToOffset::to_offset(&buffer_position, &snapshot);\n            let to_lsp = |point: &text::Anchor| {\n                let end = text::ToPointUtf16::to_point_utf16(point, &snapshot);\n                point_to_lsp(end)\n            };\n            let lsp_end = to_lsp(&buffer_position);\n\n            let candidates = snippets\n                .iter()\n                .enumerate()\n                .flat_map(|(ix, snippet)| {\n                    snippet\n                        .prefix\n                        .iter()\n                        .map(move |prefix| StringMatchCandidate::new(ix, &prefix))\n                })\n                .collect::<Vec<StringMatchCandidate>>();\n\n            const MAX_RESULTS: usize = 100;\n            let mut matches = fuzzy::match_strings(\n                &candidates,\n                &last_word,\n                last_word.chars().any(|c| c.is_uppercase()),\n                MAX_RESULTS,\n                &Default::default(),\n                executor.clone(),\n            )\n            .await;\n\n            if matches.len() >= MAX_RESULTS {\n                is_incomplete = true;\n            }\n\n            // Remove all candidates where the query's start does not match the start of any word in the candidate\n            if let Some(query_start) = last_word.chars().next() {\n                matches.retain(|string_match| {\n                    split_words(&string_match.string).any(|word| {\n                        // Check that the first codepoint of the word as lowercase matches the first\n                        // codepoint of the query as lowercase\n                        word.chars()\n                            .flat_map(|codepoint| codepoint.to_lowercase())\n                            .zip(query_start.to_lowercase())\n                            .all(|(word_cp, query_cp)| word_cp == query_cp)\n                    })\n                });\n            }\n\n            let matched_strings = matches\n                .into_iter()\n                .map(|m| m.string)\n                .collect::<HashSet<_>>();\n\n            completions.extend(snippets.iter().filter_map(|snippet| {\n                let matching_prefix = snippet\n                    .prefix\n                    .iter()\n                    .find(|prefix| matched_strings.contains(*prefix))?;\n                let start = as_offset - last_word.len();\n                let start = snapshot.anchor_before(start);\n                let range = start..buffer_position;\n                let lsp_start = to_lsp(&start);\n                let lsp_range = lsp::Range {\n                    start: lsp_start,\n                    end: lsp_end,\n                };\n                Some(Completion {\n                    replace_range: range,\n                    new_text: snippet.body.clone(),\n                    source: CompletionSource::Lsp {\n                        insert_range: None,\n                        server_id: LanguageServerId(usize::MAX),\n                        resolved: true,\n                        lsp_completion: Box::new(lsp::CompletionItem {\n                            label: snippet.prefix.first().unwrap().clone(),\n                            kind: Some(CompletionItemKind::SNIPPET),\n                            label_details: snippet.description.as_ref().map(|description| {\n                                lsp::CompletionItemLabelDetails {\n                                    detail: Some(description.clone()),\n                                    description: None,\n                                }\n                            }),\n                            insert_text_format: Some(InsertTextFormat::SNIPPET),\n                            text_edit: Some(lsp::CompletionTextEdit::InsertAndReplace(\n                                lsp::InsertReplaceEdit {\n                                    new_text: snippet.body.clone(),\n                                    insert: lsp_range,\n                                    replace: lsp_range,\n                                },\n                            )),\n                            filter_text: Some(snippet.body.clone()),\n                            sort_text: Some(char::MAX.to_string()),\n                            ..lsp::CompletionItem::default()\n                        }),\n                        lsp_defaults: None,\n                    },\n                    label: CodeLabel {\n                        text: matching_prefix.clone(),\n                        runs: Vec::new(),\n                        filter_range: 0..matching_prefix.len(),\n                    },\n                    icon_path: None,\n                    documentation: Some(CompletionDocumentation::SingleLineAndMultiLinePlainText {\n                        single_line: snippet.name.clone().into(),\n                        plain_text: snippet\n                            .description\n                            .clone()\n                            .map(|description| description.into()),\n                    }),\n                    insert_text_mode: None,\n                    confirm: None,\n                })\n            }))\n        }\n\n        Ok(CompletionResponse {\n            completions,\n            is_incomplete,\n        })\n    })\n}\n\nimpl CompletionProvider for Entity<Project> {\n    fn completions(\n        &self,\n        _excerpt_id: ExcerptId,\n        buffer: &Entity<Buffer>,\n        buffer_position: text::Anchor,\n        options: CompletionContext,\n        _window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<Vec<CompletionResponse>>> {\n        self.update(cx, |project, cx| {\n            let snippets = snippet_completions(project, buffer, buffer_position, cx);\n            let project_completions = project.completions(buffer, buffer_position, options, cx);\n            cx.background_spawn(async move {\n                let mut responses = project_completions.await?;\n                let snippets = snippets.await?;\n                if !snippets.completions.is_empty() {\n                    responses.push(snippets);\n                }\n                Ok(responses)\n            })\n        })\n    }\n\n    fn resolve_completions(\n        &self,\n        buffer: Entity<Buffer>,\n        completion_indices: Vec<usize>,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<bool>> {\n        self.update(cx, |project, cx| {\n            project.lsp_store().update(cx, |lsp_store, cx| {\n                lsp_store.resolve_completions(buffer, completion_indices, completions, cx)\n            })\n        })\n    }\n\n    fn apply_additional_edits_for_completion(\n        &self,\n        buffer: Entity<Buffer>,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        push_to_history: bool,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<Option<language::Transaction>>> {\n        self.update(cx, |project, cx| {\n            project.lsp_store().update(cx, |lsp_store, cx| {\n                lsp_store.apply_additional_edits_for_completion(\n                    buffer,\n                    completions,\n                    completion_index,\n                    push_to_history,\n                    cx,\n                )\n            })\n        })\n    }\n\n    fn is_completion_trigger(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: language::Anchor,\n        text: &str,\n        trigger_in_words: bool,\n        menu_is_open: bool,\n        cx: &mut Context<Editor>,\n    ) -> bool {\n        let mut chars = text.chars();\n        let char = if let Some(char) = chars.next() {\n            char\n        } else {\n            return false;\n        };\n        if chars.next().is_some() {\n            return false;\n        }\n\n        let buffer = buffer.read(cx);\n        let snapshot = buffer.snapshot();\n        if !menu_is_open && !snapshot.settings_at(position, cx).show_completions_on_input {\n            return false;\n        }\n        let classifier = snapshot.char_classifier_at(position).for_completion(true);\n        if trigger_in_words && classifier.is_word(char) {\n            return true;\n        }\n\n        buffer.completion_triggers().contains(text)\n    }\n}\n\nimpl SemanticsProvider for Entity<Project> {\n    fn hover(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Vec<project::Hover>>> {\n        Some(self.update(cx, |project, cx| project.hover(buffer, position, cx)))\n    }\n\n    fn document_highlights(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Result<Vec<DocumentHighlight>>>> {\n        Some(self.update(cx, |project, cx| {\n            project.document_highlights(buffer, position, cx)\n        }))\n    }\n\n    fn definitions(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        kind: GotoDefinitionKind,\n        cx: &mut App,\n    ) -> Option<Task<Result<Vec<LocationLink>>>> {\n        Some(self.update(cx, |project, cx| match kind {\n            GotoDefinitionKind::Symbol => project.definition(&buffer, position, cx),\n            GotoDefinitionKind::Declaration => project.declaration(&buffer, position, cx),\n            GotoDefinitionKind::Type => project.type_definition(&buffer, position, cx),\n            GotoDefinitionKind::Implementation => project.implementation(&buffer, position, cx),\n        }))\n    }\n\n    fn supports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &mut App) -> bool {\n        // TODO: make this work for remote projects\n        self.update(cx, |project, cx| {\n            if project\n                .active_debug_session(cx)\n                .is_some_and(|(session, _)| session.read(cx).any_stopped_thread())\n            {\n                return true;\n            }\n\n            buffer.update(cx, |buffer, cx| {\n                project.any_language_server_supports_inlay_hints(buffer, cx)\n            })\n        })\n    }\n\n    fn inline_values(\n        &self,\n        buffer_handle: Entity<Buffer>,\n\n        range: Range<text::Anchor>,\n        cx: &mut App,\n    ) -> Option<Task<anyhow::Result<Vec<InlayHint>>>> {\n        self.update(cx, |project, cx| {\n            let (session, active_stack_frame) = project.active_debug_session(cx)?;\n\n            Some(project.inline_values(session, active_stack_frame, buffer_handle, range, cx))\n        })\n    }\n\n    fn inlay_hints(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        range: Range<text::Anchor>,\n        cx: &mut App,\n    ) -> Option<Task<anyhow::Result<Vec<InlayHint>>>> {\n        Some(self.update(cx, |project, cx| {\n            project.inlay_hints(buffer_handle, range, cx)\n        }))\n    }\n\n    fn resolve_inlay_hint(\n        &self,\n        hint: InlayHint,\n        buffer_handle: Entity<Buffer>,\n        server_id: LanguageServerId,\n        cx: &mut App,\n    ) -> Option<Task<anyhow::Result<InlayHint>>> {\n        Some(self.update(cx, |project, cx| {\n            project.resolve_inlay_hint(hint, buffer_handle, server_id, cx)\n        }))\n    }\n\n    fn range_for_rename(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Result<Option<Range<text::Anchor>>>>> {\n        Some(self.update(cx, |project, cx| {\n            let buffer = buffer.clone();\n            let task = project.prepare_rename(buffer.clone(), position, cx);\n            cx.spawn(async move |_, cx| {\n                Ok(match task.await? {\n                    PrepareRenameResponse::Success(range) => Some(range),\n                    PrepareRenameResponse::InvalidPosition => None,\n                    PrepareRenameResponse::OnlyUnpreparedRenameSupported => {\n                        // Fallback on using TreeSitter info to determine identifier range\n                        buffer.read_with(cx, |buffer, _| {\n                            let snapshot = buffer.snapshot();\n                            let (range, kind) = snapshot.surrounding_word(position);\n                            if kind != Some(CharKind::Word) {\n                                return None;\n                            }\n                            Some(\n                                snapshot.anchor_before(range.start)\n                                    ..snapshot.anchor_after(range.end),\n                            )\n                        })?\n                    }\n                })\n            })\n        }))\n    }\n\n    fn perform_rename(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        new_name: String,\n        cx: &mut App,\n    ) -> Option<Task<Result<ProjectTransaction>>> {\n        Some(self.update(cx, |project, cx| {\n            project.perform_rename(buffer.clone(), position, new_name, cx)\n        }))\n    }\n\n    fn pull_diagnostics_for_buffer(\n        &self,\n        buffer: Entity<Buffer>,\n        cx: &mut App,\n    ) -> Task<anyhow::Result<()>> {\n        let diagnostics = self.update(cx, |project, cx| {\n            project\n                .lsp_store()\n                .update(cx, |lsp_store, cx| lsp_store.pull_diagnostics(buffer, cx))\n        });\n        let project = self.clone();\n        cx.spawn(async move |cx| {\n            let diagnostics = diagnostics.await.context(": "",
    ")?;\n            project.update(cx, |project, cx| {\n                project.lsp_store().update(cx, |lsp_store, cx| {\n                    for diagnostics_set in diagnostics {\n                        let LspPullDiagnostics::Response {\n                            server_id,\n                            uri,\n                            diagnostics,\n                        } = diagnostics_set\n                        else {\n                            continue;\n                        };\n\n                        let adapter = lsp_store.language_server_adapter_for_id(server_id);\n                        let disk_based_sources = adapter\n                            .as_ref()\n                            .map(|adapter| adapter.disk_based_diagnostic_sources.as_slice())\n                            .unwrap_or(&[]);\n                        match diagnostics {\n                            PulledDiagnostics::Unchanged { result_id } => {\n                                lsp_store\n                                    .merge_diagnostics(\n                                        server_id,\n                                        lsp::PublishDiagnosticsParams {\n                                            uri: uri.clone(),\n                                            diagnostics: Vec::new(),\n                                            version: None,\n                                        },\n                                        Some(result_id),\n                                        DiagnosticSourceKind::Pulled,\n                                        disk_based_sources,\n                                        |_, _| true,\n                                        cx,\n                                    )\n                                    .log_err();\n                            }\n                            PulledDiagnostics::Changed {\n                                diagnostics,\n                                result_id,\n                            } => {\n                                lsp_store\n                                    .merge_diagnostics(\n                                        server_id,\n                                        lsp::PublishDiagnosticsParams {\n                                            uri: uri.clone(),\n                                            diagnostics,\n                                            version: None,\n                                        },\n                                        result_id,\n                                        DiagnosticSourceKind::Pulled,\n                                        disk_based_sources,\n                                        |old_diagnostic, _| match old_diagnostic.source_kind {\n                                            DiagnosticSourceKind::Pulled => false,\n                                            DiagnosticSourceKind::Other\n                                            | DiagnosticSourceKind::Pushed => true,\n                                        },\n                                        cx,\n                                    )\n                                    .log_err();\n                            }\n                        }\n                    }\n                })\n            })\n        })\n    }\n}\n\nfn inlay_hint_settings(\n    location: Anchor,\n    snapshot: &MultiBufferSnapshot,\n    cx: &mut Context<Editor>,\n) -> InlayHintSettings {\n    let file = snapshot.file_at(location);\n    let language = snapshot.language_at(location).map(|l| l.name());\n    language_settings(language, file, cx).inlay_hints\n}\n\nfn consume_contiguous_rows(\n    contiguous_row_selections: &mut Vec<Selection<Point>>,\n    selection: &Selection<Point>,\n    display_map: &DisplaySnapshot,\n    selections: &mut Peekable<std::slice::Iter<Selection<Point>>>,\n) -> (MultiBufferRow, MultiBufferRow) {\n    contiguous_row_selections.push(selection.clone());\n    let start_row = MultiBufferRow(selection.start.row);\n    let mut end_row = ending_row(selection, display_map);\n\n    while let Some(next_selection) = selections.peek() {\n        if next_selection.start.row <= end_row.0 {\n            end_row = ending_row(next_selection, display_map);\n            contiguous_row_selections.push(selections.next().unwrap().clone());\n        } else {\n            break;\n        }\n    }\n    (start_row, end_row)\n}\n\nfn ending_row(next_selection: &Selection<Point>, display_map: &DisplaySnapshot) -> MultiBufferRow {\n    if next_selection.end.column > 0 || next_selection.is_empty() {\n        MultiBufferRow(display_map.next_line_boundary(next_selection.end).0.row + 1)\n    } else {\n        MultiBufferRow(next_selection.end.row)\n    }\n}\n\nimpl EditorSnapshot {\n    pub fn remote_selections_in_range<'a>(\n        &'a self,\n        range: &'a Range<Anchor>,\n        collaboration_hub: &dyn CollaborationHub,\n        cx: &'a App,\n    ) -> impl 'a + Iterator<Item = RemoteSelection> {\n        let participant_names = collaboration_hub.user_names(cx);\n        let participant_indices = collaboration_hub.user_participant_indices(cx);\n        let collaborators_by_peer_id = collaboration_hub.collaborators(cx);\n        let collaborators_by_replica_id = collaborators_by_peer_id\n            .values()\n            .map(|collaborator| (collaborator.replica_id, collaborator))\n            .collect::<HashMap<_, _>>();\n        self.buffer_snapshot\n            .selections_in_range(range, false)\n            .filter_map(move |(replica_id, line_mode, cursor_shape, selection)| {\n                if replica_id == AGENT_REPLICA_ID {\n                    Some(RemoteSelection {\n                        replica_id,\n                        selection,\n                        cursor_shape,\n                        line_mode,\n                        collaborator_id: CollaboratorId::Agent,\n                        user_name: Some(": "",
    ".into()),\n                        color: cx.theme().players().agent(),\n                    })\n                } else {\n                    let collaborator = collaborators_by_replica_id.get(&replica_id)?;\n                    let participant_index = participant_indices.get(&collaborator.user_id).copied();\n                    let user_name = participant_names.get(&collaborator.user_id).cloned();\n                    Some(RemoteSelection {\n                        replica_id,\n                        selection,\n                        cursor_shape,\n                        line_mode,\n                        collaborator_id: CollaboratorId::PeerId(collaborator.peer_id),\n                        user_name,\n                        color: if let Some(index) = participant_index {\n                            cx.theme().players().color_for_participant(index.0)\n                        } else {\n                            cx.theme().players().absent()\n                        },\n                    })\n                }\n            })\n    }\n\n    pub fn hunks_for_ranges(\n        &self,\n        ranges: impl IntoIterator<Item = Range<Point>>,\n    ) -> Vec<MultiBufferDiffHunk> {\n        let mut hunks = Vec::new();\n        let mut processed_buffer_rows: HashMap<BufferId, HashSet<Range<text::Anchor>>> =\n            HashMap::default();\n        for query_range in ranges {\n            let query_rows =\n                MultiBufferRow(query_range.start.row)..MultiBufferRow(query_range.end.row + 1);\n            for hunk in self.buffer_snapshot.diff_hunks_in_range(\n                Point::new(query_rows.start.0, 0)..Point::new(query_rows.end.0, 0),\n            ) {\n                // Include deleted hunks that are adjacent to the query range, because\n                // otherwise they would be missed.\n                let mut intersects_range = hunk.row_range.overlaps(&query_rows);\n                if hunk.status().is_deleted() {\n                    intersects_range |= hunk.row_range.start == query_rows.end;\n                    intersects_range |= hunk.row_range.end == query_rows.start;\n                }\n                if intersects_range {\n                    if !processed_buffer_rows\n                        .entry(hunk.buffer_id)\n                        .or_default()\n                        .insert(hunk.buffer_range.start..hunk.buffer_range.end)\n                    {\n                        continue;\n                    }\n                    hunks.push(hunk);\n                }\n            }\n        }\n\n        hunks\n    }\n\n    fn display_diff_hunks_for_rows<'a>(\n        &'a self,\n        display_rows: Range<DisplayRow>,\n        folded_buffers: &'a HashSet<BufferId>,\n    ) -> impl 'a + Iterator<Item = DisplayDiffHunk> {\n        let buffer_start = DisplayPoint::new(display_rows.start, 0).to_point(self);\n        let buffer_end = DisplayPoint::new(display_rows.end, 0).to_point(self);\n\n        self.buffer_snapshot\n            .diff_hunks_in_range(buffer_start..buffer_end)\n            .filter_map(|hunk| {\n                if folded_buffers.contains(&hunk.buffer_id) {\n                    return None;\n                }\n\n                let hunk_start_point = Point::new(hunk.row_range.start.0, 0);\n                let hunk_end_point = Point::new(hunk.row_range.end.0, 0);\n\n                let hunk_display_start = self.point_to_display_point(hunk_start_point, Bias::Left);\n                let hunk_display_end = self.point_to_display_point(hunk_end_point, Bias::Right);\n\n                let display_hunk = if hunk_display_start.column() != 0 {\n                    DisplayDiffHunk::Folded {\n                        display_row: hunk_display_start.row(),\n                    }\n                } else {\n                    let mut end_row = hunk_display_end.row();\n                    if hunk_display_end.column() > 0 {\n                        end_row.0 += 1;\n                    }\n                    let is_created_file = hunk.is_created_file();\n                    DisplayDiffHunk::Unfolded {\n                        status: hunk.status(),\n                        diff_base_byte_range: hunk.diff_base_byte_range,\n                        display_row_range: hunk_display_start.row()..end_row,\n                        multi_buffer_range: Anchor::range_in_buffer(\n                            hunk.excerpt_id,\n                            hunk.buffer_id,\n                            hunk.buffer_range,\n                        ),\n                        is_created_file,\n                    }\n                };\n\n                Some(display_hunk)\n            })\n    }\n\n    pub fn language_at<T: ToOffset>(&self, position: T) -> Option<&Arc<Language>> {\n        self.display_snapshot.buffer_snapshot.language_at(position)\n    }\n\n    pub fn is_focused(&self) -> bool {\n        self.is_focused\n    }\n\n    pub fn placeholder_text(&self) -> Option<&Arc<str>> {\n        self.placeholder_text.as_ref()\n    }\n\n    pub fn scroll_position(&self) -> gpui::Point<f32> {\n        self.scroll_anchor.scroll_position(&self.display_snapshot)\n    }\n\n    fn gutter_dimensions(\n        &self,\n        font_id: FontId,\n        font_size: Pixels,\n        max_line_number_width: Pixels,\n        cx: &App,\n    ) -> Option<GutterDimensions> {\n        if !self.show_gutter {\n            return None;\n        }\n\n        let ch_width = cx.text_system().ch_width(font_id, font_size).log_err()?;\n        let ch_advance = cx.text_system().ch_advance(font_id, font_size).log_err()?;\n\n        let show_git_gutter = self.show_git_diff_gutter.unwrap_or_else(|| {\n            matches!(\n                ProjectSettings::get_global(cx).git.git_gutter,\n                Some(GitGutterSetting::TrackedFiles)\n            )\n        });\n        let gutter_settings = EditorSettings::get_global(cx).gutter;\n        let show_line_numbers = self\n            .show_line_numbers\n            .unwrap_or(gutter_settings.line_numbers);\n        let line_gutter_width = if show_line_numbers {\n            // Avoid flicker-like gutter resizes when the line number gains another digit by\n            // only resizing the gutter on files with > 10**min_line_number_digits lines.\n            let min_width_for_number_on_gutter =\n                ch_advance * gutter_settings.min_line_number_digits as f32;\n            max_line_number_width.max(min_width_for_number_on_gutter)\n        } else {\n            0.0.into()\n        };\n\n        let show_runnables = self.show_runnables.unwrap_or(gutter_settings.runnables);\n        let show_breakpoints = self.show_breakpoints.unwrap_or(gutter_settings.breakpoints);\n\n        let git_blame_entries_width =\n            self.git_blame_gutter_max_author_length\n                .map(|max_author_length| {\n                    let renderer = cx.global::<GlobalBlameRenderer>().0.clone();\n                    const MAX_RELATIVE_TIMESTAMP: &str = ": "",
    ";\n\n                    /// The number of characters to dedicate to gaps and margins.\n                    const SPACING_WIDTH: usize = 4;\n\n                    let max_char_count = max_author_length.min(renderer.max_author_length())\n                        + ::git::SHORT_SHA_LENGTH\n                        + MAX_RELATIVE_TIMESTAMP.len()\n                        + SPACING_WIDTH;\n\n                    ch_advance * max_char_count\n                });\n\n        let is_singleton = self.buffer_snapshot.is_singleton();\n\n        let mut left_padding = git_blame_entries_width.unwrap_or(Pixels::ZERO);\n        left_padding += if !is_singleton {\n            ch_width * 4.0\n        } else if show_runnables || show_breakpoints {\n            ch_width * 3.0\n        } else if show_git_gutter && show_line_numbers {\n            ch_width * 2.0\n        } else if show_git_gutter || show_line_numbers {\n            ch_width\n        } else {\n            px(0.)\n        };\n\n        let shows_folds = is_singleton && gutter_settings.folds;\n\n        let right_padding = if shows_folds && show_line_numbers {\n            ch_width * 4.0\n        } else if shows_folds || (!is_singleton && show_line_numbers) {\n            ch_width * 3.0\n        } else if show_line_numbers {\n            ch_width\n        } else {\n            px(0.)\n        };\n\n        Some(GutterDimensions {\n            left_padding,\n            right_padding,\n            width: line_gutter_width + left_padding + right_padding,\n            margin: GutterDimensions::default_gutter_margin(font_id, font_size, cx),\n            git_blame_entries_width,\n        })\n    }\n\n    pub fn render_crease_toggle(\n        &self,\n        buffer_row: MultiBufferRow,\n        row_contains_cursor: bool,\n        editor: Entity<Editor>,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Option<AnyElement> {\n        let folded = self.is_line_folded(buffer_row);\n        let mut is_foldable = false;\n\n        if let Some(crease) = self\n            .crease_snapshot\n            .query_row(buffer_row, &self.buffer_snapshot)\n        {\n            is_foldable = true;\n            match crease {\n                Crease::Inline { render_toggle, .. } | Crease::Block { render_toggle, .. } => {\n                    if let Some(render_toggle) = render_toggle {\n                        let toggle_callback =\n                            Arc::new(move |folded, window: &mut Window, cx: &mut App| {\n                                if folded {\n                                    editor.update(cx, |editor, cx| {\n                                        editor.fold_at(buffer_row, window, cx)\n                                    });\n                                } else {\n                                    editor.update(cx, |editor, cx| {\n                                        editor.unfold_at(buffer_row, window, cx)\n                                    });\n                                }\n                            });\n                        return Some((render_toggle)(\n                            buffer_row,\n                            folded,\n                            toggle_callback,\n                            window,\n                            cx,\n                        ));\n                    }\n                }\n            }\n        }\n\n        is_foldable |= self.starts_indent(buffer_row);\n\n        if folded || (is_foldable && (row_contains_cursor || self.gutter_hovered)) {\n            Some(\n                Disclosure::new((": "",
    ", buffer_row.0), !folded)\n                    .toggle_state(folded)\n                    .on_click(window.listener_for(&editor, move |this, _e, window, cx| {\n                        if folded {\n                            this.unfold_at(buffer_row, window, cx);\n                        } else {\n                            this.fold_at(buffer_row, window, cx);\n                        }\n                    }))\n                    .into_any_element(),\n            )\n        } else {\n            None\n        }\n    }\n\n    pub fn render_crease_trailer(\n        &self,\n        buffer_row: MultiBufferRow,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Option<AnyElement> {\n        let folded = self.is_line_folded(buffer_row);\n        if let Crease::Inline { render_trailer, .. } = self\n            .crease_snapshot\n            .query_row(buffer_row, &self.buffer_snapshot)?\n        {\n            let render_trailer = render_trailer.as_ref()?;\n            Some(render_trailer(buffer_row, folded, window, cx))\n        } else {\n            None\n        }\n    }\n}\n\nimpl Deref for EditorSnapshot {\n    type Target = DisplaySnapshot;\n\n    fn deref(&self) -> &Self::Target {\n        &self.display_snapshot\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum EditorEvent {\n    InputIgnored {\n        text: Arc<str>,\n    },\n    InputHandled {\n        utf16_range_to_replace: Option<Range<isize>>,\n        text: Arc<str>,\n    },\n    ExcerptsAdded {\n        buffer: Entity<Buffer>,\n        predecessor: ExcerptId,\n        excerpts: Vec<(ExcerptId, ExcerptRange<language::Anchor>)>,\n    },\n    ExcerptsRemoved {\n        ids: Vec<ExcerptId>,\n        removed_buffer_ids: Vec<BufferId>,\n    },\n    BufferFoldToggled {\n        ids: Vec<ExcerptId>,\n        folded: bool,\n    },\n    ExcerptsEdited {\n        ids: Vec<ExcerptId>,\n    },\n    ExcerptsExpanded {\n        ids: Vec<ExcerptId>,\n    },\n    BufferEdited,\n    Edited {\n        transaction_id: clock::Lamport,\n    },\n    Reparsed(BufferId),\n    Focused,\n    FocusedIn,\n    Blurred,\n    DirtyChanged,\n    Saved,\n    TitleChanged,\n    DiffBaseChanged,\n    SelectionsChanged {\n        local: bool,\n    },\n    ScrollPositionChanged {\n        local: bool,\n        autoscroll: bool,\n    },\n    Closed,\n    TransactionUndone {\n        transaction_id: clock::Lamport,\n    },\n    TransactionBegun {\n        transaction_id: clock::Lamport,\n    },\n    Reloaded,\n    CursorShapeChanged,\n    PushedToNavHistory {\n        anchor: Anchor,\n        is_deactivate: bool,\n    },\n}\n\nimpl EventEmitter<EditorEvent> for Editor {}\n\nimpl Focusable for Editor {\n    fn focus_handle(&self, _cx: &App) -> FocusHandle {\n        self.focus_handle.clone()\n    }\n}\n\nimpl Render for Editor {\n    fn render(&mut self, _: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n        let settings = ThemeSettings::get_global(cx);\n\n        let mut text_style = match self.mode {\n            EditorMode::SingleLine { .. } | EditorMode::AutoHeight { .. } => TextStyle {\n                color: cx.theme().colors().editor_foreground,\n                font_family: settings.ui_font.family.clone(),\n                font_features: settings.ui_font.features.clone(),\n                font_fallbacks: settings.ui_font.fallbacks.clone(),\n                font_size: rems(0.875).into(),\n                font_weight: settings.ui_font.weight,\n                line_height: relative(settings.buffer_line_height.value()),\n                ..Default::default()\n            },\n            EditorMode::Full { .. } | EditorMode::Minimap { .. } => TextStyle {\n                color: cx.theme().colors().editor_foreground,\n                font_family: settings.buffer_font.family.clone(),\n                font_features: settings.buffer_font.features.clone(),\n                font_fallbacks: settings.buffer_font.fallbacks.clone(),\n                font_size: settings.buffer_font_size(cx).into(),\n                font_weight: settings.buffer_font.weight,\n                line_height: relative(settings.buffer_line_height.value()),\n                ..Default::default()\n            },\n        };\n        if let Some(text_style_refinement) = &self.text_style_refinement {\n            text_style.refine(text_style_refinement)\n        }\n\n        let background = match self.mode {\n            EditorMode::SingleLine { .. } => cx.theme().system().transparent,\n            EditorMode::AutoHeight { max_lines: _ } => cx.theme().system().transparent,\n            EditorMode::Full { .. } => cx.theme().colors().editor_background,\n            EditorMode::Minimap { .. } => cx.theme().colors().editor_background.opacity(0.7),\n        };\n\n        EditorElement::new(\n            &cx.entity(),\n            EditorStyle {\n                background,\n                local_player: cx.theme().players().local(),\n                text: text_style,\n                scrollbar_width: EditorElement::SCROLLBAR_WIDTH,\n                syntax: cx.theme().syntax().clone(),\n                status: cx.theme().status().clone(),\n                inlay_hints_style: make_inlay_hints_style(cx),\n                inline_completion_styles: make_suggestion_styles(cx),\n                unnecessary_code_fade: ThemeSettings::get_global(cx).unnecessary_code_fade,\n                show_underlines: !self.mode.is_minimap(),\n            },\n        )\n    }\n}\n\nimpl EntityInputHandler for Editor {\n    fn text_for_range(\n        &mut self,\n        range_utf16: Range<usize>,\n        adjusted_range: &mut Option<Range<usize>>,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<String> {\n        let snapshot = self.buffer.read(cx).read(cx);\n        let start = snapshot.clip_offset_utf16(OffsetUtf16(range_utf16.start), Bias::Left);\n        let end = snapshot.clip_offset_utf16(OffsetUtf16(range_utf16.end), Bias::Right);\n        if (start.0..end.0) != range_utf16 {\n            adjusted_range.replace(start.0..end.0);\n        }\n        Some(snapshot.text_for_range(start..end).collect())\n    }\n\n    fn selected_text_range(\n        &mut self,\n        ignore_disabled_input: bool,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<UTF16Selection> {\n        // Prevent the IME menu from appearing when holding down an alphabetic key\n        // while input is disabled.\n        if !ignore_disabled_input && !self.input_enabled {\n            return None;\n        }\n\n        let selection = self.selections.newest::<OffsetUtf16>(cx);\n        let range = selection.range();\n\n        Some(UTF16Selection {\n            range: range.start.0..range.end.0,\n            reversed: selection.reversed,\n        })\n    }\n\n    fn marked_text_range(&self, _: &mut Window, cx: &mut Context<Self>) -> Option<Range<usize>> {\n        let snapshot = self.buffer.read(cx).read(cx);\n        let range = self.text_highlights::<InputComposition>(cx)?.1.first()?;\n        Some(range.start.to_offset_utf16(&snapshot).0..range.end.to_offset_utf16(&snapshot).0)\n    }\n\n    fn unmark_text(&mut self, _: &mut Window, cx: &mut Context<Self>) {\n        self.clear_highlights::<InputComposition>(cx);\n        self.ime_transaction.take();\n    }\n\n    fn replace_text_in_range(\n        &mut self,\n        range_utf16: Option<Range<usize>>,\n        text: &str,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.input_enabled {\n            cx.emit(EditorEvent::InputIgnored { text: text.into() });\n            return;\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            let new_selected_ranges = if let Some(range_utf16) = range_utf16 {\n                let range_utf16 = OffsetUtf16(range_utf16.start)..OffsetUtf16(range_utf16.end);\n                Some(this.selection_replacement_ranges(range_utf16, cx))\n            } else {\n                this.marked_text_ranges(cx)\n            };\n\n            let range_to_replace = new_selected_ranges.as_ref().and_then(|ranges_to_replace| {\n                let newest_selection_id = this.selections.newest_anchor().id;\n                this.selections\n                    .all::<OffsetUtf16>(cx)\n                    .iter()\n                    .zip(ranges_to_replace.iter())\n                    .find_map(|(selection, range)| {\n                        if selection.id == newest_selection_id {\n                            Some(\n                                (range.start.0 as isize - selection.head().0 as isize)\n                                    ..(range.end.0 as isize - selection.head().0 as isize),\n                            )\n                        } else {\n                            None\n                        }\n                    })\n            });\n\n            cx.emit(EditorEvent::InputHandled {\n                utf16_range_to_replace: range_to_replace,\n                text: text.into(),\n            });\n\n            if let Some(new_selected_ranges) = new_selected_ranges {\n                this.change_selections(None, window, cx, |selections| {\n                    selections.select_ranges(new_selected_ranges)\n                });\n                this.backspace(&Default::default(), window, cx);\n            }\n\n            this.handle_input(text, window, cx);\n        });\n\n        if let Some(transaction) = self.ime_transaction {\n            self.buffer.update(cx, |buffer, cx| {\n                buffer.group_until_transaction(transaction, cx);\n            });\n        }\n\n        self.unmark_text(window, cx);\n    }\n\n    fn replace_and_mark_text_in_range(\n        &mut self,\n        range_utf16: Option<Range<usize>>,\n        text: &str,\n        new_selected_range_utf16: Option<Range<usize>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.input_enabled {\n            return;\n        }\n\n        let transaction = self.transact(window, cx, |this, window, cx| {\n            let ranges_to_replace = if let Some(mut marked_ranges) = this.marked_text_ranges(cx) {\n                let snapshot = this.buffer.read(cx).read(cx);\n                if let Some(relative_range_utf16) = range_utf16.as_ref() {\n                    for marked_range in &mut marked_ranges {\n                        marked_range.end.0 = marked_range.start.0 + relative_range_utf16.end;\n                        marked_range.start.0 += relative_range_utf16.start;\n                        marked_range.start =\n                            snapshot.clip_offset_utf16(marked_range.start, Bias::Left);\n                        marked_range.end =\n                            snapshot.clip_offset_utf16(marked_range.end, Bias::Right);\n                    }\n                }\n                Some(marked_ranges)\n            } else if let Some(range_utf16) = range_utf16 {\n                let range_utf16 = OffsetUtf16(range_utf16.start)..OffsetUtf16(range_utf16.end);\n                Some(this.selection_replacement_ranges(range_utf16, cx))\n            } else {\n                None\n            };\n\n            let range_to_replace = ranges_to_replace.as_ref().and_then(|ranges_to_replace| {\n                let newest_selection_id = this.selections.newest_anchor().id;\n                this.selections\n                    .all::<OffsetUtf16>(cx)\n                    .iter()\n                    .zip(ranges_to_replace.iter())\n                    .find_map(|(selection, range)| {\n                        if selection.id == newest_selection_id {\n                            Some(\n                                (range.start.0 as isize - selection.head().0 as isize)\n                                    ..(range.end.0 as isize - selection.head().0 as isize),\n                            )\n                        } else {\n                            None\n                        }\n                    })\n            });\n\n            cx.emit(EditorEvent::InputHandled {\n                utf16_range_to_replace: range_to_replace,\n                text: text.into(),\n            });\n\n            if let Some(ranges) = ranges_to_replace {\n                this.change_selections(None, window, cx, |s| s.select_ranges(ranges));\n            }\n\n            let marked_ranges = {\n                let snapshot = this.buffer.read(cx).read(cx);\n                this.selections\n                    .disjoint_anchors()\n                    .iter()\n                    .map(|selection| {\n                        selection.start.bias_left(&snapshot)..selection.end.bias_right(&snapshot)\n                    })\n                    .collect::<Vec<_>>()\n            };\n\n            if text.is_empty() {\n                this.unmark_text(window, cx);\n            } else {\n                this.highlight_text::<InputComposition>(\n                    marked_ranges.clone(),\n                    HighlightStyle {\n                        underline: Some(UnderlineStyle {\n                            thickness: px(1.),\n                            color: None,\n                            wavy: false,\n                        }),\n                        ..Default::default()\n                    },\n                    cx,\n                );\n            }\n\n            // Disable auto-closing when composing text (i.e. typing a `": "",
    "Message to log when a breakpoint is hit. Expressions within {} are interpolated.": "",
    "Condition when a breakpoint is hit. Expressions within {} are interpolated.": "",
    "How many breakpoint hits to ignore": "",
    "A multi buffer in breakpoint prompt isn't possible": "",
    "Conflict with Accept Keybinding": "",
    "Your keymap currently overrides the default accept keybinding. To continue, assign one keybinding for the `editor::AcceptEditPrediction` action.": "",
    "open-keymap": "",
    "Assign Keybinding": "",
    "see-docs": "",
    "See Docs": "",
    "https://zed.dev/docs/completions#edit-predictions-missing-keybinding": "",
    "stage": "",
    "Stage": "",
    "Stage Hunk": "",
    "unstage": "",
    "Unstage": "",
    "Unstage Hunk": "",
    "restore": "",
    "Restore": "",
    "Restore Hunk": "",
    "next-hunk": "",
    "Next Hunk": "",
    "prev-hunk": "",
    "Previous Hunk": ""
  },
  "zed/crates/editor/src/element.rs": {
    "drag state can never be in ready state after drag": "",
    "macos": "",
    "linux": "",
    "freebsd": "",
    "diagnostic": "",
    "expand": "",
    "Expand Excerpt": "",
    "{number}": "",
    "": "",
    "toggle-buffer-fold": "",
    "Toggle Excerpt Fold": "",
    "path header block": "",
    "untitled": "",
    "jump-to-file-button": "",
    "Jump To File": "",
    "Visible context menu should always render.": "",
    "crease_toggles": "",
    "expand_toggles": "",
    "crease_trailers": "",
    "minimap": "",
    " ": "",
    "Text": "",
    "Element": "",
    "size": "",
    "len": "",
    "⋯": "",
    "\\n": "",
    "you can't prepaint LineWithInvisibles twice": "",
    "modified diff status for row info": "",
    "blocks": "",
    "→": "",
    "•": "",
    "hello": "",
    "1": "",
    "\\t \\t|\\t| a b": "",
    "Hardcoded expected invisibles differ from the actual ones in '{input_text}'": "",
    "\\t\\t\\t| | a b": "",
    "For editor mode {editor_mode_without_invisibles:?} no invisibles was expected but got {invisibles:?}": "",
    "a\\tbcd     ": "",
    "Expected invisibles: {expected_invisibles:?}": "",
    "At index {i}, expected invisible {expected_invisible:?} does not match actual {actual_invisible:?} by kind. Actual invisibles: {actual_invisibles:?}": "",
    "Unexpected extra invisible {actual_invisible:?} at index {i}": "",
    "Missing expected invisibles after index {i}: {missing_expected_invisibles:?}": "",
    "Creating editor with mode {editor_mode:?}, width {}px and text '{input_text}'": ""
  },
  "zed/crates/editor/src/git.rs": {},
  "zed/crates/editor/src/hover_links.rs": {
    ".{suffix}": "",
    "{candidate_file_path}.{suffix}": "",
    "' || ch == '\\'') && !inside_quotes {\n            found_start = true;\n            inside_quotes = true;\n            break;\n        }\n\n        filename.push(ch);\n        token_start -= ch.len_utf8();\n    }\n    if !found_start && token_start != 0 {\n        return None;\n    }\n\n    filename = filename.chars().rev().collect();\n\n    let mut forwards = snapshot\n        .chars_at(offset)\n        .take(LIMIT - (offset - token_start))\n        .peekable();\n    while let Some(ch) = forwards.next() {\n        // Skip escaped whitespace\n        if ch == '\\\\' && forwards.peek().map_or(false, |ch| ch.is_whitespace()) {\n            token_end += ch.len_utf8();\n            let whitespace = forwards.next().unwrap();\n            token_end += whitespace.len_utf8();\n            filename.push(whitespace);\n            continue;\n        }\n\n        if ch.is_whitespace() {\n            found_end = true;\n            break;\n        }\n        if ch == '": "",
    "\n            struct A;\n            let vˇariable = A;\n        ": "",
    "\n            struct A;\n            let «variable» = A;\n        ": "",
    "\n            struct «A»;\n            let variable = A;\n        ": "",
    "macos": "",
    "\n            struct A;\n            let variable = A;\n        ": "",
    "\n            struct «Aˇ»;\n            let variable = A;\n        ": "",
    "\n                fn ˇtest() { do_work(); }\n                fn do_work() { test(); }\n            ": "",
    "\n                fn test() { do_wˇork(); }\n                fn do_work() { test(); }\n            ": "",
    "\n                fn test() { «do_work»(); }\n                fn do_work() { test(); }\n            ": "",
    "\n                fn test() { do_work(); }\n                fn «do_work»() { test(); }\n            ": "",
    "\n                fn test() { do_work(); }\n                fn do_work() { test(); }\n            ": "",
    "\n                fˇn test() { do_work(); }\n                fn do_work() { test(); }\n            ": "",
    "\n                fn test() { do_work(); }\n                fn do_work() { teˇst(); }\n            ": "",
    "\n                fn test() { do_work(); }\n                fn do_work() { «test»(); }\n            ": "",
    "\n                fn «test»() { do_work(); }\n                fn do_work() { test(); }\n            ": "",
    "\n                fn test() { do_work(); }\n                fn do_work() { tesˇt(); }\n            ": "",
    "\n                fn «testˇ»() { do_work(); }\n                fn do_work() { test(); }\n            ": "",
    "\n                fn test() { do_work(); }\n                fn «do_workˇ»() { test(); }\n            ": "",
    "\n                fn «test() { do_w»ork(); }\n                fn do_work() { test(); }\n            ": "",
    "\n                struct TestStruct;\n\n                fn main() {\n                    let variableˇ = TestStruct;\n                }\n            ": "",
    "\n                struct «TestStruct»;\n\n                fn main() {\n                    let variable = TestStruct;\n                }\n            ": "",
    ": TestStruct": "",
    "\n                struct TestStruct;\n\n                fn main() {\n                    let variable« »= TestStruct;\n                }\n            ": "",
    "When no cmd is pressed, should have no hint label selected, but got: {actual_ranges:?}": "",
    "\n                struct «TestStructˇ»;\n\n                fn main() {\n                    let variable = TestStruct;\n                }\n            ": "",
    "\n            Let's test a [complex](https://zed.dev/channel/had-(oops)) caseˇ.\n        ": "",
    "\n            Let's test a [complex](https://zed.dev/channel/had-(ˇoops)) case.\n            ": "",
    "\n            Let's test a [complex](«https://zed.dev/channel/had-(oops)ˇ») case.\n        ": "",
    "https://zed.dev/channel/had-(oops)": "",
    "https://zed.dev/releases is a cool ˇwebpage.": "",
    "https://zed.dev/relˇeases is a cool webpage.": "",
    "«https://zed.dev/releasesˇ» is a cool webpage.": "",
    "https://zed.dev/releases": "",
    "A cool ˇwebpage is https://zed.dev/releases": "",
    "A cool webpage is https://zed.dev/releˇases": "",
    "A cool webpage is «https://zed.dev/releasesˇ»": "",
    "file ˇ name": "",
    "ˇfile name": "",
    "file": "",
    "file ˇname": "",
    "name": "",
    "fiˇle name": "",
    "filenˇame": "",
    "filename": "",
    "foobar ˇ/home/user/f.txt": "",
    "/home/user/f.txt": "",
    "foobar /home/useˇr/f.txt": "",
    "C:\\\\Useˇrs\\\\user\\\\f.txt": "",
    "C:\\\\Users\\\\user\\\\f.txt": "",
    "ˇfile\\\\ -\\\\ name.txt": "",
    "file - name.txt": "",
    "file\\\\ -\\\\ naˇme.txt": "",
    "ˇ~/file.txt": "",
    "~/file.txt": "",
    "~/fiˇle.txt": "",
    "\\\"fˇile.txt\\\"": "",
    "file.txt": "",
    "ˇ\\\"file.txt\\\"": "",
    "ˇ\\\"fi\\\\ le.txt\\\"": "",
    "fi le.txt": "",
    "'fˇile.txt'": "",
    "ˇ'file.txt'": "",
    "ˇ'fi\\\\ le.txt'": "",
    "Failed to find file path: {}": "",
    "Incorrect file path for input: {}": "",
    "Expected no result, but got one: {:?}": "",
    "/root/dir/file2.rs": "",
    "This is file2.rs": "",
    "windows": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.ˇ\n            ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.ˇ\n        ": "",
    "\n            You can't go to a file that dˇoes_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that dˇoes_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to fˇile2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to fˇile2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to «file2.rsˇ» if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to «file2.rsˇ» if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/fˇile2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/fˇile2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to «../dir/file2.rsˇ» if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to «../dir/file2.rsˇ» if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/diˇr/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/diˇr/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to «/root/dir/file2.rsˇ» if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to «C:/root/dir/file2.rsˇ» if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/diˇr/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/diˇr/file2 if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to «/root/dir/file2ˇ» if this is a Rust file.\n        ": "",
    "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to «C:/root/dir/file2ˇ» if this is a Rust file.\n        ": "",
    "\n            You can't open ../diˇr because it's a directory.\n        ": ""
  },
  "zed/crates/editor/src/hover_popover.rs": {
    "no rendered diagnostic": "",
    "Unicode character U+{:02X}": "",
    "```{}\\n{}\\n```": "",
    "\\n\\n": "",
    "file": "",
    "info_popover": "",
    "info-md-container": "",
    "info-popover-vertical-scroll": "",
    "diagnostic": "",
    ".": "",
    ":": "",
    "\n                oneˇ\n                two\n                three\n                fn test() { println!(); }\n            ": "",
    "\n                        one.|<>\n                        two\n                        three\n                    ": "",
    "first_completion": "",
    "second_completion": "",
    "\n                one.\n                two\n                three\n                fn test() { printˇln!(); }\n            ": "",
    "\n                one.\n                two\n                three\n                fn test() { «println!»(); }\n            ": "",
    "some basic docs": "",
    "Expected exactly one hover but got: {:?}": "",
    "\n            one.second_completionˇ\n            two\n            three\n            fn test() { println!(); }\n        ": "",
    "\n                one.second_completionˇ\n                two\n                three\n                fn teˇst() { println!(); }\n            ": "",
    "\n            fn ˇtest() { println!(); }\n        ": "",
    "\n            fn test() { printˇln!(); }\n        ": "",
    "\n            fn test() { «println!»(); }\n        ": "",
    "\n            fn teˇst() { println!(); }\n        ": "",
    "\n            fˇn test() { println!(); }\n        ": "",
    "\n            «fn» test() { println!(); }\n        ": "",
    "Expected no hovers but got but got: {:?}": "",
    "some other basic docs": "",
    "regular text for hover to show": "",
    "": "",
    "Rust": "",
    "No empty string hovers should be shown": "",
    "\\nlet hovered_point: Vector2F // size = 8, align = 0x4\\n": "",
    "\\n```rust\\n{code_str}```": "",
    "Should not have extra line breaks at end of rendered hover": "",
    "\n            fn fuˇnc(abc def: i32) -> u32 {\n            }\n        ": "",
    "\n                    ### function `errands_data_read`\n\n                    ---\n                    → `char *`\n                    Function to read a file into a string\n\n                    ---\n                    ```cpp\n                    static char *errands_data_read()\n                    ```\n                    ": "",
    "Function to read a file": "",
    "\n            struct TestStruct;\n\n            // ==================\n\n            struct TestNewType<T>(T);\n\n            fn main() {\n                let variableˇ = TestNewType(TestStruct);\n            }\n        ": "",
    "\n            struct TestStruct;\n\n            // ==================\n\n            struct «TestNewType»<T>(T);\n\n            fn main() {\n                let variable = TestNewType(TestStruct);\n            }\n        ": "",
    "\n            struct «TestStruct»;\n\n            // ==================\n\n            struct TestNewType<T>(T);\n\n            fn main() {\n                let variable = TestNewType(TestStruct);\n            }\n        ": "",
    "TestNewType": "",
    "TestStruct": "",
    ": TestNewType<TestStruct>": "",
    "\n                struct TestStruct;\n\n                // ==================\n\n                struct TestNewType<T>(T);\n\n                fn main() {\n                    let variable« »= TestNewType(TestStruct);\n                }\n        ": "",
    "Hint {hint_to_resolve:?} was resolved twice": "",
    ": ": "",
    "A tooltip for `{new_type_label}`": "",
    "<": "",
    "A tooltip for `{struct_label}`": "",
    ">": "",
    "Popover range should match the new type label part": "",
    "A tooltip for {new_type_label}": "",
    "Popover range should match the struct label part": "",
    "A tooltip for {struct_label}": "",
    "Rendered markdown element should remove backticks from text": ""
  },
  "zed/crates/editor/src/indent_guides.rs": {},
  "zed/crates/editor/src/inlay_hint_cache.rs": {
    "https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_inlayHint": "",
    "https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_inlayHint_refresh": "",
    "Visible": "",
    "jumps": "",
    "https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#inlayHint_resolve": "",
    "hint resolve task": "",
    "inlay hint update task for range failed: {e:#?}": "",
    "Fetching inlay hints for range {fetch_range_to_log:?} got throttled and fell off the current visible range, skipping.": "",
    "Fetching inlay hints for range {fetch_range_to_log:?}, reason: {query_reason}, invalidate: {invalidate}": "",
    "Currently visible hints: {visible_hints:?}, cached hints present: {}": "",
    "inlay hint fetch task": "",
    "Fetched {} hints for range {fetch_range_to_log:?}": "",
    "Fetched hints: {new_hints:?}": "",
    "Applying update for range {fetch_range_to_log:?}: remove from editor: {}, remove from cache: {}, add to cache: {}": "",
    "New update: {new_update:?}": "",
    "1": "",
    "Should get its first hints when opening the editor": "",
    "Cache should use editor settings to get the allowed hint kinds": "",
    "some change": "",
    "2": "",
    "Should get new hints after an edit": "",
    "inlay refresh request failed": "",
    "3": "",
    "Should get new hints after hint refresh/ request": "",
    "0": "",
    "test_progress_token": "",
    "work done progress create request failed": "",
    "Should not update hints while the work task is running": "",
    "New hints should be queried after the work task is done": "",
    "/a": "",
    "main.rs": "",
    "fn main() { a } // and some long comment to ensure inlays are not trimmed out": "",
    "other.md": "",
    "Test md file with some text": "",
    "Rust": "",
    "rs": "",
    "Markdown": "",
    "md": "",
    "/a/main.rs": "",
    "/a/other.md": "",
    "Unexpected language: {unexpected}": "",
    "Markdown editor should have a separate version, repeating Rust editor rules": "",
    "some rs change": "",
    "Rust inlay cache should change after the edit": "",
    "Markdown editor should not be affected by Rust editor changes": "",
    "some md change": "",
    "Rust editor should not be affected by Markdown editor changes": "",
    "Markdown editor should also change independently": "",
    "type hint": "",
    "parameter hint": "",
    "other hint": "",
    "Should query new hints once": "",
    "Should load new hints twice": "",
    "Cached hints should not change due to allowed hint kinds settings update": "",
    "Should not load new hints on allowed hint kinds change for hint kinds {new_allowed_hint_kinds:?}": "",
    "Should get its cached hints unchanged after the settings change for hint kinds {new_allowed_hint_kinds:?}": "",
    "Should get its visible hints filtered after the settings change for hint kinds {new_allowed_hint_kinds:?}": "",
    "Cache should use editor settings to get the allowed hint kinds for hint kinds {new_allowed_hint_kinds:?}": "",
    "Should not load new hints when hints got disabled": "",
    "Should clear the cache when hints got disabled": "",
    "Should clear visible hints when hints got disabled": "",
    "Should update its allowed hint kinds even when hints got disabled": "",
    "Should not load new hints when they got disabled": "",
    "Should query for new hints when they got re-enabled": "",
    "Should get its cached hints fully repopulated after the hints got re-enabled": "",
    "Should get its visible hints repopulated and filtered after the h": "",
    "Cache should update editor settings when hints got re-enabled": "",
    "Should query for new hints again": "",
    "initial change #1": "",
    "initial change #2": "",
    "initial change #3": "",
    "Should apply all changes made": "",
    "Should query new hints twice: for editor init and for the last edit that interrupted all others": "",
    "Should get hints from the last edit landed only": "",
    "another change #1": "",
    "another change #2": "",
    "another change #3": "",
    "Should query new hints one more time, for the last edit only": "",
    "fn main() {{\\n{}\\n}}": "",
    "let i = 5;\\n": "",
    "other.rs": "",
    "// Test file": "",
    "When scroll is at the edge of a big document, its visible part and the same range further should be queried in order, but got: {ranges:?}": "",
    "Should initially query visible edge of the document": "",
    "Visible + invisible request": "",
    "47": "",
    "94": "",
    "Should have hints from both LSP requests made for a big file": "",
    "Should display only hints from the visible range": "",
    "Should query 2 ranges after both scrolls, but got: {ranges:?}": "",
    "Should query 2 adjacent ranges after the scrolls, but got: {ranges:?}": "",
    "First scroll should start the query right after the end of the original scroll": "",
    "Second scroll should query one more screen down after the end of the visible range": "",
    "Should query for hints after every scroll": "",
    "139": "",
    "184": "",
    "Should have hints from the new LSP response after the edit": "",
    "No new ranges or LSP queries should be made after returning to the selection with cached hints": "",
    "++++more text++++": "",
    "On edit, should scroll to selection and query a range around it: visible + same range above and below. Instead, got query ranges {ranges:?}": "",
    "Above range {above_query_range:?} should be before visible range {visible_query_range:?}": "",
    "Visible range {visible_query_range:?} should be before below range {below_query_range:?}": "",
    "Hints should be queried with the selected range after the query range start": "",
    "Hints should be queried with the selected range before the query range end": "",
    "Hints query range should contain one more screen before": "",
    "Hints query range should contain one more screen after": "",
    "There should be a visible range and two ranges above and below it queried": "",
    "67": "",
    "115": "",
    "163": "",
    "Single buffer should produce a single excerpt with visible range": "",
    "let i = {i};\\n": "",
    "": "",
    "let j = {j};\\n": "",
    "/a/other.rs": "",
    "main hint": "",
    "unexpected uri: {:?}": "",
    "out of excerpt range, should be ignored": "",
    "{hint_text}{E} #{i}": "",
    "(edited)": "",
    "main hint #0": "",
    "main hint #1": "",
    "main hint #2": "",
    "main hint #3": "",
    "main hint #4": "",
    "main hint #5": "",
    "When scroll is at the edge of a multibuffer, its visible excerpts only should be queried for inlay hints": "",
    "other hint #0": "",
    "other hint #1": "",
    "other hint #2": "",
    "With more scrolls of the multibuffer, more hints should be added into the cache and nothing invalidated without edits": "",
    "other hint #3": "",
    "other hint #4": "",
    "other hint #5": "",
    "After multibuffer was scrolled to the end, all hints for all excerpts should be fetched": "",
    "After multibuffer was scrolled to the end, further scrolls up should not bring more hints": "",
    "other hint(edited) #0": "",
    "other hint(edited) #1": "",
    "\n                );\n                assert_eq!(expected_hints, visible_hint_labels(editor, cx));\n            })\n            .unwrap();\n    }\n\n    #[gpui::test]\n    async fn test_excerpts_removed(cx: &mut gpui::TestAppContext) {\n        init_test(cx, |settings| {\n            settings.defaults.inlay_hints = Some(InlayHintSettings {\n                show_value_hints: true,\n                enabled: true,\n                edit_debounce_ms: 0,\n                scroll_debounce_ms: 0,\n                show_type_hints: false,\n                show_parameter_hints: false,\n                show_other_hints: false,\n                show_background: false,\n                toggle_on_modifiers_press: None,\n            })\n        });\n\n        let fs = FakeFs::new(cx.background_executor.clone());\n        fs.insert_tree(\n            path!(": "",
    "),\n            json!({\n                ": "",
    ": format!(": "",
    ", (0..501).map(|i| format!(": "",
    ")).collect::<Vec<_>>().join(": "",
    ")),\n                ": "",
    ", (0..501).map(|j| format!(": "",
    ")),\n            }),\n        )\n        .await;\n\n        let project = Project::test(fs, [path!(": "",
    ").as_ref()], cx).await;\n\n        let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n        language_registry.add(rust_lang());\n        let mut fake_servers = language_registry.register_fake_lsp(\n            ": "",
    ",\n            FakeLspAdapter {\n                capabilities: lsp::ServerCapabilities {\n                    inlay_hint_provider: Some(lsp::OneOf::Left(true)),\n                    ..Default::default()\n                },\n                ..Default::default()\n            },\n        );\n\n        let (buffer_1, _handle) = project\n            .update(cx, |project, cx| {\n                project.open_local_buffer_with_lsp(path!(": "",
    "), cx)\n            })\n            .await\n            .unwrap();\n        let (buffer_2, _handle2) = project\n            .update(cx, |project, cx| {\n                project.open_local_buffer_with_lsp(path!(": "",
    "), cx)\n            })\n            .await\n            .unwrap();\n        let multibuffer = cx.new(|_| MultiBuffer::new(Capability::ReadWrite));\n        let (buffer_1_excerpts, buffer_2_excerpts) = multibuffer.update(cx, |multibuffer, cx| {\n            let buffer_1_excerpts = multibuffer.push_excerpts(\n                buffer_1.clone(),\n                [ExcerptRange::new(Point::new(0, 0)..Point::new(2, 0))],\n                cx,\n            );\n            let buffer_2_excerpts = multibuffer.push_excerpts(\n                buffer_2.clone(),\n                [ExcerptRange::new(Point::new(0, 1)..Point::new(2, 1))],\n                cx,\n            );\n            (buffer_1_excerpts, buffer_2_excerpts)\n        });\n\n        assert!(!buffer_1_excerpts.is_empty());\n        assert!(!buffer_2_excerpts.is_empty());\n\n        cx.executor().run_until_parked();\n        let editor = cx.add_window(|window, cx| {\n            Editor::for_multibuffer(multibuffer, Some(project.clone()), window, cx)\n        });\n        let editor_edited = Arc::new(AtomicBool::new(false));\n        let fake_server = fake_servers.next().await.unwrap();\n        let closure_editor_edited = Arc::clone(&editor_edited);\n        fake_server\n            .set_request_handler::<lsp::request::InlayHintRequest, _, _>(move |params, _| {\n                let task_editor_edited = Arc::clone(&closure_editor_edited);\n                async move {\n                    let hint_text = if params.text_document.uri\n                        == lsp::Url::from_file_path(path!(": "",
    ")).unwrap()\n                    {\n                        ": "",
    "\n                    } else if params.text_document.uri\n                        == lsp::Url::from_file_path(path!(": "",
    "\n                    } else {\n                        panic!(": "",
    ", params.text_document.uri);\n                    };\n\n                    let positions = [\n                        lsp::Position::new(0, 2),\n                        lsp::Position::new(4, 2),\n                        lsp::Position::new(22, 2),\n                        lsp::Position::new(44, 2),\n                        lsp::Position::new(56, 2),\n                        lsp::Position::new(67, 2),\n                    ];\n                    let out_of_range_hint = lsp::InlayHint {\n                        position: lsp::Position::new(\n                            params.range.start.line + 99,\n                            params.range.start.character + 99,\n                        ),\n                        label: lsp::InlayHintLabel::String(\n                            ": "",
    ".to_string(),\n                        ),\n                        kind: None,\n                        text_edits: None,\n                        tooltip: None,\n                        padding_left: None,\n                        padding_right: None,\n                        data: None,\n                    };\n\n                    let edited = task_editor_edited.load(Ordering::Acquire);\n                    Ok(Some(\n                        std::iter::once(out_of_range_hint)\n                            .chain(positions.into_iter().enumerate().map(|(i, position)| {\n                                lsp::InlayHint {\n                                    position,\n                                    label: lsp::InlayHintLabel::String(format!(\n                                        ": "",
    ",\n                                        if edited { ": "",
    " } else { ": "",
    " },\n                                    )),\n                                    kind: None,\n                                    text_edits: None,\n                                    tooltip: None,\n                                    padding_left: None,\n                                    padding_right: None,\n                                    data: None,\n                                }\n                            }))\n                            .collect(),\n                    ))\n                }\n            })\n            .next()\n            .await;\n        cx.executor().run_until_parked();\n        editor\n            .update(cx, |editor, _, cx| {\n                assert_eq!(\n                    vec![": "",
    ".to_string(), ": "",
    ".to_string()],\n                    sorted_cached_hint_labels(editor),\n                    ": "",
    "\n                );\n                assert!(\n                visible_hint_labels(editor, cx).is_empty(),\n                ": "",
    "\n            );\n            })\n            .unwrap();\n\n        editor\n            .update(cx, |editor, _, cx| {\n                editor.buffer().update(cx, |multibuffer, cx| {\n                    multibuffer.remove_excerpts(buffer_2_excerpts, cx)\n                })\n            })\n            .unwrap();\n        cx.executor().run_until_parked();\n        editor\n            .update(cx, |editor, _, cx| {\n                assert_eq!(\n                    vec![": "",
    ".to_string()],\n                    cached_hint_labels(editor),\n                    ": "",
    "\n            );\n            })\n            .unwrap();\n\n        update_test_language_settings(cx, |settings| {\n            settings.defaults.inlay_hints = Some(InlayHintSettings {\n                show_value_hints: true,\n                enabled: true,\n                edit_debounce_ms: 0,\n                scroll_debounce_ms: 0,\n                show_type_hints: true,\n                show_parameter_hints: true,\n                show_other_hints: true,\n                show_background: false,\n                toggle_on_modifiers_press: None,\n            })\n        });\n        cx.executor().run_until_parked();\n        editor\n            .update(cx, |editor, _, cx| {\n                let expected_hints = vec![": "",
    ".to_string()];\n                assert_eq!(\n                    expected_hints,\n                    cached_hint_labels(editor),\n                    ": "",
    "\n                );\n                assert_eq!(\n                    expected_hints,\n                    visible_hint_labels(editor, cx),\n                    ": "",
    "\n                );\n            })\n            .unwrap();\n    }\n\n    #[gpui::test]\n    async fn test_inside_char_boundary_range_hints(cx: &mut gpui::TestAppContext) {\n        init_test(cx, |settings| {\n            settings.defaults.inlay_hints = Some(InlayHintSettings {\n                show_value_hints: true,\n                enabled: true,\n                edit_debounce_ms: 0,\n                scroll_debounce_ms: 0,\n                show_type_hints: true,\n                show_parameter_hints: true,\n                show_other_hints: true,\n                show_background: false,\n                toggle_on_modifiers_press: None,\n            })\n        });\n\n        let fs = FakeFs::new(cx.background_executor.clone());\n        fs.insert_tree(\n            path!(": "",
    ": format!(r#": "",
    "#, format!(": "",
    ", ": "",
    ".repeat(10)).repeat(500)),\n                ": "",
    ": ": "",
    ",\n            }),\n        )\n        .await;\n\n        let project = Project::test(fs, [path!(": "",
    ").as_ref()], cx).await;\n\n        let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n        language_registry.add(rust_lang());\n        language_registry.register_fake_lsp(\n            ": "",
    ",\n            FakeLspAdapter {\n                capabilities: lsp::ServerCapabilities {\n                    inlay_hint_provider: Some(lsp::OneOf::Left(true)),\n                    ..Default::default()\n                },\n                initializer: Some(Box::new(move |fake_server| {\n                    let lsp_request_count = Arc::new(AtomicU32::new(0));\n                    fake_server.set_request_handler::<lsp::request::InlayHintRequest, _, _>(\n                        move |params, _| {\n                            let i = lsp_request_count.fetch_add(1, Ordering::Release) + 1;\n                            async move {\n                                assert_eq!(\n                                    params.text_document.uri,\n                                    lsp::Url::from_file_path(path!(": "",
    ")).unwrap(),\n                                );\n                                let query_start = params.range.start;\n                                Ok(Some(vec![lsp::InlayHint {\n                                    position: query_start,\n                                    label: lsp::InlayHintLabel::String(i.to_string()),\n                                    kind: None,\n                                    text_edits: None,\n                                    tooltip: None,\n                                    padding_left: None,\n                                    padding_right: None,\n                                    data: None,\n                                }]))\n                            }\n                        },\n                    );\n                })),\n                ..Default::default()\n            },\n        );\n\n        let buffer = project\n            .update(cx, |project, cx| {\n                project.open_local_buffer(path!(": "",
    "), cx)\n            })\n            .await\n            .unwrap();\n        let editor =\n            cx.add_window(|window, cx| Editor::for_buffer(buffer, Some(project), window, cx));\n\n        cx.executor().run_until_parked();\n        editor\n            .update(cx, |editor, window, cx| {\n                editor.change_selections(None, window, cx, |s| {\n                    s.select_ranges([Point::new(10, 0)..Point::new(10, 0)])\n                })\n            })\n            .unwrap();\n        cx.executor().run_until_parked();\n        editor\n            .update(cx, |editor, _, cx| {\n                let expected_hints = vec![": "",
    ".to_string()];\n                assert_eq!(expected_hints, cached_hint_labels(editor));\n                assert_eq!(expected_hints, visible_hint_labels(editor, cx));\n            })\n            .unwrap();\n    }\n\n    #[gpui::test]\n    async fn test_toggle_inlay_hints(cx: &mut gpui::TestAppContext) {\n        init_test(cx, |settings| {\n            settings.defaults.inlay_hints = Some(InlayHintSettings {\n                show_value_hints: true,\n                enabled: false,\n                edit_debounce_ms: 0,\n                scroll_debounce_ms: 0,\n                show_type_hints: true,\n                show_parameter_hints: true,\n                show_other_hints: true,\n                show_background: false,\n                toggle_on_modifiers_press: None,\n            })\n        });\n\n        let (_, editor, _fake_server) = prepare_test_objects(cx, |fake_server, file_with_hints| {\n            let lsp_request_count = Arc::new(AtomicU32::new(0));\n            fake_server.set_request_handler::<lsp::request::InlayHintRequest, _, _>(\n                move |params, _| {\n                    let lsp_request_count = lsp_request_count.clone();\n                    async move {\n                        assert_eq!(\n                            params.text_document.uri,\n                            lsp::Url::from_file_path(file_with_hints).unwrap(),\n                        );\n\n                        let i = lsp_request_count.fetch_add(1, Ordering::SeqCst) + 1;\n                        Ok(Some(vec![lsp::InlayHint {\n                            position: lsp::Position::new(0, i),\n                            label: lsp::InlayHintLabel::String(i.to_string()),\n                            kind: None,\n                            text_edits: None,\n                            tooltip: None,\n                            padding_left: None,\n                            padding_right: None,\n                            data: None,\n                        }]))\n                    }\n                },\n            );\n        })\n        .await;\n\n        editor\n            .update(cx, |editor, window, cx| {\n                editor.toggle_inlay_hints(&crate::ToggleInlayHints, window, cx)\n            })\n            .unwrap();\n\n        cx.executor().run_until_parked();\n        editor\n            .update(cx, |editor, _, cx| {\n                let expected_hints = vec![": "",
    "\n                );\n                assert_eq!(expected_hints, visible_hint_labels(editor, cx));\n            })\n            .unwrap();\n\n        editor\n            .update(cx, |editor, window, cx| {\n                editor.toggle_inlay_hints(&crate::ToggleInlayHints, window, cx)\n            })\n            .unwrap();\n        cx.executor().run_until_parked();\n        editor\n            .update(cx, |editor, _, cx| {\n                assert!(\n                    cached_hint_labels(editor).is_empty(),\n                    ": "",
    "\n                );\n                assert!(visible_hint_labels(editor, cx).is_empty());\n            })\n            .unwrap();\n\n        update_test_language_settings(cx, |settings| {\n            settings.defaults.inlay_hints = Some(InlayHintSettings {\n                show_value_hints: true,\n                enabled: true,\n                edit_debounce_ms: 0,\n                scroll_debounce_ms: 0,\n                show_type_hints: true,\n                show_parameter_hints: true,\n                show_other_hints: true,\n                show_background: false,\n                toggle_on_modifiers_press: None,\n            })\n        });\n        cx.executor().run_until_parked();\n        editor\n            .update(cx, |editor, _, cx| {\n                let expected_hints = vec![": "",
    "\n                );\n                assert!(visible_hint_labels(editor, cx).is_empty());\n            })\n            .unwrap();\n\n        editor\n            .update(cx, |editor, window, cx| {\n                editor.toggle_inlay_hints(&crate::ToggleInlayHints, window, cx)\n            })\n            .unwrap();\n        cx.executor().run_until_parked();\n        editor.update(cx, |editor, _, cx| {\n            let expected_hints = vec![": "",
    ".to_string()];\n            assert_eq!(\n                expected_hints,\n                cached_hint_labels(editor),\n                ": "",
    "\n            );\n            assert_eq!(expected_hints, visible_hint_labels(editor, cx));\n        }).unwrap();\n    }\n\n    #[gpui::test]\n    async fn test_inlays_at_the_same_place(cx: &mut gpui::TestAppContext) {\n        init_test(cx, |settings| {\n            settings.defaults.inlay_hints = Some(InlayHintSettings {\n                show_value_hints: true,\n                enabled: true,\n                edit_debounce_ms: 0,\n                scroll_debounce_ms: 0,\n                show_type_hints: true,\n                show_parameter_hints: true,\n                show_other_hints: true,\n                show_background: false,\n                toggle_on_modifiers_press: None,\n            })\n        });\n\n        let fs = FakeFs::new(cx.background_executor.clone());\n        fs.insert_tree(\n            path!(": "",
    ",\n                ": "",
    ",\n            FakeLspAdapter {\n                capabilities: lsp::ServerCapabilities {\n                    inlay_hint_provider: Some(lsp::OneOf::Left(true)),\n                    ..Default::default()\n                },\n                initializer: Some(Box::new(move |fake_server| {\n                    fake_server.set_request_handler::<lsp::request::InlayHintRequest, _, _>(\n                        move |params, _| async move {\n                            assert_eq!(\n                                params.text_document.uri,\n                                lsp::Url::from_file_path(path!(": "",
    ")).unwrap(),\n                            );\n                            Ok(Some(\n                                serde_json::from_value(json!([\n                                    {\n                                        ": "",
    ": {\n                                            ": "",
    ": 3,\n                                            ": "",
    ": 16\n                                        },\n                                        ": "",
    ",\n                                        ": "",
    ": false,\n                                        ": "",
    ": false\n                                    },\n                                    {\n                                        ": "",
    ": [\n                                            {\n                                                ": "",
    "\n                                            }\n                                        ],\n                                        ": "",
    ": 0\n                                        }\n                                    },\n                                    {\n                                        ": "",
    ": true\n                                    },\n                                    // not a correct syntax, but checks that same symbols at the same place\n                                    // are not deduplicated\n                                    {\n                                        ": "",
    ": true\n                                    },\n                                ]))\n                                .unwrap(),\n                            ))\n                        },\n                    );\n                })),\n                ..FakeLspAdapter::default()\n            },\n        );\n\n        let buffer = project\n            .update(cx, |project, cx| {\n                project.open_local_buffer(path!(": "",
    "), cx)\n            })\n            .await\n            .unwrap();\n        let editor =\n            cx.add_window(|window, cx| Editor::for_buffer(buffer, Some(project), window, cx));\n\n        cx.executor().run_until_parked();\n        editor\n            .update(cx, |editor, window, cx| {\n                editor.change_selections(None, window, cx, |s| {\n                    s.select_ranges([Point::new(10, 0)..Point::new(10, 0)])\n                })\n            })\n            .unwrap();\n        cx.executor().run_until_parked();\n        editor\n            .update(cx, |editor, _window, cx| {\n                let expected_hints = vec![\n                    ": "",
    ".to_string(),\n                    ": "",
    ".to_string(),\n                ];\n                assert_eq!(\n                    expected_hints,\n                    cached_hint_labels(editor),\n                    ": "",
    "\n                );\n                assert_eq!(expected_hints, visible_hint_labels(editor, cx));\n            })\n            .unwrap();\n    }\n\n    pub(crate) fn init_test(cx: &mut TestAppContext, f: impl Fn(&mut AllLanguageSettingsContent)) {\n        cx.update(|cx| {\n            let settings_store = SettingsStore::test(cx);\n            cx.set_global(settings_store);\n            theme::init(theme::LoadThemes::JustBase, cx);\n            release_channel::init(SemanticVersion::default(), cx);\n            client::init_settings(cx);\n            language::init(cx);\n            Project::init_settings(cx);\n            workspace::init_settings(cx);\n            crate::init(cx);\n        });\n\n        update_test_language_settings(cx, f);\n    }\n\n    async fn prepare_test_objects(\n        cx: &mut TestAppContext,\n        initialize: impl 'static + Send + Fn(&mut FakeLanguageServer, &'static str) + Send + Sync,\n    ) -> (&'static str, WindowHandle<Editor>, FakeLanguageServer) {\n        let fs = FakeFs::new(cx.background_executor.clone());\n        fs.insert_tree(\n            path!(": "",
    ").as_ref()], cx).await;\n        let file_path = path!(": "",
    ");\n\n        let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n        language_registry.add(rust_lang());\n        let mut fake_servers = language_registry.register_fake_lsp(\n            ": "",
    ",\n            FakeLspAdapter {\n                capabilities: lsp::ServerCapabilities {\n                    inlay_hint_provider: Some(lsp::OneOf::Left(true)),\n                    ..Default::default()\n                },\n                initializer: Some(Box::new(move |server| initialize(server, file_path))),\n                ..Default::default()\n            },\n        );\n\n        let buffer = project\n            .update(cx, |project, cx| {\n                project.open_local_buffer(path!(": "",
    "), cx)\n            })\n            .await\n            .unwrap();\n        let editor =\n            cx.add_window(|window, cx| Editor::for_buffer(buffer, Some(project), window, cx));\n\n        editor\n            .update(cx, |editor, _, cx| {\n                assert!(cached_hint_labels(editor).is_empty());\n                assert!(visible_hint_labels(editor, cx).is_empty());\n            })\n            .unwrap();\n\n        cx.executor().run_until_parked();\n        let fake_server = fake_servers.next().await.unwrap();\n        (file_path, editor, fake_server)\n    }\n\n    // Inlay hints in the cache are stored per excerpt as a key, and those keys are guaranteed to be ordered same as in the multi buffer.\n    // Ensure a stable order for testing.\n    fn sorted_cached_hint_labels(editor: &Editor) -> Vec<String> {\n        let mut labels = cached_hint_labels(editor);\n        labels.sort();\n        labels\n    }\n\n    pub fn cached_hint_labels(editor: &Editor) -> Vec<String> {\n        let mut labels = Vec::new();\n        for excerpt_hints in editor.inlay_hint_cache().hints.values() {\n            let excerpt_hints = excerpt_hints.read();\n            for id in &excerpt_hints.ordered_hints {\n                let hint = &excerpt_hints.hints_by_id[id];\n                let mut label = hint.text();\n                if hint.padding_left {\n                    label.insert(0, ' ');\n                }\n                if hint.padding_right {\n                    label.push_str(": ""
  },
  "zed/crates/editor/src/inline_completion_tests.rs": {
    "let absolute_zero_celsius = ˇ;": "",
    "-273.15": "",
    "let absolute_zero_celsius = -273.15ˇ;": "",
    "let pi = ˇ\\\"foo\\\";": "",
    "3.14159": "",
    "let pi = 3.14159ˇ;": "",
    "\n        line 0\n        line ˇ1\n        line 2\n        line 3\n        line\n    ": "",
    " 4": "",
    "\n        line 0\n        line 1\n        line 2\n        line 3\n        linˇe\n    ": "",
    "\n        line 0\n        line\n        line 2\n        line 3\n        line ˇ4\n    ": "",
    " 1": "",
    "\n        line 0\n        linˇe\n        line 2\n        line 3\n        line 4\n    ": "",
    "\n        line 0\n        line ˇ1\n        line 2\n        line 3\n        line 4\n        line\n    ": "",
    " 5": "",
    "\n        line 0\n        line 1\n        line ˇ2\n        line 3\n        line 4\n        line\n    ": "",
    "\n        line ˇ0\n        line 1\n        line 2\n        line 3\n        line 4\n        line\n    ": "",
    "\n        line\n        line 1\n        line 2\n        line 3\n        line ˇ4\n        line 5\n    ": "",
    " 0": "",
    "\n        line\n        line 1\n        line 2\n        line ˇ3\n        line 4\n        line 5\n    ": "",
    "\n        line\n        line 1\n        line 2\n        line 3\n        line 4\n        line ˇ5\n    ": "",
    "editor has no active completion": "",
    "expected edit completion": "",
    "expected move completion": "",
    "fake-completion-provider": "",
    "Fake Completion Provider": ""
  },
  "zed/crates/editor/src/items.rs": {
    "leaders don't share views for unshared buffers": "",
    "untitled": "",
    "Editor Saved": "",
    "cannot call save_as on an excerpt list": "",
    "Editor": "",
    "editors": "",
    "Failed to query editor state": "",
    "No path or contents found for buffer": "",
    "Failed to downcast to Editor after opening abs path {abs_path:?}": "",
    "Serializing editor {item_id:?} in workspace {workspace_id:?}": "",
    "failed to save serialized editor": "",
    "failed to save contents of buffer": "",
    "just written the type downcasted to": "",
    "": "",
    "Rust": "",
    "rs": "",
    "/file.rs": "",
    "fn main() {}": "",
    "hello": ""
  },
  "zed/crates/editor/src/linked_editing_ranges.rs": {},
  "zed/crates/editor/src/lsp_ext.rs": {
    "Timed out waiting for LSP tasks": ""
  },
  "zed/crates/editor/src/mouse_context_menu.rs": {
    "MouseContextMenu": "",
    "position": "",
    "context_menu": "",
    "Evaluate Selection": "",
    "Go to Definition": "",
    "Go to Declaration": "",
    "Go to Type Definition": "",
    "Go to Implementation": "",
    "Find All References": "",
    "Rename Symbol": "",
    "Format Buffer": "",
    "Format Selections": "",
    "Show Code Actions": "",
    "Cut": "",
    "Copy": "",
    "Copy and Trim": "",
    "Paste": "",
    "macos": "",
    "Reveal in Finder": "",
    "Reveal in File Manager": "",
    "Open in Terminal": "",
    "Copy Permalink": "",
    "\n            fn teˇst() {\n                do_work();\n            }\n        ": "",
    "\n            fn test() {\n                do_wˇork();\n            }\n        ": ""
  },
  "zed/crates/editor/src/movement.rs": {
    "move left": "",
    "subkind": "",
    "previous_word_start mismatch for '{}': actual={:?}, expected={:?}": "",
    "\\nˇ   ˇlorem": "",
    "ˇ\\nˇ   lorem": "",
    "    ˇloremˇ": "",
    "ˇ    ˇlorem": "",
    "    ˇlorˇem": "",
    "\\nlorem\\nˇ   ˇipsum": "",
    "\\n\\nˇ\\nˇ": "",
    "    ˇlorem  ˇipsum": "",
    "ˇlorem-ˇipsum": "",
    "loremˇ-#$@ˇipsum": "",
    "ˇlorem_ˇipsum": "",
    " ˇdefγˇ": "",
    " ˇbcΔˇ": "",
    "ˇhello.ˇ": "",
    "helloˇ...ˇ": "",
    "helloˇ.---..ˇtest": "",
    "test  ˇ.--ˇtest": "",
    "oneˇ,;:!?ˇtwo": "",
    "lorem_ˇipˇsum": "",
    "lorem_ˇipsumˇ": "",
    "lorem_ˇipsum_ˇdolor": "",
    "loremˇIpˇsum": "",
    "loremˇIpsumˇ": "",
    "loremˇ-ˇipsum": "",
    " bcˇΔˇ": "",
    " ˇbcδˇ": "",
    " abˇ——ˇcd": "",
    "abcˇdef\\ngh\\nijˇk": "",
    "abcdef\\nˇgh\\nijˇk": "",
    "abcdefghijklmnopqrstuvwxys": "",
    "Helvetica": "",
    "test": "",
    "Should not stop at inlays when looking for boundaries": "",
    "next_word_end mismatch for '{}': actual={:?}, expected={:?}": "",
    "\\nˇ   loremˇ": "",
    "    lorˇemˇ": "",
    "    loremˇ    ˇ\\nipsum\\n": "",
    "\\nˇ\\nˇ\\n\\n": "",
    "loremˇ    ipsumˇ   ": "",
    "loremˇ-ipsumˇ": "",
    "loremˇ#$@-ˇipsum": "",
    "loremˇ_ipsumˇ": "",
    "ˇ.helloˇ": "",
    "display_pointsˇ[0ˇ]": "",
    "ˇ...ˇhello": "",
    "testˇ.--ˇ test": "",
    "loˇremˇ_ipsum": "",
    "ˇloremˇ_ipsum": "",
    "loremˇ_ipsumˇ_dolor": "",
    "loˇremˇIpsum": "",
    "loremˇIpsumˇDolor": "",
    " ˇbcˇΔ": "",
    "abˇcdef\\ngh\\nˇijk": "",
    "abcˇdef\\ngh\\nˇijk": "",
    "{}": "",
    "ˇˇloremˇ  ipsum": "",
    "ˇloˇremˇ  ipsum": "",
    "ˇloremˇˇ  ipsum": "",
    "loremˇ ˇ  ˇipsum": "",
    "lorem\\nˇˇˇ\\nipsum": "",
    "lorem\\nˇˇipsumˇ": "",
    "loremˇ,ˇˇ ipsum": "",
    "ˇloremˇˇ, ipsum": "",
    "abc\\ndefg\\nhijkl\\nmn": "",
    "abc\\ndefg\\n\\nhijkl\\nmn": ""
  },
  "zed/crates/editor/src/persistence.rs": {
    "NOT NULL": "",
    "Saving selections for editor {editor_id} in workspace {workspace_id:?}": "",
    "(?1, ?2, ?, ?)": "",
    ", ": "",
    "\nDELETE FROM editor_selections WHERE editor_id = ?1 AND workspace_id = ?2;\n\nINSERT OR IGNORE INTO editor_selections (editor_id, workspace_id, start, end)\nVALUES {placeholders};\n": "",
    "Saving folds for editor {editor_id} in workspace {workspace_id:?}": "",
    "\nDELETE FROM editor_folds WHERE editor_id = ?1 AND workspace_id = ?2;\n\nINSERT OR IGNORE INTO editor_folds (editor_id, workspace_id, start, end)\nVALUES {placeholders};\n": "",
    "testing.txt": "",
    "Test": "",
    "Go": ""
  },
  "zed/crates/editor/src/proposed_changes_editor.rs": {
    "ProposedChangesEditor": "",
    "apply-changes": "",
    "Apply All": ""
  },
  "zed/crates/editor/src/rust_analyzer_ext.rs": {
    "Rust": "",
    "lsp ext go to parent module proto request": "",
    "go to parent module via collab": "",
    "go to parent module": "",
    "lsp ext expand macro proto request": "",
    "expand macro": "",
    "Empty macro expansion for position {:?}": "",
    "lsp ext open docs proto request": "",
    "open docs": "",
    "Empty docs urls for position {:?}": ""
  },
  "zed/crates/extension/src/extension_builder.rs": {
    "wasm32-wasip2": "",
    "https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-25/": "",
    "macos": "",
    "x86_64": "",
    "wasi-sdk-25.0-x86_64-macos.tar.gz": "",
    "aarch64": "",
    "wasi-sdk-25.0-arm64-macos.tar.gz": "",
    "linux": "",
    "wasi-sdk-25.0-x86_64-linux.tar.gz": "",
    "wasi-sdk-25.0-arm64-linux.tar.gz": "",
    "freebsd": "",
    "windows": "",
    "wasi-sdk-25.0-x86_64-windows.tar.gz": "",
    "extension dir {} is not an absolute path": "",
    "failed to create cache dir": "",
    "compiling Rust extension {}": "",
    "failed to compile Rust extension": "",
    "compiled Rust extension {}": "",
    "grammar name '{grammar_name}' must be written in snake_case: {snake_cased_grammar_name}": "",
    "compiling grammar {grammar_name} for extension {}": "",
    "failed to compile grammar '{grammar_name}'": "",
    "compiled grammar {grammar_name} for extension {}": "",
    "finished compiling extension {}": "",
    "Cargo.toml": "",
    "compiling Rust crate for extension {}": "",
    "cargo": "",
    "build": "",
    "--target": "",
    "--release": "",
    "--target-dir": "",
    "target": "",
    "RUSTC_WRAPPER": "",
    "": "",
    "failed to run `cargo`": "",
    "failed to build extension {}": "",
    "compiled Rust crate for extension {}": "",
    "release": "",
    "debug": "",
    "_": "",
    "wasm": "",
    "encoding wasm component for extension {}": "",
    "failed to read output module `{}`": "",
    "failed to strip debug sections from wasm component": "",
    "compiled wasm did not contain a valid zed extension api version": "",
    "extension.wasm": "",
    "failed to write extension.wasm": "",
    "extension {} written to {}": "",
    "grammars": "",
    "checking out {grammar_name} parser": "",
    "src": "",
    "parser.c": "",
    "scanner.c": "",
    "compiling {grammar_name} parser": "",
    "-fPIC": "",
    "-shared": "",
    "-Os": "",
    "-Wl,--export=tree_sitter_{grammar_name}": "",
    "-o": "",
    "-I": "",
    "failed to run clang": "",
    "failed to compile {} parser with clang: {}": "",
    ".git": "",
    "git": "",
    "--git-dir": "",
    "remote": "",
    "-v": "",
    "origin": "",
    "grammar directory '{}' already exists, but is not a git clone of '{}'": "",
    "failed to create grammar directory {}": "",
    "init": "",
    "failed to run `git init` in directory '{}'": "",
    "add": "",
    "failed to execute `git remote add`": "",
    "failed to add remote {url} for git repository {}": "",
    "fetch": "",
    "--depth": "",
    "1": "",
    "failed to execute `git fetch`": "",
    "checkout": "",
    "failed to execute `git checkout`": "",
    "failed to fetch revision {} in directory '{}'": "",
    "failed to checkout revision {} in directory '{}': {}": "",
    "rustc": "",
    "--print": "",
    "sysroot": "",
    "failed to run rustc": "",
    "failed to retrieve rust sysroot: {}": "",
    "lib/rustlib": "",
    "rustup": "",
    "failed to run `rustup target add`": "",
    "failed to install the `{RUST_TARGET}` target: {}": "",
    "{WASI_SDK_URL}{asset_name}": "",
    "wasi-sdk is not available for platform {}": "",
    "wasi-sdk": "",
    "bin": "",
    "clang{}": "",
    "archive": "",
    "downloading wasi-sdk to {}": "",
    "failed to unpack wasi-sdk archive": "",
    "no content": "",
    "failed to read contents of extracted wasi archive directory": "",
    "failed to move extracted wasi dir": "",
    "name": "",
    "component-type:": "",
    "dylink.0": "",
    "zed:api-version": "",
    "languages": "",
    "failed to list languages dir": "",
    "config.toml": "",
    "themes": "",
    "failed to list themes dir": "",
    "json": "",
    "icon_themes": "",
    "failed to list icon themes dir": "",
    "snippets.json": "",
    "failed to list grammars dir": "",
    "toml": "",
    "no grammar name": ""
  },
  "zed/crates/extension/src/extension_host_proxy.rs": {},
  "zed/crates/extension/src/extension_manifest.rs": {
    "{}": "",
    "**": "",
    "*": "",
    "capability for process:exec {desired_command} {desired_args:?} was not listed in the extension manifest": "",
    "kind": "",
    "process:exec": "",
    "commit": "",
    "invalid extension name": "",
    "extension.json": "",
    "failed to load {extension_name} extension.json": "",
    "invalid extension.json for extension {extension_name}": "",
    "toml": "",
    "failed to load {extension_name} extension.toml": "",
    "invalid extension.toml for extension {extension_name}": "",
    "test": "",
    "Test": "",
    "1.0.0": "",
    "ls": "",
    "-la": "",
    "-l": "",
    "pwd": "",
    "git": "",
    "status": "",
    "-s": "",
    "npm": "",
    "install": "",
    "cargo": "",
    "--all": "",
    "--no-fail-fast": "",
    "build": "",
    "docker": "",
    "run": "",
    "nginx": "",
    "ubuntu": "",
    "bash": "",
    "alpine": "",
    "sh": "",
    "-c": "",
    "echo hello": "",
    "ps": ""
  },
  "zed/crates/extension/src/extension.rs": {
    "error parsing wasm extension": "",
    "zed:api-version": "",
    "extension {} has invalid zed:api-version section: {:?}": "",
    "extension {extension_id} has no zed:api-version section": ""
  },
  "zed/crates/extension/src/types.rs": {},
  "zed/crates/extension_api/src/extension_api.rs": {
    "`language_server_command` not implemented": "",
    "`run_slash_command` not implemented": "",
    "`context_server_command` not implemented": "",
    "`index_docs` not implemented": "",
    "`get_dap_binary` not implemented": "",
    "`dap_schema` not implemented": "",
    "init-extension": "",
    "C": "",
    "PWD": "",
    "wasm32": "",
    "zed:api-version": "",
    "OUT_DIR": "",
    "/version_bytes": "",
    "./wit/since_v0.6.0": "",
    "{}": ""
  },
  "zed/crates/extension_api/src/http_client.rs": {
    "Method not set": "",
    "URL not set": ""
  },
  "zed/crates/extension_api/src/settings.rs": {
    "../wit/since_v0.2.0/settings.rs": "",
    "language": "",
    "lsp": "",
    "context_servers": ""
  },
  "zed/crates/extension_cli/src/main.rs": {
    "zed-extension": "",
    "failed to canonicalize source_dir": "",
    "failed to canonicalize scratch_dir": "",
    "loading extension manifest": "",
    "compiling extension": "",
    "Zed Extension CLI/{} ({}; {})": "",
    "CARGO_PKG_VERSION": "",
    "failed to compile extension": "",
    "archive": "",
    "failed to copy extension resources": "",
    "tar": "",
    "-czvf": "",
    "archive.tar.gz": "",
    "-C": "",
    ".": "",
    "failed to run tar": "",
    "failed to create archive.tar.gz: {}": "",
    "missing repository in extension manifest": "",
    "manifest.json": "",
    "failed to create output dir": "",
    "failed to serialize manifest": "",
    "extension.toml": "",
    "failed to write extension.toml": "",
    "extension.wasm": "",
    "failed to copy extension.wasm": "",
    "grammars": "",
    "wasm": "",
    "failed to copy grammar '{}'": "",
    "themes": "",
    "invalid theme path": "",
    "failed to copy theme '{}'": "",
    "icon_themes": "",
    "invalid icon theme path": "",
    "failed to copy icon theme '{}'": "",
    "icons": "",
    "failed to copy icons": "",
    "languages": "",
    "invalid language path": "",
    "failed to copy language dir '{}'": "",
    "loaded grammar {grammar_name}": "",
    "config.toml": "",
    "grammar not found: '{name}'": "",
    "scm": "",
    "language {} provides query {} but no grammar": "",
    "loaded language {}": "",
    "loaded theme family {}": "",
    "Theme ": "",
    " is using a deprecated style property: scrollbar_thumb.background. Use `scrollbar.thumb.background` instead.": ""
  },
  "zed/crates/extensions_ui/src/components/extension_card.rs": {
    "Overridden by dev extension.": ""
  },
  "zed/crates/extensions_ui/src/components/feature_upsell.rs": {
    "open_docs": "",
    "View Documentation": "",
    "Documentation Viewed": "",
    "Feature Upsell": ""
  },
  "zed/crates/extensions_ui/src/extension_suggest.rs": {
    "astro": "",
    "beancount": "",
    "clojure": "",
    "bb": "",
    "clj": "",
    "cljc": "",
    "cljs": "",
    "edn": "",
    "neocmake": "",
    "CMakeLists.txt": "",
    "cmake": "",
    "csharp": "",
    "cs": "",
    "cython": "",
    "pyx": "",
    "pxd": "",
    "pxi": "",
    "dart": "",
    "dockerfile": "",
    "Dockerfile": "",
    "elisp": "",
    "el": "",
    "elixir": "",
    "ex": "",
    "exs": "",
    "heex": "",
    "elm": "",
    "erlang": "",
    "erl": "",
    "hrl": "",
    "fish": "",
    "git-firefly": "",
    ".gitconfig": "",
    ".gitignore": "",
    "COMMIT_EDITMSG": "",
    "EDIT_DESCRIPTION": "",
    "MERGE_MSG": "",
    "NOTES_EDITMSG": "",
    "TAG_EDITMSG": "",
    "git-rebase-todo": "",
    "gleam": "",
    "glsl": "",
    "vert": "",
    "frag": "",
    "graphql": "",
    "gql": "",
    "haskell": "",
    "hs": "",
    "html": "",
    "htm": "",
    "shtml": "",
    "java": "",
    "kotlin": "",
    "kt": "",
    "latex": "",
    "tex": "",
    "log": "",
    "lua": "",
    "make": "",
    "Makefile": "",
    "nim": "",
    "nix": "",
    "nu": "",
    "ocaml": "",
    "ml": "",
    "mli": "",
    "php": "",
    "prisma": "",
    "proto": "",
    "purescript": "",
    "purs": "",
    "r": "",
    "R": "",
    "racket": "",
    "rkt": "",
    "rescript": "",
    "res": "",
    "resi": "",
    "ruby": "",
    "rb": "",
    "erb": "",
    "scheme": "",
    "scm": "",
    "scss": "",
    "sql": "",
    "svelte": "",
    "swift": "",
    "templ": "",
    "terraform": "",
    "tf": "",
    "tfvars": "",
    "hcl": "",
    "toml": "",
    "Cargo.lock": "",
    "vue": "",
    "wgsl": "",
    "wit": "",
    "zig": "",
    "{}_extension_suggest": "",
    "Do you want to install the recommended '{}' extension for '{}' files?": "",
    "Yes, install extension": "",
    "No, don't install it": "",
    "dismissed": "",
    "Cargo.toml": "",
    "a/b/c/d/.gitignore": "",
    "a/b/c/d/test.gleam": ""
  },
  "zed/crates/extensions_ui/src/extension_version_selector.rs": {
    "v{}": "",
    "Select extension version...": "",
    "Incompatible": "",
    "%Y-%m-%d": ""
  },
  "zed/crates/extensions_ui/src/extensions_ui.rs": {
    "Failed to install dev extension: {:?}": "",
    "Failed to install dev extension: {}": "",
    "Themes": "",
    "Icon Themes": "",
    "Languages": "",
    "Grammars": "",
    "Language Servers": "",
    "MCP Servers": "",
    "Slash Commands": "",
    "Indexed Docs Providers": "",
    "Snippets": "",
    "git": "",
    "github": "",
    "gitlab": "",
    "bitbucket": "",
    "codeberg": "",
    "sourcehut": "",
    "permalink": "",
    "link": "",
    "open in": "",
    "vim": "",
    "sh": "",
    "bash": "",
    "c": "",
    "clang": "",
    "c++": "",
    "cpp": "",
    "go": "",
    "golang": "",
    "python": "",
    "py": "",
    "react": "",
    "rust": "",
    "rs": "",
    "type": "",
    "typescript": "",
    "ts": "",
    "Search extensions...": "",
    "v{}": "",
    "rebuild-{}": "",
    "Rebuild": "",
    "Uninstall": "",
    "configure-{}": "",
    "Configure": "",
    "{}: {}": "",
    "Authors": "",
    "Author": "",
    ", ": "",
    "<>": "",
    "repository-{}": "",
    "v{version}": "",
    "(v{installed_version} installed)": "",
    "Downloads: {}": "",
    "more-{}": "",
    "Install Another Version...": "",
    "Copy Extension ID": "",
    "Copy Author Info": "",
    "Install": "",
    "Extension Installed": "",
    "Upgrade": "",
    "Extension Uninstalled": "",
    "v{version} is not compatible with this version of Zed.": "",
    "BufferSearchBar": "",
    "no extensions": "",
    "Loading extensions...": "",
    "No extensions that match your search.": "",
    "No extensions.": "",
    "No installed extensions that match your search.": "",
    "No installed extensions.": "",
    "No not installed extensions that match your search.": "",
    "No not installed extensions.": "",
    "Zed comes with basic Git support. More Git features are coming in the future.": "",
    "https://zed.dev/docs/git": "",
    "Zed supports linking to a source line on GitHub and others.": "",
    "https://zed.dev/docs/git#git-integrations": "",
    "Vim support is built-in to Zed!": "",
    "https://zed.dev/docs/vim": "",
    "enable-vim": "",
    "Enable vim mode": "",
    "Vim Mode Toggled": "",
    "Feature Upsell": "",
    "Shell support is built-in to Zed!": "",
    "https://zed.dev/docs/languages/bash": "",
    "C support is built-in to Zed!": "",
    "https://zed.dev/docs/languages/c": "",
    "C++ support is built-in to Zed!": "",
    "https://zed.dev/docs/languages/cpp": "",
    "Go support is built-in to Zed!": "",
    "https://zed.dev/docs/languages/go": "",
    "Python support is built-in to Zed!": "",
    "https://zed.dev/docs/languages/python": "",
    "React support is built-in to Zed!": "",
    "https://zed.dev/docs/languages/typescript": "",
    "Rust support is built-in to Zed!": "",
    "https://zed.dev/docs/languages/rust": "",
    "Typescript support is built-in to Zed!": "",
    "Extensions": "",
    "install-dev-extension": "",
    "Install Dev Extension": "",
    "filter-all": "",
    "All": "",
    "Show all extensions": "",
    "filter-installed": "",
    "Installed": "",
    "Show installed extensions": "",
    "filter-not-installed": "",
    "Not Installed": "",
    "Show not installed extensions": "",
    "filter-row": "",
    "filter-all-categories": "",
    "filter-category-{}": "",
    "entries": "",
    "Extensions Page Opened": ""
  },
  "zed/crates/feedback/src/feedback_modal.rs": {
    "GiveFeedback": "",
    "Give Feedback": "",
    "close-btn": "",
    "Thanks for using Zed! To share your experience with us, reach for the channel that's the most appropriate:": "",
    "file-a-bug-report": "",
    "File a Bug Report": "",
    "request-a-feature": "",
    "Request a Feature": "",
    "send-us_an-email": "",
    "Send an Email": "",
    "zed_repository": "",
    "GitHub Repository": ""
  },
  "zed/crates/feedback/src/feedback.rs": {
    "https://github.com/zed-industries/zed": "",
    "https://github.com/zed-industries/zed/discussions/new/choose": "",
    "https://github.com/zed-industries/zed/issues/new": "",
    "?": "",
    "template=10_bug_report.yml": "",
    "&": "",
    "environment={}": "",
    "mailto:hi@zed.dev": "",
    "body={}": "",
    "\\n\\nSystem Information:\\n\\n{}": "",
    "Copied into clipboard": "",
    "OK": ""
  },
  "zed/crates/feedback/src/system_specs.rs": {
    "{} || {} || {}": "",
    "OS: {} {}": "",
    "Zed: v{} ({}) {}": "",
    "{} {}": "",
    "(Taylor's Version)": "",
    "": "",
    "Memory: {}": "",
    "Architecture: {}": "",
    "GPU: {}": "",
    "\\n": "",
    "{system_specs}": "",
    "linux": "",
    "vulkaninfo": "",
    "--summary": "",
    "<details><summary>`vulkaninfo --summary` output</summary>": "",
    "```": "",
    "</details>": "",
    "Failed to run `vulkaninfo --summary`": ""
  },
  "zed/crates/file_finder/src/file_finder_tests.rs": {
    "…": "",
    "p/a/b/c/d/": "",
    "p/…/d/": "",
    "p/a/…/c/d/": "",
    "p/…/c/d/": "",
    "p/a/b/c/d": "",
    "p/…/d": "",
    "p/a/…/c/d": "",
    "p/…/c/d": "",
    "/p/a/b/c/d/": "",
    "/p/…/d/": "",
    "/p/a/…/c/d/": "",
    "/p/…/c/d/": "",
    "project/dir/child/grandchild": "",
    "project/one/two/X/three/sub": "",
    "project/…/X/three/sub": "",
    "project/one/two/three/X/sub": "",
    "project/…/three/X/sub": "",
    "b0.5": "",
    "c1.0": "",
    "a1.0": "",
    "a0.5": "",
    "b1.0": "",
    "/root": "",
    "a": "",
    "banana": "",
    "": "",
    "bandana": "",
    "bna": "",
    "./bandana": "",
    ".\\\\bandana": "",
    "a/bandana": "",
    "b/bandana": "",
    "b\\\\bandana": "",
    " bandana": "",
    "bandana ": "",
    " bandana ": "",
    " ndan ": "",
    " band ": "",
    "a bandana": "",
    "Wrong number of matches for bandana query '{bandana_query}'. Matches: {:?}": "",
    "Wrong match for bandana query '{bandana_query}'": "",
    "İg": "",
    " ": "",
    "g": "",
    "file1.txt": "",
    "b": "",
    "file2.txt": "",
    "/root/a/b/file2.txt": "",
    "a/b/file2.txt": "",
    "Matching abs path should be the only match": "",
    "/root/a/b/file1.txt": "",
    "Mismatching abs path should produce no matches": "",
    "其他": "",
    "S数据表格": "",
    "task.xlsx": "",
    "some content": "",
    "t": "",
    "其他/S数据表格/task.xlsx": "",
    "first.rs": "",
    "// First Rust file": "",
    "/src": "",
    "test": "",
    "second.rs": "",
    "// Second Rust file": "",
    "{file_query}:{file_row}:{file_column}": "",
    "Finder should have a query after the update_matches call": "",
    "Expected to have 1 selection (caret) after file finder confirm, but got: {all_selections:?}": "",
    "Caret selection should have its start and end at the same position": "",
    "Query inside file should get caret with the same focus row": "",
    "Query inside file should get caret with the same focus column": "",
    "Excessive rows (as in query outside file borders) should get trimmed to last file row": "",
    "Excessive columns (as in query outside file borders) should get trimmed to selected row's last column": "",
    "/dir": "",
    "hello": "",
    "goodbye": "",
    "halogen-light": "",
    "happiness": "",
    "height": "",
    "hi": "",
    "hiccup": "",
    "/ancestor": "",
    ".gitignore": "",
    "ignored-root": "",
    "tracked-root": "",
    "height*": "",
    "heights": "",
    "height_1": "",
    "height_2": "",
    "/ancestor/tracked-root": "",
    "/ancestor/ignored-root": "",
    "ignored-root/hi": "",
    "tracked-root/hi": "",
    "ignored-root/hiccup": "",
    "tracked-root/hiccup": "",
    "ignored-root/height": "",
    "ignored-root/happiness": "",
    "tracked-root/happiness": "",
    "All ignored files that were indexed are found for default ignored mode": "",
    "tracked-root/height": "",
    "All ignored files should be found, for the toggled on ignored mode": "",
    "Only non-ignored files should be found for the turned off ignored mode": "",
    "/ancestor/tracked-root/heights/height_1": "",
    "Only for the worktree with the ignored root, all indexed ignored files are found in the auto ignored mode": "",
    "tracked-root/heights/height_1": "",
    "tracked-root/heights/height_2": "",
    "All ignored files that were indexed are found in the turned on ignored mode": "",
    "the-parent-dir": "",
    "the-file": "",
    "/root/the-parent-dir/the-file": "",
    "thf": "",
    "thf/": "",
    "dir1": "",
    "a.txt": "",
    "dir2": "",
    "b.txt": "",
    "dir2/b.txt": "",
    "dir2/a.txt": "",
    "dir1/a.txt": "",
    "dir3": "",
    "dir": "",
    "third.rs": "",
    "// Third Rust file": "",
    "fir": "",
    "Should have no history before opening any files": "",
    "sec": "",
    "test/first.rs": "",
    "/src/test/first.rs": "",
    "Should show 1st opened item in the history when opening the 2nd item": "",
    "thi": "",
    "test/second.rs": "",
    "/src/test/second.rs": "",
    "\n    );\n\n    let history_after_third =\n        open_close_queried_buffer(": "",
    ", 1, ": "",
    ", &workspace, cx).await;\n    assert_eq!(\n        history_after_third,\n        vec![\n            FoundPath::new(\n                ProjectPath {\n                    worktree_id,\n                    path: Arc::from(Path::new(": "",
    ")),\n                },\n                Some(PathBuf::from(path!(": "",
    ")))\n            ),\n            FoundPath::new(\n                ProjectPath {\n                    worktree_id,\n                    path: Arc::from(Path::new(": "",
    ")))\n            ),\n        ],\n        ": "",
    "\n    );\n\n    let history_after_second_again =\n        open_close_queried_buffer(": "",
    ", &workspace, cx).await;\n    assert_eq!(\n        history_after_second_again,\n        vec![\n            FoundPath::new(\n                ProjectPath {\n                    worktree_id,\n                    path: Arc::from(Path::new(": "",
    "\n    );\n}\n\n#[gpui::test]\nasync fn test_external_files_history(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    "),\n            json!({\n                ": "",
    ": {\n                    ": "",
    ": ": "",
    ",\n                    ": "",
    ",\n                }\n            }),\n        )\n        .await;\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ",\n                }\n            }),\n        )\n        .await;\n\n    let project = Project::test(app_state.fs.clone(), [path!(": "",
    ").as_ref()], cx).await;\n    cx.update(|cx| {\n        project.update(cx, |project, cx| {\n            project.find_or_create_worktree(path!(": "",
    "), false, cx)\n        })\n    })\n    .detach();\n    cx.background_executor.run_until_parked();\n\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n    let worktree_id = cx.read(|cx| {\n        let worktrees = workspace.read(cx).worktrees(cx).collect::<Vec<_>>();\n        assert_eq!(worktrees.len(), 1,);\n\n        WorktreeId::from_usize(worktrees[0].entity_id().as_u64() as usize)\n    });\n    workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_abs_path(\n                PathBuf::from(path!(": "",
    ")),\n                OpenOptions {\n                    visible: Some(OpenVisible::None),\n                    ..Default::default()\n                },\n                window,\n                cx,\n            )\n        })\n        .detach();\n    cx.background_executor.run_until_parked();\n    let external_worktree_id = cx.read(|cx| {\n        let worktrees = workspace.read(cx).worktrees(cx).collect::<Vec<_>>();\n        assert_eq!(\n            worktrees.len(),\n            2,\n            ": "",
    "\n        );\n\n        WorktreeId::from_usize(\n            worktrees\n                .into_iter()\n                .find(|worktree| worktree.entity_id().as_u64() as usize != worktree_id.to_usize())\n                .expect(": "",
    ")\n                .entity_id()\n                .as_u64() as usize,\n        )\n    });\n    cx.dispatch_action(workspace::CloseActiveItem {\n        save_intent: None,\n        close_pinned: false,\n    });\n\n    let initial_history_items =\n        open_close_queried_buffer(": "",
    ", &workspace, cx).await;\n    assert_eq!(\n        initial_history_items,\n        vec![FoundPath::new(\n            ProjectPath {\n                worktree_id: external_worktree_id,\n                path: Arc::from(Path::new(": "",
    ")),\n            },\n            Some(PathBuf::from(path!(": "",
    ")))\n        )],\n        ": "",
    "\n    );\n\n    let updated_history_items =\n        open_close_queried_buffer(": "",
    ", &workspace, cx).await;\n    assert_eq!(\n        updated_history_items,\n        vec![\n            FoundPath::new(\n                ProjectPath {\n                    worktree_id,\n                    path: Arc::from(Path::new(": "",
    ")))\n            ),\n            FoundPath::new(\n                ProjectPath {\n                    worktree_id: external_worktree_id,\n                    path: Arc::from(Path::new(": "",
    ",\n    );\n}\n\n#[gpui::test]\nasync fn test_toggle_panel_new_selections(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n    // generate some history to select from\n    open_close_queried_buffer(": "",
    ", &workspace, cx).await;\n    open_close_queried_buffer(": "",
    ", &workspace, cx).await;\n    let current_history = open_close_queried_buffer(": "",
    ", &workspace, cx).await;\n\n    for expected_selected_index in 0..current_history.len() {\n        cx.dispatch_action(ToggleFileFinder::default());\n        let picker = active_file_picker(&workspace, cx);\n        let selected_index = picker.update(cx, |picker, _| picker.delegate.selected_index());\n        assert_eq!(\n            selected_index, expected_selected_index,\n            ": "",
    "\n        );\n    }\n\n    cx.dispatch_action(ToggleFileFinder::default());\n    let selected_index = workspace.update(cx, |workspace, cx| {\n        workspace\n            .active_modal::<FileFinder>(cx)\n            .unwrap()\n            .read(cx)\n            .picker\n            .read(cx)\n            .delegate\n            .selected_index()\n    });\n    assert_eq!(\n        selected_index, 0,\n        ": "",
    "\n    );\n}\n\n#[gpui::test]\nasync fn test_search_preserves_history_items(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n    let worktree_id = cx.read(|cx| {\n        let worktrees = workspace.read(cx).worktrees(cx).collect::<Vec<_>>();\n        assert_eq!(worktrees.len(), 1,);\n\n        WorktreeId::from_usize(worktrees[0].entity_id().as_u64() as usize)\n    });\n\n    // generate some history to select from\n    open_close_queried_buffer(": "",
    ", &workspace, cx).await;\n\n    let finder = open_file_picker(&workspace, cx);\n    let first_query = ": "",
    ";\n    finder\n        .update_in(cx, |finder, window, cx| {\n            finder\n                .delegate\n                .update_matches(first_query.to_string(), window, cx)\n        })\n        .await;\n    finder.update(cx, |picker, _| {\n            let matches = collect_search_matches(picker);\n            assert_eq!(matches.history.len(), 1, ": "",
    ");\n            let history_match = matches.history_found_paths.first().expect(": "",
    ");\n            assert_eq!(history_match, &FoundPath::new(\n                ProjectPath {\n                    worktree_id,\n                    path: Arc::from(Path::new(": "",
    ")))\n            ));\n            assert_eq!(matches.search.len(), 1, ": "",
    ");\n            assert_eq!(matches.search.first().unwrap(), Path::new(": "",
    "));\n        });\n\n    let second_query = ": "",
    ";\n    let finder = active_file_picker(&workspace, cx);\n    finder\n        .update_in(cx, |finder, window, cx| {\n            finder\n                .delegate\n                .update_matches(second_query.to_string(), window, cx)\n        })\n        .await;\n    finder.update(cx, |picker, _| {\n        assert!(\n            collect_search_matches(picker)\n                .search_paths_only()\n                .is_empty(),\n            ": "",
    "\n        );\n    });\n\n    let first_query_again = first_query;\n\n    let finder = active_file_picker(&workspace, cx);\n    finder\n        .update_in(cx, |finder, window, cx| {\n            finder\n                .delegate\n                .update_matches(first_query_again.to_string(), window, cx)\n        })\n        .await;\n    finder.update(cx, |picker, _| {\n            let matches = collect_search_matches(picker);\n            assert_eq!(matches.history.len(), 1, ": "",
    "));\n        });\n}\n\n#[gpui::test]\nasync fn test_search_sorts_history_items(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n    // generate some history to select from\n    open_close_queried_buffer(": "",
    ", &workspace, cx).await;\n\n    let finder = open_file_picker(&workspace, cx);\n    let query = ": "",
    ";\n    finder\n        .update_in(cx, |finder, window, cx| {\n            finder\n                .delegate\n                .update_matches(query.to_string(), window, cx)\n        })\n        .await;\n    finder.update(cx, |finder, _| {\n        let search_matches = collect_search_matches(finder);\n        assert_eq!(\n            search_matches.history,\n            vec![PathBuf::from(": "",
    "), PathBuf::from(": "",
    "),],\n        );\n        assert_eq!(\n            search_matches.search,\n            vec![\n                PathBuf::from(": "",
    "),\n                PathBuf::from(": "",
    "),\n            ],\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_select_current_open_file_when_no_history(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n    // Open new buffer\n    open_queried_buffer(": "",
    ", &workspace, cx).await;\n\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_match_selection(&finder, 0, ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_keep_opened_file_on_top_of_search_results_and_select_next_one(\n    cx: &mut TestAppContext,\n) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n    open_close_queried_buffer(": "",
    ", &workspace, cx).await;\n    open_queried_buffer(": "",
    ", &workspace, cx).await;\n\n    // main.rs is on top, previously used is selected\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
    ");\n        assert_match_at_position(finder, 1, ": "",
    ");\n        assert_match_at_position(finder, 2, ": "",
    ");\n    });\n\n    // all files match, main.rs is still on top, but the second item is selected\n    picker\n        .update_in(cx, |finder, window, cx| {\n            finder\n                .delegate\n                .update_matches(": "",
    ".to_string(), window, cx)\n        })\n        .await;\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 6);\n        assert_match_at_position(finder, 0, ": "",
    ");\n        assert_match_selection(finder, 1, ": "",
    ");\n        assert_match_at_position(finder, 3, ": "",
    ");\n        assert_match_at_position(finder, 4, ": "",
    ");\n        assert_match_at_position(finder, 5, ": "",
    ");\n    });\n\n    // main.rs is not among matches, select top item\n    picker\n        .update_in(cx, |finder, window, cx| {\n            finder.delegate.update_matches(": "",
    ".to_string(), window, cx)\n        })\n        .await;\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_at_position(finder, 0, ": "",
    ");\n    });\n\n    // main.rs is back, put it on top and select next item\n    picker\n        .update_in(cx, |finder, window, cx| {\n            finder.delegate.update_matches(": "",
    ".to_string(), window, cx)\n        })\n        .await;\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 4);\n        assert_match_at_position(finder, 0, ": "",
    ");\n    });\n\n    // get back to the initial state\n    picker\n        .update_in(cx, |finder, window, cx| {\n            finder.delegate.update_matches(": "",
    ".to_string(), window, cx)\n        })\n        .await;\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_setting_auto_select_first_and_select_active_file(cx: &mut TestAppContext) {\n    let app_state = init_test(cx);\n\n    cx.update(|cx| {\n        let settings = *FileFinderSettings::get_global(cx);\n\n        FileFinderSettings::override_global(\n            FileFinderSettings {\n                skip_focus_for_active_in_search: false,\n                ..settings\n            },\n            cx,\n        );\n    });\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ");\n    });\n\n    // all files match, main.rs is on top, and is selected\n    picker\n        .update_in(cx, |finder, window, cx| {\n            finder\n                .delegate\n                .update_matches(": "",
    ".to_string(), window, cx)\n        })\n        .await;\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 6);\n        assert_match_selection(finder, 0, ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_non_separate_history_items(cx: &mut TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ", &workspace, cx).await;\n\n    cx.dispatch_action(ToggleFileFinder::default());\n    let picker = active_file_picker(&workspace, cx);\n    // main.rs is on top, previously used is selected\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_history_items_shown_in_order_of_open(cx: &mut TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n    open_queried_buffer(": "",
    ", &workspace, cx).await;\n\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
    ");\n    });\n\n    cx.dispatch_action(SelectNext);\n    cx.dispatch_action(Confirm); // Open 2.txt\n\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
    ");\n    });\n\n    cx.dispatch_action(SelectNext);\n    cx.dispatch_action(SelectNext);\n    cx.dispatch_action(Confirm); // Open 1.txt\n\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_selected_history_item_stays_selected_on_worktree_updated(cx: &mut TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ");\n    });\n\n    cx.dispatch_action(SelectNext);\n\n    // Add more files to the worktree to trigger update matches\n    for i in 0..5 {\n        let filename = if cfg!(windows) {\n            format!(": "",
    ", 4 + i)\n        } else {\n            format!(": "",
    ", 4 + i)\n        };\n        app_state\n            .fs\n            .create_file(Path::new(&filename), Default::default())\n            .await\n            .expect(": "",
    ");\n    }\n\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_at_position(finder, 0, ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_history_items_vs_very_good_external_match(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ";\n    cx.simulate_input(query);\n    finder.update(cx, |picker, _| {\n            let search_entries = collect_search_matches(picker).search_paths_only();\n            assert_eq!(\n                search_entries,\n                vec![\n                    PathBuf::from(": "",
    "),\n                    PathBuf::from(": "",
    "),\n                ],\n                ": "",
    "\n            );\n        });\n}\n\n#[gpui::test]\nasync fn test_nonexistent_history_items_not_shown(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx)); // generate some history to select from\n    open_close_queried_buffer(": "",
    ", &workspace, cx).await;\n    app_state\n        .fs\n        .remove_file(\n            Path::new(path!(": "",
    ")),\n            RemoveOptions::default(),\n        )\n        .await\n        .unwrap();\n    cx.run_until_parked();\n\n    let picker = open_file_picker(&workspace, cx);\n    cx.simulate_input(": "",
    ");\n\n    picker.update(cx, |picker, _| {\n        assert_eq!(\n            collect_search_matches(picker).history,\n            vec![\n                PathBuf::from(": "",
    "),\n            ],\n            ": "",
    "\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_search_results_refreshed_on_worktree_updates(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            ": "",
    ",\n            json!({\n                ": "",
    ",\n                ": "",
    ",\n            }),\n        )\n        .await;\n\n    let project = Project::test(app_state.fs.clone(), [": "",
    ".as_ref()], cx).await;\n    let (workspace, cx) =\n        cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n\n    // Initial state\n    let picker = open_file_picker(&workspace, cx);\n    cx.simulate_input(": "",
    ");\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_at_position(finder, 0, ": "",
    ");\n    });\n\n    // Delete main.rs\n    app_state\n        .fs\n        .remove_file(": "",
    ".as_ref(), Default::default())\n        .await\n        .expect(": "",
    ");\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    // main.rs is in not among search results anymore\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 2);\n        assert_match_at_position(finder, 0, ": "",
    ");\n    });\n\n    // Create util.rs\n    app_state\n        .fs\n        .create_file(": "",
    ");\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    // util.rs is among search results\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_at_position(finder, 0, ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_search_results_refreshed_on_adding_and_removing_worktrees(\n    cx: &mut gpui::TestAppContext,\n) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            ": "",
    ",\n                },\n                ": "",
    ",\n                }\n            }),\n        )\n        .await;\n\n    let project = Project::test(app_state.fs.clone(), [": "",
    ".as_ref()], cx).await;\n    let (workspace, cx) =\n        cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let worktree_1_id = project.update(cx, |project, cx| {\n        let worktree = project.worktrees(cx).last().expect(": "",
    ");\n        worktree.read(cx).id()\n    });\n\n    // Initial state\n    let picker = open_file_picker(&workspace, cx);\n    cx.simulate_input(": "",
    ");\n    });\n\n    // Add new worktree\n    project\n        .update(cx, |project, cx| {\n            project\n                .find_or_create_worktree(": "",
    ", true, cx)\n                .into_future()\n        })\n        .await\n        .expect(": "",
    ");\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    // main.rs is among search results\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 4);\n        assert_match_at_position(finder, 0, ": "",
    ");\n    });\n\n    // Remove the first worktree\n    project.update(cx, |project, cx| {\n        project.remove_worktree(worktree_1_id, cx);\n    });\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    // Files from the first worktree are not in the search results anymore\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 2);\n        assert_match_at_position(finder, 0, ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_selected_match_stays_selected_after_matches_refreshed(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state.fs.as_fake().insert_tree(": "",
    ", json!({})).await;\n\n    app_state\n        .fs\n        .create_dir(": "",
    ".as_ref())\n        .await\n        .expect(": "",
    ");\n\n    let initial_files_num = 5;\n    for i in 0..initial_files_num {\n        let filename = format!(": "",
    ", 10 + i);\n        app_state\n            .fs\n            .create_file(Path::new(&filename), Default::default())\n            .await\n            .expect(": "",
    ");\n    }\n\n    let project = Project::test(app_state.fs.clone(), [": "",
    ");\n    let selected_index = 3;\n    // Checking only the filename, not the whole path\n    let selected_file = format!(": "",
    ", 10 + selected_index);\n    // Select even/file_13.txt\n    for _ in 0..selected_index {\n        cx.dispatch_action(SelectNext);\n    }\n\n    picker.update(cx, |finder, _| {\n        assert_match_selection(finder, selected_index, &selected_file)\n    });\n\n    // Add more matches to the search results\n    let files_to_add = 10;\n    for i in 0..files_to_add {\n        let filename = format!(": "",
    ", 20 + i);\n        app_state\n            .fs\n            .create_file(Path::new(&filename), Default::default())\n            .await\n            .expect(": "",
    ");\n    }\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    // file_13.txt is still selected\n    picker.update(cx, |finder, _| {\n        let expected_selected_index = selected_index + files_to_add;\n        assert_match_selection(finder, expected_selected_index, &selected_file);\n    });\n}\n\n#[gpui::test]\nasync fn test_first_match_selected_if_previous_one_is_not_in_the_match_list(\n    cx: &mut gpui::TestAppContext,\n) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            ": "",
    ");\n    // Select even/file_2.txt\n    cx.dispatch_action(SelectNext);\n\n    // Remove the selected entry\n    app_state\n        .fs\n        .remove_file(": "",
    ");\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    // file_1.txt is now selected\n    picker.update(cx, |finder, _| {\n        assert_match_selection(finder, 0, ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_keeps_file_finder_open_after_modifier_keys_release(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ",\n            }),\n        )\n        .await;\n\n    let project = Project::test(app_state.fs.clone(), [path!(": "",
    ", &workspace, cx).await;\n\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    open_file_picker(&workspace, cx);\n\n    cx.simulate_modifiers_change(Modifiers::none());\n    active_file_picker(&workspace, cx);\n}\n\n#[gpui::test]\nasync fn test_opens_file_on_modifier_keys_release(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ", &workspace, cx).await;\n\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 2);\n        assert_match_selection(finder, 0, ": "",
    ");\n    });\n\n    cx.dispatch_action(SelectNext);\n    cx.simulate_modifiers_change(Modifiers::none());\n    cx.read(|cx| {\n        let active_editor = workspace.read(cx).active_item_as::<Editor>(cx).unwrap();\n        assert_eq!(active_editor.read(cx).title(cx), ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_switches_between_release_norelease_modes_on_forward_nav(\n    cx: &mut gpui::TestAppContext,\n) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ", &workspace, cx).await;\n\n    // Open with a shortcut\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 2);\n        assert_match_selection(finder, 0, ": "",
    ");\n    });\n\n    // Switch to navigating with other shortcuts\n    // Don't open file on modifiers release\n    cx.simulate_modifiers_change(Modifiers::control());\n    cx.dispatch_action(SelectNext);\n    cx.simulate_modifiers_change(Modifiers::none());\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 2);\n        assert_match_at_position(finder, 0, ": "",
    ");\n    });\n\n    // Back to navigation with initial shortcut\n    // Open file on modifiers release\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    cx.dispatch_action(ToggleFileFinder::default());\n    cx.simulate_modifiers_change(Modifiers::none());\n    cx.read(|cx| {\n        let active_editor = workspace.read(cx).active_item_as::<Editor>(cx).unwrap();\n        assert_eq!(active_editor.read(cx).title(cx), ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_switches_between_release_norelease_modes_on_backward_nav(\n    cx: &mut gpui::TestAppContext,\n) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    "\n            }),\n        )\n        .await;\n\n    let project = Project::test(app_state.fs.clone(), [path!(": "",
    ", &workspace, cx).await;\n\n    // Open with a shortcut\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
    ");\n    });\n\n    // Switch to navigating with other shortcuts\n    // Don't open file on modifiers release\n    cx.simulate_modifiers_change(Modifiers::control());\n    cx.dispatch_action(menu::SelectPrevious);\n    cx.simulate_modifiers_change(Modifiers::none());\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_at_position(finder, 0, ": "",
    ");\n        assert_match_selection(finder, 2, ": "",
    ");\n    });\n\n    // Back to navigation with initial shortcut\n    // Open file on modifiers release\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    cx.dispatch_action(SelectPrevious); // <-- File Finder's SelectPrevious, not menu's\n    cx.simulate_modifiers_change(Modifiers::none());\n    cx.read(|cx| {\n        let active_editor = workspace.read(cx).active_item_as::<Editor>(cx).unwrap();\n        assert_eq!(active_editor.read(cx).title(cx), ": "",
    ");\n    });\n}\n\n#[gpui::test]\nasync fn test_extending_modifiers_does_not_confirm_selection(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ", &workspace, cx).await;\n\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    open_file_picker(&workspace, cx);\n\n    cx.simulate_modifiers_change(Modifiers::command_shift());\n    active_file_picker(&workspace, cx);\n}\n\n#[gpui::test]\nasync fn test_repeat_toggle_action(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            ": "",
    ".as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n    cx.dispatch_action(ToggleFileFinder::default());\n    let picker = active_file_picker(&workspace, cx);\n\n    picker.update_in(cx, |picker, window, cx| {\n        picker.update_matches(": "",
    ".to_string(), window, cx)\n    });\n\n    cx.run_until_parked();\n\n    picker.update(cx, |picker, _| {\n        assert_eq!(picker.delegate.matches.len(), 7);\n        assert_eq!(picker.delegate.selected_index, 0);\n    });\n\n    // When toggling repeatedly, the picker scrolls to reveal the selected item.\n    cx.dispatch_action(ToggleFileFinder::default());\n    cx.dispatch_action(ToggleFileFinder::default());\n    cx.dispatch_action(ToggleFileFinder::default());\n\n    cx.run_until_parked();\n\n    picker.update(cx, |picker, _| {\n        assert_eq!(picker.delegate.matches.len(), 7);\n        assert_eq!(picker.delegate.selected_index, 3);\n    });\n}\n\nasync fn open_close_queried_buffer(\n    input: &str,\n    expected_matches: usize,\n    expected_editor_title: &str,\n    workspace: &Entity<Workspace>,\n    cx: &mut gpui::VisualTestContext,\n) -> Vec<FoundPath> {\n    let history_items = open_queried_buffer(\n        input,\n        expected_matches,\n        expected_editor_title,\n        workspace,\n        cx,\n    )\n    .await;\n\n    cx.dispatch_action(workspace::CloseActiveItem {\n        save_intent: None,\n        close_pinned: false,\n    });\n\n    history_items\n}\n\nasync fn open_queried_buffer(\n    input: &str,\n    expected_matches: usize,\n    expected_editor_title: &str,\n    workspace: &Entity<Workspace>,\n    cx: &mut gpui::VisualTestContext,\n) -> Vec<FoundPath> {\n    let picker = open_file_picker(&workspace, cx);\n    cx.simulate_input(input);\n\n    let history_items = picker.update(cx, |finder, _| {\n        assert_eq!(\n            finder.delegate.matches.len(),\n            expected_matches + 1, // +1 from CreateNew option\n            ": "",
    ",\n            finder.delegate.matches\n        );\n        finder.delegate.history_items.clone()\n    });\n\n    cx.dispatch_action(Confirm);\n\n    cx.read(|cx| {\n        let active_editor = workspace.read(cx).active_item_as::<Editor>(cx).unwrap();\n        let active_editor_title = active_editor.read(cx).title(cx);\n        assert_eq!(\n            expected_editor_title, active_editor_title,\n            ": "",
    "\n        );\n    });\n\n    history_items\n}\n\nfn init_test(cx: &mut TestAppContext) -> Arc<AppState> {\n    cx.update(|cx| {\n        let state = AppState::test(cx);\n        theme::init(theme::LoadThemes::JustBase, cx);\n        language::init(cx);\n        super::init(cx);\n        editor::init(cx);\n        workspace::init_settings(cx);\n        Project::init_settings(cx);\n        state\n    })\n}\n\nfn test_path_position(test_str: &str) -> FileSearchQuery {\n    let path_position = PathWithPosition::parse_str(test_str);\n\n    FileSearchQuery {\n        raw_query: test_str.to_owned(),\n        file_query_end: if path_position.path.to_str().unwrap() == test_str {\n            None\n        } else {\n            Some(path_position.path.to_str().unwrap().len())\n        },\n        path_position,\n    }\n}\n\nfn build_find_picker(\n    project: Entity<Project>,\n    cx: &mut TestAppContext,\n) -> (\n    Entity<Picker<FileFinderDelegate>>,\n    Entity<Workspace>,\n    &mut VisualTestContext,\n) {\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n    let picker = open_file_picker(&workspace, cx);\n    (picker, workspace, cx)\n}\n\n#[track_caller]\nfn open_file_picker(\n    workspace: &Entity<Workspace>,\n    cx: &mut VisualTestContext,\n) -> Entity<Picker<FileFinderDelegate>> {\n    cx.dispatch_action(ToggleFileFinder {\n        separate_history: true,\n    });\n    active_file_picker(workspace, cx)\n}\n\n#[track_caller]\nfn active_file_picker(\n    workspace: &Entity<Workspace>,\n    cx: &mut VisualTestContext,\n) -> Entity<Picker<FileFinderDelegate>> {\n    workspace.update(cx, |workspace, cx| {\n        workspace\n            .active_modal::<FileFinder>(cx)\n            .expect(": "",
    ")\n            .read(cx)\n            .picker\n            .clone()\n    })\n}\n\n#[derive(Debug, Default)]\nstruct SearchEntries {\n    history: Vec<PathBuf>,\n    history_found_paths: Vec<FoundPath>,\n    search: Vec<PathBuf>,\n    search_matches: Vec<PathMatch>,\n}\n\nimpl SearchEntries {\n    #[track_caller]\n    fn search_paths_only(self) -> Vec<PathBuf> {\n        assert!(\n            self.history.is_empty(),\n            ": "",
    ",\n            self.history\n        );\n        self.search\n    }\n\n    #[track_caller]\n    fn search_matches_only(self) -> Vec<PathMatch> {\n        assert!(\n            self.history.is_empty(),\n            ": "",
    ",\n            self.history\n        );\n        self.search_matches\n    }\n}\n\nfn collect_search_matches(picker: &Picker<FileFinderDelegate>) -> SearchEntries {\n    let mut search_entries = SearchEntries::default();\n    for m in &picker.delegate.matches.matches {\n        match &m {\n            Match::History {\n                path: history_path,\n                panel_match: path_match,\n            } => {\n                search_entries.history.push(\n                    path_match\n                        .as_ref()\n                        .map(|path_match| {\n                            Path::new(path_match.0.path_prefix.as_ref()).join(&path_match.0.path)\n                        })\n                        .unwrap_or_else(|| {\n                            history_path\n                                .absolute\n                                .as_deref()\n                                .unwrap_or_else(|| &history_path.project.path)\n                                .to_path_buf()\n                        }),\n                );\n                search_entries\n                    .history_found_paths\n                    .push(history_path.clone());\n            }\n            Match::Search(path_match) => {\n                search_entries\n                    .search\n                    .push(Path::new(path_match.0.path_prefix.as_ref()).join(&path_match.0.path));\n                search_entries.search_matches.push(path_match.0.clone());\n            }\n            Match::CreateNew(_) => {}\n        }\n    }\n    search_entries\n}\n\n#[track_caller]\nfn assert_match_selection(\n    finder: &Picker<FileFinderDelegate>,\n    expected_selection_index: usize,\n    expected_file_name: &str,\n) {\n    assert_eq!(\n        finder.delegate.selected_index(),\n        expected_selection_index,\n        ": "",
    "\n    );\n    assert_match_at_position(finder, expected_selection_index, expected_file_name);\n}\n\n#[track_caller]\nfn assert_match_at_position(\n    finder: &Picker<FileFinderDelegate>,\n    match_index: usize,\n    expected_file_name: &str,\n) {\n    let match_item = finder\n        .delegate\n        .matches\n        .get(match_index)\n        .unwrap_or_else(|| panic!(": "",
    "));\n    let match_file_name = match &match_item {\n        Match::History { path, .. } => path.absolute.as_deref().unwrap().file_name(),\n        Match::Search(path_match) => path_match.0.path.file_name(),\n        Match::CreateNew(project_path) => project_path.path.file_name(),\n    }\n    .unwrap()\n    .to_string_lossy();\n    assert_eq!(match_file_name, expected_file_name);\n}\n\n#[gpui::test]\nasync fn test_filename_precedence(cx: &mut TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
    ").as_ref()], cx).await;\n    let (picker, _, cx) = build_find_picker(project, cx);\n\n    cx.simulate_input(": "",
    ");\n\n    picker.update(cx, |finder, _| {\n        let search_matches = collect_search_matches(finder).search_paths_only();\n\n        assert_eq!(\n            search_matches,\n            vec![\n                PathBuf::from(": ""
  },
  "zed/crates/file_finder/src/file_finder.rs": {
    "c/d": "",
    "/a/b": "",
    "/": "",
    "": "",
    "Create file: {}": "",
    "HOME": "",
    "~": "",
    "…": "",
    "FileFinder": "",
    "filter_menu_open": "",
    "split_menu_open": "",
    "Search project files...": "",
    ".\\\\": "",
    "./": "",
    "a\\\\": "",
    "a/": "",
    "a": "",
    "b\\\\": "",
    "b/": "",
    "b": "",
    "Invalid matches state: no element for index {ix}": "",
    "filter-menu-popover": "",
    "filter-trigger": "",
    "Filter Options": "",
    "Include Ignored Files": "",
    "split-menu-popover": "",
    "split-trigger": "",
    "Split…": "",
    "Split Left": "",
    "Split Right": "",
    "Split Up": "",
    "Split Down": "",
    "open-selection": "",
    "Open": ""
  },
  "zed/crates/file_finder/src/open_path_prompt.rs": {
    "windows": "",
    "C:\\\\": "",
    "/": "",
    "test-support": "",
    "": "",
    "{}{}{}": "",
    "{prompted_path:?} already exists. Do you want to replace it?": "",
    "A file or folder with the same name already exists. Replacing it will overwrite its current contents.": "",
    "Replace": "",
    "Cancel": "",
    "{}{}": "",
    "{label} (replace)": "",
    "{label} (create)": "",
    "Type a path…": "",
    "No such file or directory": "",
    "[directory{MAIN_SEPARATOR_STR}]filename.ext": ""
  },
  "zed/crates/fsevent/examples/events.rs": {
    "macos": "",
    "Must pass 1 or more paths as arguments": "",
    "event batch": "",
    "  {:?}": "",
    "This example only works on macOS": ""
  },
  "zed/crates/fsevent/src/fsevent.rs": {
    "macos": "",
    "C": "",
    "dropped": "",
    "unknown flag set for fs event: {}": "",
    "MUST_SCAN_SUBDIRS ": "",
    "USER_DROPPED ": "",
    "KERNEL_DROPPED ": "",
    "IDS_WRAPPED ": "",
    "HISTORY_DONE ": "",
    "ROOT_CHANGED ": "",
    "MOUNT ": "",
    "UNMOUNT ": "",
    "ITEM_CREATED ": "",
    "ITEM_REMOVED ": "",
    "INODE_META_MOD ": "",
    "ITEM_RENAMED ": "",
    "ITEM_MODIFIED ": "",
    "FINDER_INFO_MOD ": "",
    "ITEM_CHANGE_OWNER ": "",
    "ITEM_XATTR_MOD ": "",
    "IS_FILE ": "",
    "IS_DIR ": "",
    "IS_SYMLINK ": "",
    "OWN_EVENT ": "",
    "IS_LAST_HARDLINK ": "",
    "IS_HARDLINK ": "",
    "ITEM_CLONED ": "",
    "": "",
    "CoreServices": "",
    "framework": "",
    "test-event-stream": "",
    "existing-file-{}": "",
    "new-file": "",
    "existing-file-5": "",
    "running": "",
    "stopped": "",
    "CI": ""
  },
  "zed/crates/fuzzy/src/strings.rs": {
    "Invariant violation: Index {start} out of range or not on a utf-8 boundary in string {:?}": "",
    "Invariant violation: Index {end} out of range or not on a utf-8 boundary in string {:?}": ""
  },
  "zed/crates/git/src/blame.rs": {
    "failed to get commit messages": "",
    "fatal: no such ref: HEAD": "",
    "fatal: no such path": "",
    "blame": "",
    "--incremental": "",
    "--contents": "",
    "-": "",
    "starting git blame process": "",
    "failed to get pipe to stdin of git blame command": "",
    "reading git blame output": "",
    "git blame process failed: {stderr}": "",
    "parsing sha": "",
    "parsing original line number": "",
    "parsing final line number": "",
    "parsing line count": "",
    "[offset_hour][offset_minute]": "",
    "filename": "",
    "previous": "",
    "summary": "",
    "author": "",
    "author-mail": "",
    "author-time": "",
    "author-tz": "",
    "committer": "",
    "committer-mail": "",
    "committer-time": "",
    "committer-tz": "",
    "CARGO_MANIFEST_DIR": "",
    "test_data": "",
    "Could not read test data at {:?}. Is it generated?": "",
    "golden": "",
    "{}.json": "",
    "could not serialize entries to JSON": "",
    "UPDATE_GOLDEN": "",
    "true": "",
    "could not create golden test data directory": "",
    "could not write out golden data": "",
    "could not read golden test data file at {:?}. Did you run the test with UPDATE_GOLDEN=true before?": "",
    "\\r\\n": "",
    "\\n": "",
    "wrong blame entries": "",
    "blame_incremental_not_committed": "",
    "blame_incremental_simple": "",
    "blame_incremental_complex": ""
  },
  "zed/crates/git/src/commit.rs": {
    "<MARKER>": "",
    "git": "",
    "show": "",
    "-s": "",
    "--format=%B{}": "",
    "starting git blame process": "",
    "'git show' failed with error {:?}": "",
    "<": "",
    "&lt;": "",
    ">": "",
    "&gt;": "",
    "M": "",
    "A": "",
    "D": "",
    "M\u0000Cargo.lock\u0000": "",
    "M\u0000crates/project/Cargo.toml\u0000": "",
    "M\u0000crates/project/src/buffer_store.rs\u0000": "",
    "D\u0000crates/project/src/git.rs\u0000": "",
    "A\u0000crates/project/src/git_store.rs\u0000": "",
    "A\u0000crates/project/src/git_store/git_traversal.rs\u0000": "",
    "M\u0000crates/project/src/project.rs\u0000": "",
    "M\u0000crates/project/src/worktree_store.rs\u0000": "",
    "M\u0000crates/project_panel/src/project_panel.rs\u0000": "",
    "Cargo.lock": "",
    "crates/project/Cargo.toml": "",
    "crates/project/src/buffer_store.rs": "",
    "crates/project/src/git.rs": "",
    "crates/project/src/git_store.rs": "",
    "crates/project/src/git_store/git_traversal.rs": "",
    "crates/project/src/project.rs": "",
    "crates/project/src/worktree_store.rs": "",
    "crates/project_panel/src/project_panel.rs": ""
  },
  "zed/crates/git/src/git.rs": {
    ".git": "",
    ".gitignore": "",
    "fsmonitor--daemon": "",
    "lfs": "",
    "COMMIT_EDITMSG": "",
    "index.lock": "",
    "editor::RevertFile": "",
    "editor::RevertSelectedHunks": "",
    "editor::ToggleGitBlame": "",
    "failed to parse bytes into git oid": "",
    "parsing git oid": ""
  },
  "zed/crates/git/src/remote.rs": {
    "^[0-9a-zA-Z\\-_]+@": "",
    "Failed to create USERNAME_REGEX": "",
    "ssh://{}": "",
    "/": "",
    "https://github.com/octocat/zed.git": "",
    "https": "",
    "github.com": "",
    "/octocat/zed.git": "",
    "git@github.com:octocat/zed.git": "",
    "ssh": "",
    "org-000000@github.com:octocat/zed.git": "",
    "ssh://git@github.com/octocat/zed.git": "",
    "file:///path/to/local/zed": "",
    "file": "",
    "": "",
    "/path/to/local/zed": "",
    "failed to parse URL": "",
    "unexpected scheme for {input:?}": "",
    "unexpected host for {input:?}": "",
    "unexpected path for {input:?}": "",
    "not_a_url": "",
    "http://": "",
    "expected \\\"{url}\\\" to not parse as a Git remote URL": ""
  },
  "zed/crates/git/src/repository.rs": {
    "Operation cancelled by user": "",
    "refs/heads/": "",
    "refs/remotes/": "",
    "/": "",
    "Fetch all remotes": "",
    "--all": "",
    "{}": "",
    "{already_added}\\n{excludes}": "",
    "\\n\\n#  ====== Auto-added by Zed: =======\\n": "",
    "HEAD": "",
    "dyn GitRepository<...>": "",
    "git": "",
    "failed to read git work directory": "",
    "test-support": "",
    "macos": "",
    "ZED_BUNDLE": "",
    "true": "",
    "could not find git binary path": "",
    "config": "",
    "--global": "",
    "user.name": "",
    "user.email": "",
    "--no-optional-locks": "",
    "show": "",
    "--no-patch": "",
    "--format=%H%x00%B%x00%at%x00%ae%x00%an%x00": "",
    "unexpected git-show output for {commit:?}: {output:?}": "",
    "no working directory": "",
    "--format=%P": "",
    "-z": "",
    "--no-renames": "",
    "--name-status": "",
    "starting git show process": "",
    "": "",
    "cat-file": "",
    "--batch=%(objectsize)": "",
    "starting git cat-file process": "",
    "{commit}:{}": "",
    "{parent_sha}:{}": "",
    "invalid object size output from cat-file {info_line}": "",
    "invalid object size output from cat-file {}": "",
    "--mixed": "",
    "--soft": "",
    "reset": "",
    "Failed to reset:\\n{}": "",
    "checkout": "",
    "--": "",
    "Failed to checkout files:\\n{}": "",
    "Error loading index text: {:?}": "",
    "hash-object": "",
    "-w": "",
    "--stdin": "",
    "indexing SHA: {sha}, path {path:?}": "",
    "update-index": "",
    "--add": "",
    "--cacheinfo": "",
    "100644": "",
    "Failed to stage:\\n{}": "",
    "--force-remove": "",
    "Failed to unstage:\\n{}": "",
    "--batch-check=%(objectname)": "",
    "no stdin for git cat-file subprocess": "",
    "{rev}\\n": "",
    "missing": "",
    "unexpected number of shas": "",
    "MERGE_MSG": "",
    "git status failed: {stderr}": "",
    "%(HEAD)": "",
    "%(objectname)": "",
    "%(parent)": "",
    "%(refname)": "",
    "%(upstream)": "",
    "%(upstream:track)": "",
    "%(committerdate:unix)": "",
    "%(contents:subject)": "",
    "%00": "",
    "for-each-ref": "",
    "refs/heads/**/*": "",
    "refs/remotes/**/*": "",
    "--format": "",
    "Failed to git git branches:\\n{}": "",
    "symbolic-ref": "",
    "--quiet": "",
    "Unexpected branch format": "",
    "Branch not found": "",
    "Branch name could not be retrieved": "",
    "upstream": "",
    "origin": "",
    "--staged": "",
    "diff": "",
    "Failed to run git diff:\\n{}": "",
    "--remove": "",
    "Failed to stage paths:\\n{}": "",
    "commit": "",
    "-m": "",
    "--cleanup=strip": "",
    "--amend": "",
    "--author": "",
    "{name} <{email}>": "",
    "Failed to commit:\\n{}": "",
    "push": "",
    "--set-upstream": "",
    "--force-with-lease": "",
    "{}:{}": "",
    "pull": "",
    "fetch": "",
    "--get": "",
    "branch.{}.remote": "",
    "remote": "",
    "Failed to get remotes:\\n{}": "",
    "rev-parse": "",
    "Failed to get HEAD": "",
    "merge-base": "",
    "Failed to get remotes": "",
    "refs/remotes/{remote}/HEAD": "",
    "--symbolic-full-name": "",
    "@{u}": "",
    "add": "",
    "write-tree": "",
    "commit-tree": "",
    "-p": "",
    "Checkpoint": "",
    "restore": "",
    "--source": "",
    "--worktree": "",
    ".": "",
    "read-tree": "",
    "clean": "",
    "-d": "",
    "--force": "",
    "diff-tree": "",
    "--find-renames": "",
    "--patch": "",
    "status": "",
    "--porcelain=v1": "",
    "--untracked-files=all": "",
    "./checkpoint.gitignore": "",
    "\\n": "",
    "?? ": "",
    ".git": "",
    "index": "",
    "info": "",
    "exclude": "",
    "index-{}.tmp": "",
    "GIT_INDEX_FILE": "",
    "Git command failed: {stdout}": "",
    "GIT_ASKPASS": "",
    "SSH_ASKPASS": "",
    "SSH_ASKPASS_REQUIRE": "",
    "force": "",
    "Connecting to host timed out": "",
    "Repo paths must be relative": "",
    "windows": "",
    "\\\\": "",
    "no HEAD": "",
    "*": "",
    "no objectname": "",
    "no parent": "",
    "no refname": "",
    "no upstream": "",
    "no upstream:track": "",
    "no committerdate": "",
    "no contents:subject": "",
    "[": "",
    "missing [": "",
    "]": "",
    ", ": "",
    "gone": "",
    "ahead ": "",
    "behind ": "",
    "repo path should not be empty": "",
    "repo path `{}` should be relative, not a windows prefix": "",
    "repo path `{}` should be relative": "",
    "repo path `{}` should not start with `.`": "",
    "repo path `{}` should not start with `..`": "",
    "GIT_AUTHOR_NAME": "",
    "Zed": "",
    "GIT_AUTHOR_EMAIL": "",
    "hi@zed.dev": "",
    "GIT_COMMITTER_NAME": "",
    "GIT_COMMITTER_EMAIL": "",
    "file": "",
    "initial": "",
    "Initial commit": "",
    "modified before checkpoint": "",
    "new_file_before_checkpoint": "",
    "1": "",
    "modified after checkpoint": "",
    "Commit after checkpoint": "",
    "new_file_after_checkpoint": "",
    "2": "",
    "foo": "",
    "bar": "",
    "baz": "",
    "qux": "",
    "file1": "",
    "content1": "",
    "file2": "",
    "content2": "",
    "main.rs": "",
    "binary.o": "",
    "fn main() {}": "",
    "some binary file here": "",
    "fn main() { println!(\\\"Modified\\\"); }": "",
    "Modified binary file": "",
    "help: octal escapes are not supported, `\\0` is always null": "",
    "*\\0060964da10574cd9bf06463a53bf6e0769c5c45e\\0\\0refs/heads/zed-patches\\0refs/remotes/origin/zed-patches\\0\\01733187470\\0generated protobuf\\n": "",
    "refs/heads/zed-patches": "",
    "refs/remotes/origin/zed-patches": "",
    "060964da10574cd9bf06463a53bf6e0769c5c45e": "",
    "generated protobuf": "",
    "gc": "",
    "--prune": ""
  },
  "zed/crates/git/src/status.rs": {
    "Invalid status code: {byte}": "",
    "Invalid unmerged status code: {byte}": "",
    " ": "",
    "summary": "",
    "Unexpected duplicated status entries: {a_status:?} and {b_status:?}": ""
  },
  "zed/crates/git_hosting_providers/src/providers/codeberg.rs": {
    "https://codeberg.org/api/v1/repos/{repo_owner}/{repo}/git/commits/{commit}": "",
    "Content-Type": "",
    "application/json": "",
    "CODEBERG_TOKEN": "",
    "Authorization": "",
    "Bearer {}": "",
    "error fetching Codeberg commit details at {:?}": "",
    "status error {}, response: {text:?}": "",
    "failed to deserialize Codeberg commit details": "",
    "Codeberg": "",
    "https://codeberg.org": "",
    "L{line}": "",
    "L{start_line}-L{end_line}": "",
    "codeberg.org": "",
    ".git": "",
    "{owner}/{repo}/commit/{sha}": "",
    "{owner}/{repo}/src/commit/{sha}/{path}": "",
    "git@codeberg.org:zed-industries/zed.git": "",
    "zed-industries": "",
    "zed": "",
    "https://codeberg.org/zed-industries/zed.git": "",
    "faa6f979be417239b2e070dbbf6392b909224e0b": "",
    "crates/editor/src/git/permalink.rs": "",
    "https://codeberg.org/zed-industries/zed/src/commit/faa6f979be417239b2e070dbbf6392b909224e0b/crates/editor/src/git/permalink.rs": "",
    "https://codeberg.org/zed-industries/zed/src/commit/faa6f979be417239b2e070dbbf6392b909224e0b/crates/editor/src/git/permalink.rs#L7": "",
    "https://codeberg.org/zed-industries/zed/src/commit/faa6f979be417239b2e070dbbf6392b909224e0b/crates/editor/src/git/permalink.rs#L24-L48": ""
  },
  "zed/crates/git_hosting_providers/src/providers/github.rs": {
    "\\(#(\\d+)\\)$": "",
    "GitHub": "",
    "https://github.com": "",
    "github.com": "",
    "the GitHub instance is not self-hosted": "",
    "github": "",
    "not a GitHub URL": "",
    "GitHub Self-Hosted": "",
    "https://{}": "",
    "failed to get host from github base url": "",
    "https://api.{host}/repos/{repo_owner}/{repo}/commits/{commit}": "",
    "Content-Type": "",
    "application/json": "",
    "GITHUB_TOKEN": "",
    "Authorization": "",
    "Bearer {}": "",
    "error fetching GitHub commit details at {:?}": "",
    "status error {}, response: {text:?}": "",
    "failed to deserialize GitHub commit details": "",
    "L{line}": "",
    "L{start_line}-L{end_line}": "",
    ".git": "",
    "{owner}/{repo}/commit/{sha}": "",
    "{owner}/{repo}/blob/{sha}/{path}": "",
    ".md": "",
    "plain=1": "",
    "/{}/{}/pull/{}": "",
    "size=128": "",
    "git@github.com:zed-industries/zed.git": "",
    "git@github.my-enterprise.com:zed-industries/zed.git": "",
    "https://github.my-enterprise.com": "",
    "https://github.my-enterprise.com/zed-industries/zed.git": "",
    "zed-industries": "",
    "zed": "",
    "https://github.com/zed-industries/zed.git": "",
    "https://jlannister@github.com/some-org/some-repo.git": "",
    "some-org": "",
    "some-repo": "",
    "e6ebe7974deb6bb6cc0e2595c8ec31f0c71084b7": "",
    "crates/editor/src/git/permalink.rs": "",
    "https://github.com/zed-industries/zed/blob/e6ebe7974deb6bb6cc0e2595c8ec31f0c71084b7/crates/editor/src/git/permalink.rs": "",
    "b2efec9824c45fcc90c9a7eb107a50d1772a60aa": "",
    "crates/zed/src/main.rs": "",
    "https://github.com/zed-industries/zed/blob/b2efec9824c45fcc90c9a7eb107a50d1772a60aa/crates/zed/src/main.rs": "",
    "https://github.com/zed-industries/zed/blob/e6ebe7974deb6bb6cc0e2595c8ec31f0c71084b7/crates/editor/src/git/permalink.rs#L7": "",
    "https://github.com/zed-industries/zed/blob/e6ebe7974deb6bb6cc0e2595c8ec31f0c71084b7/crates/editor/src/git/permalink.rs#L24-L48": "",
    "This does not contain a pull request": "",
    "\n            project panel: do not expand collapsed worktrees on ": "",
    " (#10687)\n\n            Fixes #10597\n\n            Release Notes:\n\n            - Fixed ": "",
    " expanding collapsed worktrees.\n            ": "",
    "https://github.com/zed-industries/zed/pull/10687": "",
    "\n            Follow-up to #10687 to fix problems\n\n            See the original PR, this is a fix.\n            ": ""
  },
  "zed/crates/git_hosting_providers/src/providers/gitlab.rs": {
    "GitLab": "",
    "https://gitlab.com": "",
    "gitlab.com": "",
    "the GitLab instance is not self-hosted": "",
    "gitlab": "",
    "not a GitLab URL": "",
    "GitLab Self-Hosted": "",
    "https://{}": "",
    "L{line}": "",
    "L{start_line}-{end_line}": "",
    ".git": "",
    "/": "",
    "{owner}/{repo}/-/commit/{sha}": "",
    "{owner}/{repo}/-/blob/{sha}/{path}": "",
    ".md": "",
    "plain=1": "",
    "https://gitlab.com/zed-industries/zed.git": "",
    "git@gitlab.com:zed-industries/zed.git": "",
    "zed-industries": "",
    "zed": "",
    "git@gitlab.my-enterprise.com:zed-industries/zed.git": "",
    "https://gitlab.my-enterprise.com/group/subgroup/zed.git": "",
    "group/subgroup": "",
    "e6ebe7974deb6bb6cc0e2595c8ec31f0c71084b7": "",
    "crates/editor/src/git/permalink.rs": "",
    "https://gitlab.com/zed-industries/zed/-/blob/e6ebe7974deb6bb6cc0e2595c8ec31f0c71084b7/crates/editor/src/git/permalink.rs": "",
    "https://gitlab.com/zed-industries/zed/-/blob/e6ebe7974deb6bb6cc0e2595c8ec31f0c71084b7/crates/editor/src/git/permalink.rs#L7": "",
    "https://gitlab.com/zed-industries/zed/-/blob/e6ebe7974deb6bb6cc0e2595c8ec31f0c71084b7/crates/editor/src/git/permalink.rs#L24-48": "",
    "git@gitlab.some-enterprise.com:zed-industries/zed.git": "",
    "https://gitlab.some-enterprise.com/zed-industries/zed/-/blob/e6ebe7974deb6bb6cc0e2595c8ec31f0c71084b7/crates/editor/src/git/permalink.rs": "",
    "https://gitlab-instance.big-co.com/zed-industries/zed.git": "",
    "b2efec9824c45fcc90c9a7eb107a50d1772a60aa": "",
    "crates/zed/src/main.rs": "",
    "https://gitlab-instance.big-co.com/zed-industries/zed/-/blob/b2efec9824c45fcc90c9a7eb107a50d1772a60aa/crates/zed/src/main.rs": ""
  },
  "zed/crates/git_ui/src/branch_picker.rs": {
    "No active repository": "",
    "-": "",
    "Failed to create branch": "",
    "Select branch...": "",
    "refs/heads/{query}": "",
    "Failed to change branch": "",
    "vcs-menu-{ix}": "",
    "Create branch \\\"{}\\\"…": "",
    "based off {}": "",
    "based off the current branch": "",
    "no commits found": ""
  },
  "zed/crates/git_ui/src/git_panel.rs": {
    "title_case": "",
    "Stage All": "",
    "Unstage All": "",
    "Open Diff": "",
    "Discard Tracked Changes": "",
    "Trash Untracked Files": "",
    "GitPanel": "",
    "Conflicts": "",
    "Tracked": "",
    "Untracked": "",
    "Enter commit message": "",
    "": "",
    "menu": "",
    "ChangesList": "",
    "CommitEditor": "",
    "Failed to open file": "",
    "{e}": "",
    "Are you sure you want to restore {}?": "",
    "Restore": "",
    "Cancel": "",
    "Trash {}?": "",
    "Failed to trash file": "",
    "HEAD": "",
    "checkout": "",
    "\\n": "",
    "\\nand {} more…": "",
    "Discard changes to these files?": "",
    "Trash these files?": "",
    "Failed to trash files": "",
    "add": "",
    "reset": "",
    "Git Committed": "",
    "Git Panel": "",
    "Git Amended": "",
    "Ok": "",
    "There are still conflicts. You must stage these before committing": "",
    "No changes to commit": "",
    "commit": "",
    "Git Uncommitted": "",
    "HEAD^": "",
    "No active repository": "",
    "This commit was already pushed to {}.": "",
    ", ": "",
    "Are you sure?": "",
    "Delete": "",
    "Create": "",
    "Update": "",
    "{} {}": "",
    "Git Commit Message Generated": "",
    "{PROMPT}\\nHere are the changes in this commit:\\n{diff_text}": "",
    "{PROMPT}\\nHere is the user's subject line:\\n{subject}\\nHere are the changes in this commit:\\n{diff_text}\\n": "",
    "commit_message_prompt.txt": "",
    "Pick which remote to fetch": "",
    "Git Fetched": "",
    "git fetch": "",
    "Error while fetching {:?}": "",
    "Unable to initialize a git repository": "",
    "Open a directory first": "",
    "~": "",
    "Where would you like to initialize this git repository?": "",
    "init": "",
    "Git Pulled": "",
    "Failed to get current remote: {}": "",
    "pull": "",
    "git pull {}": "",
    "Error while pulling {:?}": "",
    "Git Pushed": "",
    "push": "",
    "git push {}": "",
    "Error while pushing {:?}": "",
    "No active branch": "",
    "Pick which remote to push to": "",
    "Co-authored-by: ": "",
    " <": "",
    "git {} failed": "",
    "View Log": "",
    "Failed to generate commit message: {err}": "",
    "stdout:\\n{}\\nstderr:\\n{}": "",
    "Open Pull Request": "",
    "Output from git {operation}": "",
    "overflow-menu-trigger": "",
    "arrow-circle": "",
    "Generating Commit...": "",
    "generate-commit-message": "",
    "Generate Commit Message": "",
    "Remove co-authored-by": "",
    "Add co-authored-by": "",
    "co-authors": "",
    "{}:{}{}": "",
    " {} <{}>": "",
    "commit-split-button-right": "",
    "Amend": "",
    "You must resolve conflicts before committing": "",
    "Commit in progress": "",
    "No commit message": "",
    "You do not have write access to this project": "",
    "Amend Tracked": "",
    "Commit": "",
    "Commit Tracked": "",
    "git reset": "",
    "git add --all .": "",
    "No Changes": "",
    "1 Change": "",
    "{} Changes": "",
    "overflow_menu": "",
    "remote-button": "",
    "/": "",
    "commit-editor-container": "",
    "commit-footer": "",
    "expand-commit-editor": "",
    "Open Commit Modal": "",
    "commit-wrapper": "",
    "Cancel amend": "",
    "split-button-left-{}": "",
    "git commit": "",
    "split-button-right-{}": "",
    "This will update your most recent commit. Cancel to make a new one instead.": "",
    "commit-msg-hover": "",
    "undo": "",
    "Uncommit": "",
    "git reset HEAD^ --soft": "",
    "git reset HEAD^": "",
    "No Git repositories": "",
    "Initialize Repository": "",
    "git init": "",
    "git-panel-vertical-scroll": "",
    "git-panel-horizontal-scroll": "",
    "stage-file": "",
    "start-slot": "",
    "entries": "",
    "header_{}": "",
    "no active repo": "",
    "Unstage File": "",
    "Stage File": "",
    "Trash File": "",
    "Restore File": "",
    "Open File": "",
    "entry_{}_{}": "",
    "entry_{}_{}_checkbox_wrapper": "",
    "entry_{}_{}_checkbox": "",
    "Unstage": "",
    "Stage": "",
    "{} section": "",
    "Release shift to {} single entry": "",
    "Shift click to {} section": "",
    "{}/": "",
    "loading git panel": "",
    "git_panel": "",
    " (no branch)": "",
    "repo-selector": "",
    "repository-switcher": "",
    "Switch active repository": "",
    "branch-selector": "",
    "Switch Branch": "",
    "popover-button": "",
    "some-branch": "",
    "origin/some-branch": "",
    "abc123": "",
    "Modify stuff": "",
    "zed/{}": "",
    "repo-{}": "",
    "Action Button States": "",
    "No Branch": "",
    "Remote status unknown": "",
    "No Remote Upstream": "",
    "Not Ahead or Behind": "",
    "Behind remote": "",
    "Ahead of remote": "",
    "Ahead and behind remote": "",
    "Labels": "",
    "Short Branch & Repo": "",
    "zed": "",
    "main": "",
    "Long Branch": "",
    "redesign-and-update-git-ui-list-entry-style": "",
    "Long Repo": "",
    "zed-industries-community-examples": "",
    "gpui": "",
    "Long Repo & Branch": "",
    "Uppercase Repo": "",
    "LICENSES": "",
    "Uppercase Branch": "",
    "update-README": "",
    "/root": "",
    ".git": "",
    "crates": "",
    "gpui.rs": "",
    "fn main() {}": "",
    "util": "",
    "util.rs": "",
    "fn do_it() {}": "",
    "/root/zed/.git": "",
    "crates/gpui/gpui.rs": "",
    "crates/util/util.rs": "",
    "/root/zed/crates/gpui": "",
    "/root/zed/crates/gpui/gpui.rs": "",
    "/root/zed/crates/util/util.rs": ""
  },
  "zed/crates/git_ui/src/git_ui.rs": {
    "Fetch": "",
    "Fetch updates from remote": "",
    "git fetch": "",
    "Push": "",
    "Push committed changes to remote": "",
    "git push": "",
    "Pull": "",
    "git pull": "",
    "Publish": "",
    "Publish branch to remote": "",
    "git push --set-upstream": "",
    "Republish": "",
    "Re-publish branch to remote": "",
    "split-button-right": "",
    "Fetch From": "",
    "Push To": "",
    "Force Push": "",
    "split-button-left-{}": "",
    "split-button-right-{}": "",
    "Modified": "",
    "Added": "",
    "Deleted": "",
    "Conflicted": ""
  },
  "zed/crates/git_ui/src/project_diff.rs": {
    "Git Diff Opened": "",
    "Git Panel": "",
    "Action": "",
    "project diff editor should have a conflict addon": "",
    "test-support": "",
    "Project Diff": "",
    "Uncommitted Changes": "",
    "Project Diff Opened": "",
    "EmptyPane": "",
    "GitDiff": "",
    "No uncommitted changes": "",
    "Remote up to date": "",
    "project-diff-close-button": "",
    "Close": "",
    "ProjectDiff": "",
    "stage": "",
    "Toggle Staged": "",
    "Stage": "",
    "Stage and go to next hunk": "",
    "unstage": "",
    "Unstage": "",
    "Unstage and go to next hunk": "",
    "undo": "",
    "up": "",
    "Go to previous hunk": "",
    "down": "",
    "Go to next hunk": "",
    "unstage-all": "",
    "Unstage All": "",
    "Unstage all changes": "",
    "Unstaged": "",
    "stage-all": "",
    "Stage All": "",
    "Stage all changes": "",
    "commit": "",
    "Commit": "",
    "{} Commits Ahead": "",
    "Push your changes to {}": "",
    "push": "",
    "Publish Branch": "",
    "Create {} on remote": "",
    "publish": "",
    "Remote status unknown": "",
    "No Repository": "",
    "No Changes": "",
    "some-branch": "",
    "origin/some-branch": "",
    "abc123": "",
    "Modify stuff": "",
    "No Repo": "",
    "Unknown Upstream": "",
    "Ahead of Remote": "",
    "windows": "",
    "/project": "",
    ".git": "",
    "foo.txt": "",
    "FOO\\n": "",
    "/project/.git": "",
    "foo\\n": "",
    "deadbeef": "",
    "\n                - foo\n                + ˇFOO\n            ": "",
    "ˇ": "",
    "/project/foo.txt": "",
    "bar": "",
    "BAR\\n": "",
    "foo": "",
    "bar\\n": "",
    "\n                - bar\n                + BAR\n\n                - ˇfoo\n                + FOO\n            ": "",
    "\n                - ˇbar\n                + BAR\n\n                - foo\n                + FOO\n            ": "",
    "modified\\n": "",
    "/project/foo": "",
    "original\\n": "",
    "\n                - original\n                + ˇmodified\n            ": "",
    "different\\n": "",
    "\n                - original\n                + different\n                  ˇ": "",
    "/a": "",
    "a.txt": "",
    "created\\n": "",
    "b.txt": "",
    "really changed\\n": "",
    "c.txt": "",
    "unchanged\\n": "",
    "/a/.git": "",
    "before\\n": "",
    "d.txt": "",
    "deleted\\n": "",
    "\n            [EXCERPT]\n            before\n            really changed\n            [EXCERPT]\n            [FOLDED]\n            [EXCERPT]\n            ˇcreated\n        ": "",
    "\n            [EXCERPT]\n            before\n            really changed\n            [EXCERPT]\n            ˇ[FOLDED]\n            [EXCERPT]\n            created\n        ": "",
    "\n            [EXCERPT]\n            ˇbefore\n            really changed\n            [EXCERPT]\n            [FOLDED]\n            [EXCERPT]\n            created\n        ": "",
    "\n            #[rustfmt::skip]\n            fn main() {\n                let x = 0.0; // this line will be removed\n                // 1\n                // 2\n                // 3\n                let y = 0.0; // this line will be removed\n                // 1\n                // 2\n                // 3\n                let arr = [\n                    0.0, // this line will be removed\n                    0.0, // this line will be removed\n                    0.0, // this line will be removed\n                    0.0, // this line will be removed\n                ];\n            }\n        ": "",
    "\n            #[rustfmt::skip]\n            fn main() {\n                // 1\n                // 2\n                // 3\n                // 1\n                // 2\n                // 3\n                let arr = [\n                ];\n            }\n        ": "",
    "main.rs": "",
    "[EXCERPT]\\nˇ{git_contents}": "",
    "<<<<<<< x\\nours\\n=======\\ntheirs\\n>>>>>>> y\\n": "",
    "ours\\n": ""
  },
  "zed/crates/git_ui/src/remote_output.rs": {
    "fetch": "",
    "pull": "",
    "push": "",
    "Already up to date": "",
    "Synchronized with {}": "",
    "Synchronized with remotes": "",
    "Failed to get last line of output": "",
    "Failed to get first word of last line": "",
    "Everything up to date": "",
    "Updating": "",
    "Received {} file change{} from {}": "",
    "": "",
    "s": "",
    "Fast forwarded from {}": "",
    "Merge": "",
    "Merged {} file change{} from {}": "",
    "Merged from {}": "",
    "Successfully rebased": "",
    "Successfully rebased from {}": "",
    "Successfully pulled from {}": "",
    "* [new branch]": "",
    "Create a pull request": "",
    "Published {} to {}": "",
    "Pushed {} to {}": ""
  },
  "zed/crates/go_to_line/src/cursor_position.rs": {
    "1": "",
    "before the first character": "",
    "added 1": "",
    "line": "",
    "selection": "",
    "character": "",
    " (": "",
    ", ": "",
    "s": "",
    "": "",
    "{count} {name}{plural_suffix}": "",
    "{}{FILE_ROW_COLUMN_DELIMITER}{}": "",
    "go-to-line-column": "",
    "Go to Line/Column": "",
    "snake_case": "",
    "line_indicator_format": ""
  },
  "zed/crates/go_to_line/src/go_to_line.rs": {
    "{line}{FILE_ROW_COLUMN_DELIMITER}{column}": "",
    "Current Line: {} of {} (column {})": "",
    "Go to line {line}, character {character}": "",
    "Go to line {line}": "",
    "GoToLine": "",
    "/dir": "",
    "a.rs": "",
    "\n                    struct SingleLine; // display line 0\n                                       // display line 1\n                    struct MultiLine { // display line 2\n                        field_1: i32,  // display line 3\n                        field_2: i32,  // display line 4\n                    }                  // display line 5\n                                       // display line 6\n                    struct Another {   // display line 7\n                        field_1: i32,  // display line 8\n                        field_2: i32,  // display line 9\n                        field_3: i32,  // display line 10\n                        field_4: i32,  // display line 11\n                    }                  // display line 12\n                ": "",
    "/dir/a.rs": "",
    "Initially opened go to line modal should not highlight any rows": "",
    "1": "",
    "Go to line modal should highlight a row, corresponding to the query": "",
    "8": "",
    "If the query is too large, the last row should be highlighted": "",
    "After cancelling and closing the modal, no rows should be highlighted": "",
    "Reopened modal should not highlight any rows": "",
    "5": "",
    "After confirming and closing the modal, no rows should be highlighted": "",
    "ēlo": "",
    "missing cursor position item": "",
    "No selections should be initially": "",
    "After selecting a text with multibyte unicode characters, the character count should be correct": "",
    "ēlo你好": "",
    "Beginning of the line should be at first line, before any characters": "",
    "Wrong position for char '{c}' in string '{text}'": "",
    "After reaching the end of the text, position should not change when moving right": "",
    "When going to {point:?}, expecting the cursor to be at char '{c}' in string '{text}'": "",
    "When going into too large point, should go to the end of the text": "",
    "No position found": "",
    "No placeholder text": "",
    "{}:{}": "",
    "Expected one caret selection but got: {selections:?}": "",
    "Expected a single caret selection, but got: {selection:?}": ""
  },
  "zed/crates/google_ai/src/google_ai.rs": {
    "https://generativelanguage.googleapis.com": "",
    "{api_url}/v1beta/models/{model_id}:streamGenerateContent?alt=sse&key={api_key}": "",
    "Content-Type": "",
    "application/json": "",
    "data: ": "",
    "Error parsing JSON: {error:?}\\n{line:?}": "",
    "error during streamGenerateContent, status code: {:?}, body: {}": "",
    "{api_url}/v1beta/models/{model_id}:countTokens?key={api_key}": "",
    "error during countTokens, status code: {:?}, body: {}": "",
    "Model must be specified": "",
    "Request must contain at least one content item": "",
    "User content must contain at least one part": "",
    "generateContent": "",
    "streamGenerateContent": "",
    "countTokens": "",
    "embedContent": "",
    "batchEmbedContents": "",
    "camelCase": "",
    "ModelName::is_empty": "",
    "Option::is_none": "",
    "schemars": "",
    "HARM_CATEGORY_UNSPECIFIED": "",
    "HARM_CATEGORY_DEROGATORY": "",
    "HARM_CATEGORY_TOXICITY": "",
    "HARM_CATEGORY_VIOLENCE": "",
    "HARM_CATEGORY_SEXUAL": "",
    "HARM_CATEGORY_MEDICAL": "",
    "HARM_CATEGORY_DANGEROUS": "",
    "HARM_CATEGORY_HARASSMENT": "",
    "HARM_CATEGORY_HATE_SPEECH": "",
    "HARM_CATEGORY_SEXUALLY_EXPLICIT": "",
    "HARM_CATEGORY_DANGEROUS_CONTENT": "",
    "SCREAMING_SNAKE_CASE": "",
    "HARM_BLOCK_THRESHOLD_UNSPECIFIED": "",
    "HARM_PROBABILITY_UNSPECIFIED": "",
    "lowercase": "",
    "models/": "",
    "{MODEL_NAME_PREFIX}{}": "",
    "Expected model name to begin with {}, got: {}": "",
    "gemini-1.5-pro": "",
    "gemini-1.5-flash": "",
    "gemini-2.0-pro-exp": "",
    "gemini-2.0-flash": "",
    "gemini-2.0-flash-thinking-exp": "",
    "gemini-2.0-flash-lite-preview": "",
    "gemini-2.5-pro-exp-03-25": "",
    "gemini-2.5-pro-preview-03-25": "",
    "gemini-2.5-flash-preview-04-17": "",
    "gemini-2.5-flash-preview-latest": "",
    "gemini-2.5-flash-preview-05-20": "",
    "gemini-2.5-pro-preview-latest": "",
    "gemini-2.5-pro-preview-06-05": "",
    "custom": "",
    "Gemini 1.5 Pro": "",
    "Gemini 1.5 Flash": "",
    "Gemini 2.0 Pro": "",
    "Gemini 2.0 Flash": "",
    "Gemini 2.0 Flash Thinking": "",
    "Gemini 2.0 Flash Lite": "",
    "Gemini 2.5 Pro Exp": "",
    "Gemini 2.5 Pro Preview (0325)": "",
    "Gemini 2.5 Flash Preview (0417)": "",
    "Gemini 2.5 Flash Preview": "",
    "Gemini 2.5 Pro Preview": "",
    "{}": ""
  },
  "zed/crates/gpui/examples/hello_world.rs": {
    "Hello, {}!": "",
    "World": ""
  },
  "zed/crates/gpui/examples/image/image.rs": {
    "main": "",
    "Image loaded from a local file": "",
    "Image loaded from a remote resource": "",
    "Image loaded from an asset": "",
    "Auto Width": "",
    "https://picsum.photos/800/400": "",
    "Auto Height": "",
    "image with max width 100%": "",
    "CARGO_MANIFEST_DIR": "",
    "examples": "",
    "gpui example": "",
    "cmd-q": "",
    "Image": "",
    "Quit": "",
    "Image Example": "",
    "examples/image/app-icon.png": "",
    "image/color.svg": ""
  },
  "zed/crates/gpui/examples/set_menus.rs": {
    "Set Menus Example": "",
    "set_menus": "",
    "Quit": "",
    "Gracefully quitting the application . . .": ""
  },
  "zed/crates/gpui/examples/uniform_list.rs": {
    "entries": "",
    "clicked Item {item:?}": "",
    "Item {item}": ""
  },
  "zed/crates/gpui/examples/window_positioning.rs": {
    "origin: {}, {} size: {}, {}": "",
    "cx.bounds() origin: {}, {} size {}, {}": "",
    "Top Left {:?}": "",
    "Top Right {:?}": "",
    "Bottom Left {:?}": "",
    "Bottom Right {:?}": "",
    "Top Center {:?}": "",
    "Left Center {:?}": "",
    "Center {:?}": "",
    "Right Center {:?}": "",
    "Bottom Center {:?}": ""
  },
  "zed/crates/gpui/src/elements/animation.rs": {
    "delta should always be between 0 and 1": "",
    "should only be called once": ""
  },
  "zed/crates/gpui/src/elements/div.rs": {
    "DragMoveEvent is only valid when the stored active drag is of the same type.": "",
    "inspector": "",
    "calling on_drag more than once on the same element is not supported": "",
    "calling on_hover more than once on the same element is not supported": "",
    "calling tooltip more than once on the same element is not supported": "",
    "hover style already set": "",
    "test-support": "",
    "{:?}": "",
    "This element was created at:\\n{}:{}:{}": "",
    "checked for type drag state type above": ""
  },
  "zed/crates/gpui/src/action.rs": {
    "dyn Action": "",
    "name": "",
    "Didn't find an action named \\\"{name}\\\"": "",
    "Error while building action \\\"{name}\\\": {error}": "",
    "no action type registered for {type_id:?}": "",
    "All actions in all_names should be registered": "",
    "action generated by `gpui::actions!`": "",
    "action generated by `gpui::action_as!`": "",
    "action, generated by `gpui::action_with_deprecated_aliases!`": "",
    "::": "",
    " is an internal action, so cannot be built from JSON.": ""
  },
  "zed/crates/gpui/src/app.rs": {
    "test-support": "",
    "inspector": "",
    "TRACK_THREAD_BORROWS": "",
    "borrowed {thread_id:?}": "",
    "dropped borrow from {thread_id:?}": "",
    "dropped {thread_id:?}": "",
    "GPUI was compiled in test mode": "",
    "must construct App on main thread": "",
    "timed out waiting on app_will_quit": "",
    "invalid event type": "",
    "linux": "",
    "freebsd": "",
    "All windows should be off the stack when flushing effects": "",
    "window not found": "",
    "Can't spawn on main thread after on_app_quit": "",
    "no state of type {} exists": "",
    "no global added for {}": "",
    "no global registered of type {}": "",
    "invalid entity type": "",
    "attempted to read a window that is already on the stack": "",
    "root view's type has changed": "",
    "Notify({})": "",
    "Emit({:?})": "",
    "RefreshWindows": "",
    "NotifyGlobalObservers({:?})": "",
    "Defer(..)": "",
    "EntityCreated({:?})": "",
    "No HttpClient available": ""
  },
  "zed/crates/gpui/src/arena.rs": {
    "not enough space in Arena": "",
    "attempted to dereference an ArenaRef after its Arena was cleared": ""
  },
  "zed/crates/gpui/src/asset_cache.rs": {
    "Failed to load asset: {}": ""
  },
  "zed/crates/gpui/src/color.rs": {
    "rgba({:#010x})": "",
    "a string in the format #rrggbb or #rrggbbaa": "",
    "Rgba": "",
    "^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$": "",
    "#{r:02x}{g:02x}{b:02x}{a:02x}": "",
    "rgb": "",
    "rgba": "",
    "rrggbb": "",
    "rrggbbaa": "",
    "Expected #rgb, #rgba, #rrggbb, or #rrggbbaa": "",
    "invalid unicode characters in color": "",
    "": "",
    "invalid RGBA hex color: '{value}'. {EXPECTED_FORMATS}": "",
    "{INVALID_UNICODE}: r component of #rgb/#rgba for value: '{value}'": "",
    "{INVALID_UNICODE}: g component of #rgb/#rgba for value: '{value}'": "",
    "{INVALID_UNICODE}: b component of #rgb/#rgba for value: '{value}'": "",
    "{INVALID_UNICODE}: a component of #rgba for value: '{value}'": "",
    "{}: r component of #rrggbb/#rrggbbaa for value: '{}'": "",
    "{INVALID_UNICODE}: g component of #rrggbb/#rrggbbaa for value: '{value}'": "",
    "{INVALID_UNICODE}: b component of #rrggbb/#rrggbbaa for value: '{value}'": "",
    "{INVALID_UNICODE}: a component of #rrggbbaa for value: '{value}'": "",
    "hsla({:.2}, {:.2}%, {:.2}%, {:.2})": "",
    "sRGB": "",
    "Oklab": "",
    "Solid({:?})": "",
    "LinearGradient({}, {:?}, {:?})": "",
    "PatternSlash({:?}, {})": "",
    "#f09": "",
    "#f09f": "",
    "#ff0099": "",
    "#ff0099ff": "",
    " #f5f5f5ff   ": "",
    "#DeAdbEeF": ""
  },
  "zed/crates/gpui/src/element.rs": {
    "views": "",
    ".": "",
    "{}": "",
    "inspector": "",
    "must call request_layout only once": "",
    "must call request_layout before prepaint": "",
    "must call prepaint before paint": "",
    "cannot measure after painting": ""
  },
  "zed/crates/gpui/src/executor.rs": {
    "test-support": "",
    "\\nbacktrace of waiting future:\\n{:?}": "",
    "\\n  waiting on: {}\\n": "",
    "parked with nothing left to run{waiting_message}{backtrace_message}": "",
    "parked with nothing let to run": "",
    "local task dropped by a thread that didn't spawn it. Task spawned at {}": "",
    "local task polled by a thread that didn't spawn it. Task spawned at {}": ""
  },
  "zed/crates/gpui/src/key_dispatch.rs": {
    "Editor": "",
    "cmd-z": "",
    "cmd-shift-z": "",
    "cmd-k left": "",
    "Pane": "",
    "node {} was not part of the reused subtree {:?}": "",
    "test::TestAction": "",
    "cmd-n": "",
    "ProjectPanel": "",
    "Workspace": ""
  },
  "zed/crates/gpui/src/platform/linux/platform.rs": {
    "wayland": "",
    "x11": "",
    "zed-github-account": "",
    "Couldn't open file picker due to missing xdg-desktop-portal implementation.": "",
    "Failed to get app path: {:?}": "",
    "Restarting process, using app path: {:?}": "",
    "\n            while kill -0 {pid} 2>/dev/null; do\n                sleep 0.1\n            done\n\n            {app_path}\n            ": "",
    "/bin/bash": "",
    "-c": "",
    "failed to spawn restart script: {:?}": "",
    "activate is not implemented on Linux, ignoring the call": "",
    "hide is not implemented on Linux, ignoring the call": "",
    "hide_other_apps is not implemented on Linux, ignoring the call": "",
    "unhide_other_apps is not implemented on Linux, ignoring the call": "",
    "Open Folder": "",
    "Open File": "",
    "Save File": "",
    "pathbuf should not be nul terminated": "",
    "pick files": "",
    "pick directories": "",
    "xdg-open": "",
    "invoking xdg-open": "",
    "Platform<LinuxPlatform>::path_for_auxiliary_executable is not implemented yet": "",
    "url": "",
    "username": "",
    "Cannot find username in stored credentials": "",
    "register_url_scheme unimplemented": "",
    "Failed to open with dbus: {}": "",
    "XDG_ACTIVATION_TOKEN": "",
    "Failed to open with {:?}: {}": "",
    "": "",
    "LC_CTYPE": "",
    "C": "",
    "left_ptr": "",
    "text": "",
    "crosshair": "",
    "grabbing": "",
    "grab": "",
    "pointer": "",
    "w-resize": "",
    "e-resize": "",
    "ew-resize": "",
    "n-resize": "",
    "s-resize": "",
    "ns-resize": "",
    "nwse-resize": "",
    "nesw-resize": "",
    "col-resize": "",
    "row-resize": "",
    "vertical-text": "",
    "not-allowed": "",
    "alias": "",
    "copy": "",
    "context-menu": "",
    "CursorStyle::None should be handled separately in the client": "",
    "default": "",
    "enter": "",
    "pageup": "",
    "pagedown": "",
    "tab": "",
    "back": "",
    "forward": "",
    "cut": "",
    "paste": "",
    "new": "",
    "open": "",
    "save": "",
    ",": "",
    ".": "",
    "<": "",
    ">": "",
    "/": "",
    "?": "",
    ";": "",
    ":": "",
    "'": "",
    "\\\"": "",
    "[": "",
    "{": "",
    "]": "",
    "}": "",
    "\\\\": "",
    "|": "",
    "`": "",
    "~": "",
    "!": "",
    "@": "",
    "#": "",
    "$": "",
    "%": "",
    "^": "",
    "&": "",
    "*": "",
    "(": "",
    ")": "",
    "-": "",
    "_": "",
    "=": "",
    "+": "",
    "kp_": "",
    "´": "",
    "¯": "",
    "˘": "",
    "˙": "",
    "¨": "",
    "˚": "",
    "˝": "",
    "ˇ": "",
    "¸": "",
    "˛": "",
    "ͅ": "",
    "゙": "",
    "゚": "",
    "̣̣": "",
    "̡": "",
    "̛": "",
    "̶̶": "",
    "̓̓": "",
    "ʽ": "",
    "̏": "",
    "˳": "",
    "̱": "",
    "ꞈ": "",
    "̰": "",
    "̮": "",
    "̤": "",
    "̯": "",
    "̦": "",
    "ə": "",
    "Ə": ""
  },
  "zed/crates/gpui/src/platform/windows/platform.rs": {
    "unable to initialize Windows OLE": "",
    "Error creating bitmap factory.": "",
    "Error creating DirectWriteTextSystem": "",
    "Unable to init GPU context": "",
    "Error retrieve windows version": "",
    "Dock menu for index {action_idx} not found": "",
    "Something went wrong while waiting {:?}": "",
    "\n            $pidToWaitFor = {}\n            $exePath = ": "",
    "\n\n            while ($true) {{\n                $process = Get-Process -Id $pidToWaitFor -ErrorAction SilentlyContinue\n                if (-not $process) {{\n                    Start-Process -FilePath $exePath\n                    break\n                }}\n                Start-Sleep -Seconds 0.1\n            }}\n            ": "",
    "powershell.exe": "",
    "-command": "",
    "failed to spawn restart script: {:?}": "",
    "screen capture not implemented": "",
    "only files": "",
    "only folders": "",
    "unable to parse file path": "",
    "unable to parse file full path: {}": "",
    "not yet implemented": "",
    "register_url_scheme unimplemented": "",
    "open": "",
    "Unable to open target: {}": "",
    "explorer.exe": "",
    "/select,{}": "",
    "Unable to open target in explorer: {}": "",
    "All files": "",
    "*.*": "",
    "unable to get module handle": "",
    "unable to load icon file": "",
    "你好，我是张小白": "",
    "12345": "",
    "abcdef": ""
  },
  "zed/crates/html_to_markdown/src/html_to_markdown.rs": {
    "failed to parse HTML": "",
    "failed to convert HTML to Markdown": "",
    "failed to parse HTML document": ""
  },
  "zed/crates/html_to_markdown/src/markdown_writer.rs": {
    "^\\s*$": "",
    "Failed to create empty_line_regex": "",
    "\\n{3,}": "",
    "\\n": "",
    "\\n\\n": "",
    "": "",
    " ": ""
  },
  "zed/crates/http_client/src/github.rs": {
    "prerelease": "",
    "https://api.github.com/repos/{repo_name_with_owner}/releases": "",
    "error fetching latest release": "",
    "error reading latest release": "",
    "status error {}, response: {text:?}": "",
    "Error deserializing: {err:?}": "",
    "GitHub API response text: {:?}": "",
    "error deserializing latest release: {err:?}": "",
    "finding a prerelease": "",
    "https://api.github.com/repos/{repo_name_with_owner}/releases/tags/{tag}": "",
    "error deserializing GitHub release: {err:?}": "",
    "https://github.com/{repo_name_with_owner}/archive/refs/tags": "",
    "{tag}.{extension}": "",
    "tar.gz": "",
    "gz": "",
    "zip": "",
    "cannot modify url path segments": "",
    "release/2.3.5": "",
    "microsoft/vscode-eslint": "",
    "https://github.com/microsoft/vscode-eslint/archive/refs/tags/release%2F2.3.5.tar.gz": "",
    "https://github.com/microsoft/vscode-eslint/archive/refs/tags/release%2F2.3.5.zip": ""
  },
  "zed/crates/http_client/src/http_client.rs": {
    "test-support": "",
    "Content-Type": "",
    "application/json": "",
    "{}{}": "",
    "https://zed.dev": "",
    "https://api.zed.dev": "",
    "https://staging.zed.dev": "",
    "https://api-staging.zed.dev": "",
    "http://localhost:3000": "",
    "http://localhost:8080": "",
    "https://llm.zed.dev": "",
    "https://llm-staging.zed.dev": "",
    "http://localhost:8787": "",
    "ALL_PROXY": "",
    "all_proxy": "",
    "HTTPS_PROXY": "",
    "https_proxy": "",
    "HTTP_PROXY": "",
    "http_proxy": "",
    "BlockedHttpClient disallowed request": "",
    "http://test.example": "",
    "FakeHttpClient": ""
  },
  "zed/crates/image_viewer/src/image_viewer.rs": {
    "ImageView": "",
    "No image path found": "",
    "Path not found": "",
    "image_viewers": "",
    "Saving image at path {image_path:?}": "",
    "img": ""
  },
  "zed/crates/indexed_docs/src/providers/rustdoc.rs": {
    "rustdoc": "",
    "docs/rust/rustdoc-db.1.mdb": "",
    "Cargo.toml": "",
    "failed to load cargo metadata": "",
    "target/doc": "",
    "_": "",
    "no docs directory for '{crate_name}'. if this is a valid crate name, try running `cargo doc`": "",
    "no cargo doc directory. run `cargo doc`": "",
    "index.html": "",
    "docs-rs": "",
    "docs/rust/docs-rs-db.1.mdb": "",
    "./rustdoc/popular_crates.txt": "",
    "latest": "",
    "{crate_name}/{version}/{crate_name}{item_path}": "",
    "/{}": "",
    "https://docs.rs/{path}": "",
    "error reading docs.rs response body": "",
    "status error {}, response: {text:?}": "",
    "failed to fetch {item:?}: {history:?}": "",
    "failed to fetch {item:?}": "",
    "{package}::{}": ""
  },
  "zed/crates/indexed_docs/src/store.rs": {
    "no indexed docs store found for {provider}": "",
    "rustdoc_entries": "",
    "no docs found for {key}": ""
  },
  "zed/crates/inline_completion_button/src/inline_completion_button.rs": {
    "https://github.com/settings/copilot": "",
    "copilot-error": "",
    "Copilot can't be started: {}": "",
    "Reinstall Copilot": "",
    "GitHub Copilot": "",
    "copilot": "",
    "copilot-icon": "",
    "supermaven": "",
    "Sign In": "",
    "Use Copilot": "",
    "supermaven-icon": "",
    "Read Terms of Service": "",
    "Choose a Plan": "",
    "Sign in to use": "",
    "zed-predict-pending-button": "",
    "Edit Predictions": "",
    "Pending ToS Clicked": "",
    "Edit Prediction Status Button": "",
    "Edit Prediction": "",
    "Hidden For This File": "",
    "Disabled For This File": "",
    "zeta": "",
    "pulsating-label": "",
    "Disable Copilot": "",
    "Use Supermaven": "",
    "Show Edit Predictions For": "",
    "This Buffer": "",
    "Edit predictions cannot be toggled for this buffer because they are disabled for {}": "",
    "All Files": "",
    "Display Modes": "",
    "Eager": "",
    "Display predictions inline when there are no language server completions available.": "",
    "Subtle": "",
    "Display predictions inline only when holding a modifier key (alt by default).": "",
    "Privacy Settings": "",
    "Training Data Collection": "",
    "Project identified as open source, and you're sharing data.": "",
    "Project identified as open source, but you're not sharing data.": "",
    "Project not identified as open source. No data captured.": "",
    "Project not identified as open source, and setting turned off.": "",
    "\n                                    })\n                                )\n                                .child(\n                                    h_flex()\n                                        .items_start()\n                                        .pt_2()\n                                        .flex_1()\n                                        .gap_1p5()\n                                        .border_t_1()\n                                        .border_color(cx.theme().colors().border_variant)\n                                        .child(h_flex().flex_shrink_0().h(line_height).child(Icon::new(icon_name).size(IconSize::XSmall).color(icon_color)))\n                                        .child(div().child(msg).w_full().text_sm().text_color(label_color.color(cx)))\n                                )\n                                .into_any_element()\n                        })\n                        .handler(move |_, cx| {\n                            provider.toggle_data_collection(cx);\n\n                            if !enabled {\n                                telemetry::event!(\n                                    ": "",
    ",\n                                    source = ": "",
    "\n                                );\n                            } else {\n                                telemetry::event!(\n                                    ": "",
    "\n                                );\n                            }\n                        })\n                );\n\n                if is_collecting && !is_open_source {\n                    menu = menu.item(\n                        ContextMenuEntry::new(": "",
    ")\n                            .disabled(true)\n                            .icon(IconName::Close)\n                            .icon_color(Color::Error)\n                            .icon_size(IconSize::Small),\n                    );\n                }\n            }\n        }\n\n        menu = menu.item(\n            ContextMenuEntry::new(": "",
    ")\n                .icon(IconName::LockOutlined)\n                .icon_color(Color::Muted)\n                .documentation_aside(DocumentationSide::Left, |_| {\n                    Label::new(indoc!{": "",
    "}).into_any_element()\n                })\n                .handler(move |window, cx| {\n                    if let Some(workspace) = window.root().flatten() {\n                        let workspace = workspace.downgrade();\n                        window\n                            .spawn(cx, async |cx| {\n                                open_disabled_globs_setting_in_editor(\n                                    workspace,\n                                    cx,\n                                ).await\n                            })\n                            .detach_and_log_err(cx);\n                    }\n                }),\n        );\n\n        if !self.editor_enabled.unwrap_or(true) {\n            menu = menu.item(\n                ContextMenuEntry::new(": "",
    ")\n                    .disabled(true)\n                    .icon(IconName::ZedPredictDisabled)\n                    .icon_size(IconSize::Small),\n            );\n        }\n\n        if let Some(editor_focus_handle) = self.editor_focus_handle.clone() {\n            menu = menu\n                .separator()\n                .entry(\n                    ": "",
    ",\n                    Some(Box::new(ShowEditPrediction)),\n                    {\n                        let editor_focus_handle = editor_focus_handle.clone();\n                        move |window, cx| {\n                            editor_focus_handle.dispatch_action(&ShowEditPrediction, window, cx);\n                        }\n                    },\n                )\n                .context(editor_focus_handle);\n        }\n\n        menu\n    }\n\n    fn build_copilot_context_menu(\n        &self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Entity<ContextMenu> {\n        ContextMenu::build(window, cx, |menu, window, cx| {\n            self.build_language_settings_menu(menu, window, cx)\n                .separator()\n                .link(\n                    ": "",
    ",\n                    OpenBrowser {\n                        url: COPILOT_SETTINGS_URL.to_string(),\n                    }\n                    .boxed_clone(),\n                )\n                .action(": "",
    ", copilot::SignOut.boxed_clone())\n        })\n    }\n\n    fn build_supermaven_context_menu(\n        &self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Entity<ContextMenu> {\n        ContextMenu::build(window, cx, |menu, window, cx| {\n            self.build_language_settings_menu(menu, window, cx)\n                .separator()\n                .action(": "",
    ", supermaven::SignOut.boxed_clone())\n        })\n    }\n\n    fn build_zeta_context_menu(\n        &self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Entity<ContextMenu> {\n        ContextMenu::build(window, cx, |mut menu, window, cx| {\n            if let Some(usage) = self\n                .edit_prediction_provider\n                .as_ref()\n                .and_then(|provider| provider.usage(cx))\n            {\n                menu = menu.header(": "",
    ");\n                menu = menu\n                    .custom_entry(\n                        move |_window, cx| {\n                            let used_percentage = match usage.limit {\n                                UsageLimit::Limited(limit) => {\n                                    Some((usage.amount as f32 / limit as f32) * 100.)\n                                }\n                                UsageLimit::Unlimited => None,\n                            };\n\n                            h_flex()\n                                .flex_1()\n                                .gap_1p5()\n                                .children(\n                                    used_percentage.map(|percent| {\n                                        ProgressBar::new(": "",
    ", percent, 100., cx)\n                                    }),\n                                )\n                                .child(\n                                    Label::new(match usage.limit {\n                                        UsageLimit::Limited(limit) => {\n                                            format!(": "",
    ", usage.amount)\n                                        }\n                                        UsageLimit::Unlimited => format!(": "",
    ", usage.amount),\n                                    })\n                                    .size(LabelSize::Small)\n                                    .color(Color::Muted),\n                                )\n                                .into_any_element()\n                        },\n                        move |_, cx| cx.open_url(&zed_urls::account_url(cx)),\n                    )\n                    .when(usage.over_limit(), |menu| -> ContextMenu {\n                        menu.entry(": "",
    ", None, |_window, cx| {\n                            cx.open_url(&zed_urls::account_url(cx))\n                        })\n                    })\n                    .separator();\n            } else if self.user_store.read(cx).account_too_young() {\n                menu = menu\n                    .custom_entry(\n                        |_window, _cx| {\n                            h_flex()\n                                .gap_1()\n                                .child(\n                                    Icon::new(IconName::Warning)\n                                        .size(IconSize::Small)\n                                        .color(Color::Warning),\n                                )\n                                .child(\n                                    Label::new(": "",
    ")\n                                        .size(LabelSize::Small)\n                                        .color(Color::Warning),\n                                )\n                                .into_any_element()\n                        },\n                        |_window, cx| cx.open_url(&zed_urls::account_url(cx)),\n                    )\n                    .entry(\n                        ": "",
    ",\n                        None,\n                        |_window, cx| cx.open_url(&zed_urls::account_url(cx)),\n                    )\n                    .separator();\n            } else if self.user_store.read(cx).has_overdue_invoices() {\n                menu = menu\n                    .custom_entry(\n                        |_window, _cx| {\n                            h_flex()\n                                .gap_1()\n                                .child(\n                                    Icon::new(IconName::Warning)\n                                        .size(IconSize::Small)\n                                        .color(Color::Warning),\n                                )\n                                .child(\n                                    Label::new(": "",
    ")\n                                        .size(LabelSize::Small)\n                                        .color(Color::Warning),\n                                )\n                                .into_any_element()\n                        },\n                        |_window, cx| {\n                            cx.open_url(&zed_urls::account_url(cx))\n                        },\n                    )\n                    .entry(\n                        ": "",
    ",\n                        None,\n                        |_window, cx| {\n                            cx.open_url(&zed_urls::account_url(cx))\n                        },\n                    )\n                    .separator();\n            }\n\n            self.build_language_settings_menu(menu, window, cx).when(\n                cx.has_flag::<PredictEditsRateCompletionsFeatureFlag>(),\n                |this| this.action(": "",
    ", RateCompletions.boxed_clone()),\n            )\n        })\n    }\n\n    pub fn update_enabled(&mut self, editor: Entity<Editor>, cx: &mut Context<Self>) {\n        let editor = editor.read(cx);\n        let snapshot = editor.buffer().read(cx).snapshot(cx);\n        let suggestion_anchor = editor.selections.newest_anchor().start;\n        let language = snapshot.language_at(suggestion_anchor);\n        let file = snapshot.file_at(suggestion_anchor).cloned();\n        self.editor_enabled = {\n            let file = file.as_ref();\n            Some(\n                file.map(|file| {\n                    all_language_settings(Some(file), cx)\n                        .edit_predictions_enabled_for_file(file, cx)\n                })\n                .unwrap_or(true),\n            )\n        };\n        self.editor_show_predictions = editor.edit_predictions_enabled();\n        self.edit_prediction_provider = editor.edit_prediction_provider();\n        self.language = language.cloned();\n        self.file = file;\n        self.editor_focus_handle = Some(editor.focus_handle(cx));\n\n        cx.notify();\n    }\n\n    pub fn toggle_menu(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.popover_menu_handle.toggle(window, cx);\n    }\n}\n\nimpl StatusItemView for InlineCompletionButton {\n    fn set_active_pane_item(\n        &mut self,\n        item: Option<&dyn ItemHandle>,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(editor) = item.and_then(|item| item.act_as::<Editor>(cx)) {\n            self.editor_subscription = Some((\n                cx.observe(&editor, Self::update_enabled),\n                editor.entity_id().as_u64() as usize,\n            ));\n            self.update_enabled(editor, cx);\n        } else {\n            self.language = None;\n            self.editor_subscription = None;\n            self.editor_enabled = None;\n        }\n        cx.notify();\n    }\n}\n\nimpl SupermavenButtonStatus {\n    fn to_icon(&self) -> IconName {\n        match self {\n            SupermavenButtonStatus::Ready => IconName::Supermaven,\n            SupermavenButtonStatus::Errored(_) => IconName::SupermavenError,\n            SupermavenButtonStatus::NeedsActivation(_) => IconName::SupermavenInit,\n            SupermavenButtonStatus::Initializing => IconName::SupermavenInit,\n        }\n    }\n\n    fn to_tooltip(&self) -> String {\n        match self {\n            SupermavenButtonStatus::Ready => ": "",
    ".to_string(),\n            SupermavenButtonStatus::Errored(error) => format!(": "",
    ", error),\n            SupermavenButtonStatus::NeedsActivation(_) => ": "",
    ".to_string(),\n            SupermavenButtonStatus::Initializing => ": "",
    ".to_string(),\n        }\n    }\n\n    fn has_menu(&self) -> bool {\n        match self {\n            SupermavenButtonStatus::Ready | SupermavenButtonStatus::NeedsActivation(_) => true,\n            SupermavenButtonStatus::Errored(_) | SupermavenButtonStatus::Initializing => false,\n        }\n    }\n}\n\nasync fn open_disabled_globs_setting_in_editor(\n    workspace: WeakEntity<Workspace>,\n    cx: &mut AsyncWindowContext,\n) -> Result<()> {\n    let settings_editor = workspace\n        .update_in(cx, |_, window, cx| {\n            create_and_open_local_file(paths::settings_file(), window, cx, || {\n                settings::initial_user_settings_content().as_ref().into()\n            })\n        })?\n        .await?\n        .downcast::<Editor>()\n        .unwrap();\n\n    settings_editor\n        .downgrade()\n        .update_in(cx, |item, window, cx| {\n            let text = item.buffer().read(cx).snapshot(cx).text();\n\n            let settings = cx.global::<SettingsStore>();\n\n            // Ensure that we always have ": "",
    "disabled_globs": "",
    "\n            let edits = settings.edits_for_update::<AllLanguageSettings>(&text, |file| {\n                file.edit_predictions\n                    .get_or_insert_with(Default::default)\n                    .disabled_globs\n                    .get_or_insert_with(Vec::new);\n            });\n\n            if !edits.is_empty() {\n                item.edit(edits, cx);\n            }\n\n            let text = item.buffer().read(cx).snapshot(cx).text();\n\n            static DISABLED_GLOBS_REGEX: LazyLock<Regex> = LazyLock::new(|| {\n                Regex::new(r#": "",
    "#).unwrap()\n            });\n            // Only capture [...]\n            let range = DISABLED_GLOBS_REGEX.captures(&text).and_then(|captures| {\n                captures\n                    .name(": ""
  },
  "zed/crates/install_cli/src/install_cli.rs": {
    "cli": "",
    "/usr/local/bin/zed": "",
    "windows": "",
    "/usr/bin/osascript": "",
    "-e": "",
    " with administrator privileges": "",
    "error running osascript": "",
    "If you installed Zed from our official release add ~/.local/bin to your PATH.\\n\\nIf you installed Zed from a different source like your package manager, then you may need to create an alias/symlink manually.\\n\\nDepending on your package manager, the CLI might be named zeditor, zedit, zed-editor or something else.": "",
    "linux": "",
    "freebsd": "",
    "CLI should already be installed": "",
    "Ok": "",
    "error creating CLI symlink": "",
    "Installed `zed` to {}. You can launch {} from your terminal.": "",
    "Error installing zed cli": ""
  },
  "zed/crates/language/src/buffer_tests.rs": {
    "[ \\t]+$": "",
    "Failed to create TRAILING_WHITESPACE_REGEX": "",
    "one\\r\\ntwo\\rthree": "",
    "one\\ntwo\\nthree": "",
    "\\r\\nfour": "",
    "zero\\r\\n": "",
    "zero\\none\\ntwo\\nthree\\nfour": "",
    "Rust": "",
    "rs": "",
    "Rust with longer extension": "",
    "longer.rs": "",
    "Make": "",
    "Makefile": "",
    "mk": "",
    "src/lib.rs": "",
    "src/lib.mk": "",
    "src/lib.longer.rs": "",
    "src/Makefile": "",
    "zed/cars": "",
    "zed/a.cars": "",
    "zed/sumk": "",
    "JavaScript": "",
    "js": "",
    "\\bnode\\b": "",
    "the/script": "",
    "nothing": "",
    "#!/bin/env node": "",
    "TypeScript": "",
    "*longer.ts": "",
    "ecmascript": "",
    "C++": "",
    "c": "",
    "*.dev": "",
    "Dockerfile": "",
    "Dockerfile.*": "",
    "ts": "",
    "ts.ecmascript": "",
    "cpp": "",
    "C": "",
    "foo.ts": "",
    "foo.ts.ecmascript": "",
    "foo.cpp": "",
    "foo.js": "",
    "foo.c": "",
    "foo.longer.ts": "",
    "foo.ecmascript": "",
    "c-plus-plus.dev": "",
    "Dockerfile.dev": "",
    "zed": "",
    "abcdef": "",
    "XYZ": "",
    "u": "",
    "w": "",
    "one two three\\nfour fiˇve six\\nseven eightˇ nine\\nten eleven twelve\\n": "",
    "one two three\\n{\\nfour FIVEˇ six\\n}\\nseven AND EIGHTˇ nine\\nten eleven twelve\\n": "",
    "one two three\\n{\\nˇ}\\nseven AND EIGHTEENˇ nine\\nten eleven twelve\\n": "",
    "zero": "",
    "one  ": "",
    "two": "",
    "three   ": "",
    "four": "",
    "five    ": "",
    "\\n": "",
    "EE": "",
    "EEE": "",
    "zEEero": "",
    "one": "",
    "threeEEE   ": "",
    "five": "",
    "threeEEE": "",
    "fn a() {}": "",
    "(source_file (function_item name: (identifier) ": "",
    "parameters: (parameters) ": "",
    "body: (block)))": "",
    "b: C": "",
    " d; ": "",
    "fn a(b: C) { d; }": "",
    "parameters: (parameters (parameter pattern: (identifier) type: (type_identifier))) ": "",
    "body: (block (expression_statement (identifier)))))": "",
    ".e": "",
    "fn a(b: C) { d.e; }": "",
    "(f)": "",
    "fn a(b: C) { d.e(f); }": "",
    "::<G>": "",
    "fn a(b: C) { d.e::<G>(f); }": "",
    "body: (block (expression_statement (call_expression ": "",
    "function: (generic_function ": "",
    "function: (field_expression value: (identifier) field: (field_identifier)) ": "",
    "type_arguments: (type_arguments (type_identifier))) ": "",
    "arguments: (arguments (identifier)))))))": "",
    "{}": "",
    "(source_file (expression_statement (block)))": "",
    "(document (object))": "",
    "\n        struct Person {\n            name: String,\n            age: usize,\n        }\n\n        mod module {\n            enum LoginState {\n                LoggedOut,\n                LoggingOn,\n                LoggedIn {\n                    person: Person,\n                    time: Instant,\n                }\n            }\n        }\n\n        impl Eq for Person {}\n\n        impl Drop for Person {\n            fn drop(&mut self) {\n                println!(": "",
    ");\n            }\n        }\n    ": "",
    "struct Person": "",
    "name": "",
    "age": "",
    "mod module": "",
    "enum LoginState": "",
    "LoggedOut": "",
    "LoggingOn": "",
    "LoggedIn": "",
    "person": "",
    "time": "",
    "impl Eq for Person": "",
    "impl Drop for Person": "",
    "fn drop": "",
    "oon": "",
    "dp p": "",
    "dpn": "",
    "impl ": "",
    "\n        impl A for B<\n            C\n        > {\n        };\n    ": "",
    "impl A for B<": "",
    "\n            (function_declaration\n                ": "",
    " @context\n                name: (_) @name\n                parameters: (formal_parameters\n                    ": "",
    " @context.extra\n                    ": "",
    " @context.extra)) @item\n            ": "",
    "\n        function a() {}\n        function b(c) {}\n    ": "",
    "function a()": "",
    "function b( )": "",
    "function a": "",
    "\n        /// This is a doc comment\n        /// that spans multiple lines\n        fn annotated_function() {\n            // This is not an annotation\n        }\n\n        // This is a single-line annotation\n        fn another_function() {}\n\n        fn unannotated_function() {}\n\n        // This comment is not an annotation\n\n        fn function_after_blank_line() {}\n    ": "",
    "fn annotated_function": "",
    "/// This is a doc comment\\n/// that spans multiple lines": "",
    "fn another_function": "",
    "// This is a single-line annotation": "",
    "fn unannotated_function": "",
    "fn function_after_blank_line": "",
    "\n        impl Person {\n            fn one() {\n                1\n            }\n\n            fn two() {\n                2\n            }fn three() {\n                3\n            }\n        }\n    ": "",
    "impl Person": "",
    "fn one": "",
    "fn two": "",
    "\n            impl Hello {\n                fn say() -> u8 { return /* ˇhi */ 1 }\n            }": "",
    "/* hi */": "",
    "return /* hi */ 1": "",
    "fn say() -> u8 { return /* hi */ 1 }": "",
    "\n            mod x {\n                moˇd y {\n\n                }\n            }\n            let foo = 1;": "",
    "\n            mod x «{»\n                mod y {\n\n                }\n            «}»\n            let foo = 1;": "",
    "\n            mod x {\n                mod y ˇ{\n\n                }\n            }\n            let foo = 1;": "",
    "\n                mod x «{»\n                    mod y {\n\n                    }\n                «}»\n                let foo = 1;": "",
    "\n                mod x {\n                    mod y «{»\n\n                    «}»\n                }\n                let foo = 1;": "",
    "\n            mod x {\n                mod y {\n\n                }ˇ\n            }\n            let foo = 1;": "",
    "\n            mod x {\n                mod y {\n\n                }\n            ˇ}\n            let foo = 1;": "",
    "\n            mod x {\n                mod y {\n\n                }\n            }\n            let fˇoo = 1;": "",
    "\n            mod x {\n                mod y {\n\n                }\n            }\n            let foo = 1;ˇ": "",
    "\n        for (const a in b)ˇ {\n            // a comment that's longer than the for-loop header\n        }": "",
    "\n        for «(»const a in b«)» {\n            // a comment that's longer than the for-loop header\n        }": "",
    "\n        for (const a in b) {ˇ\n            // a comment that's longer than the for-loop header\n        }": "",
    "\n        for (const a in b) «{»\n            // a comment that's longer than the for-loop header\n        «}»": "",
    "fn a() { b(|c| {}) }": "",
    "|": "",
    "|c|": "",
    "|c| {}": "",
    "(|c| {})": "",
    "\\n\\n": "",
    "fn a() {\\n    \\n}": "",
    "b()\\n": "",
    "fn a() {\\n    b()\\n    \\n}": "",
    ".c": "",
    "fn a() {\\n    b()\\n        .c\\n}": "",
    "": "",
    "fn a() {\\n    b()\\n    c\\n}": "",
    "fn a() {\\n\\t\\n}": "",
    "fn a() {\\n\\tb()\\n\\t\\n}": "",
    "fn a() {\\n\\tb()\\n\\t\\t.c\\n}": "",
    "fn a() {\\n\\tb()\\n\\tc\\n}": "",
    "\n            fn a() {\n            c;\n            d;\n            }\n            ": "",
    "\n            fn a() {\n            c«()»;\n            d«()»;\n            }\n            ": "",
    "\n            fn a() {\n            c();\n            d();\n            }\n            ": "",
    "\n            fn a() {\n            c«\n            .f\n            .g()»;\n            d«\n            .f\n            .g()»;\n            }\n            ": "",
    "\n            fn a() {\n            c\n                .f\n                .g();\n            d\n                .f\n                .g();\n            }\n            ": "",
    "\n            fn a() {«\n            »\n            c\n                .f\n                .g();\n            d\n                .f\n                .g();\n            }\n            ": "",
    "\n            fn a() {\n                ˇ\n            c\n                .f\n                .g();\n            d\n                .f\n                .g();\n            }\n            ": "",
    "ˇ": "",
    "\n            fn a() {\n            «»\n            c\n                .f\n                .g();\n            d\n                .f\n                .g();\n            }\n            ": "",
    "\n            fn a() {\n\n            c\n                .f\n                .g();\n            d\n                .f\n                .g();\n            }\n            ": "",
    "second buffer: {:?}": "",
    "\n            fn a() {\n                b();\n                |\n            ": "",
    "\n            fn a() {\n                b();\n                «}»\n            ": "",
    "\n            fn a() {\n                b();\n            }\n            ": "",
    "\n            fn a() {\n                b();\n            «    »}\n            ": "",
    "\n            fn a() {\n                b();\n                }\n            ": "",
    "DONE": "",
    "\n            fn a() {\n                i\n            }\n            ": "",
    "\n            fn a() {\n                i«f let Some(x) = y»\n            }\n            ": "",
    "\n            fn a() {\n                if let Some(x) = y\n            }\n            ": "",
    "\n            fn a() {\n                if let Some(x) = y« {»\n            }\n            ": "",
    "\n            fn a() {\n                if let Some(x) = y {\n            }\n            ": "",
    "\n            fn a() {}\n            ": "",
    "\n            fn a(«\n            b») {}\n            ": "",
    "\n            fn a(\n                b) {}\n            ": "",
    "\n            fn a(\n                ˇ) {}\n            ": "",
    "\n                fn a(\n                ) {}\n            ": "",
    "a\\nb": "",
    "\\n\\n\\n": "",
    "\n            const a: usize = 1;\n            fn b() {\n                if c {\n                    let d = 2;\n                }\n            }\n        ": "",
    "e(\\n    f()\\n);\\n": "",
    "\n                const a: usize = 1;\n                fn b() {\n                    if c {\n                        e(\n                            f()\n                        );\n                        let d = 2;\n                    }\n                }\n            ": "",
    "\n            fn a() {\n                b();\n            }\n        ": "",
    "\n            ": "",
    "\n        ": "",
    "\n            fn a() {\n                b();\n                ": "",
    "\n            }\n            ": "",
    "        ": "",
    "original_indent_columns": "",
    "\n\n                c();\n                    d();\n                        e();\n        ": "",
    "\n            fn a() {\n                b();\n\n                c();\n                    d();\n                        e();\n            }\n            ": "",
    "\n            fn a() {\n                if b() {\n\n                }\n            }\n        ": "",
    "    c\\n        .d()\\n        .e();": "",
    "\n            fn a() {\n                if b() {\n                    c\n                        .d()\n                        .e();\n                }\n            }\n            ": "",
    " ": "",
    "\n            mod numbers {\n                «fn one() {\n                    1\n                }\n            »\n                «fn two() {\n                    2\n                }\n            »\n                «fn three() {\n                    3\n                }\n            »}\n            ": "",
    "fn one() {\\n    101\\n}\\n": "",
    "fn two() {\\n    102\\n}\\n": "",
    "fn three() {\\n    103\\n}\\n": "",
    "\n            mod numbers {\n                fn one() {\n                    101\n                }\n\n                fn two() {\n                    102\n                }\n\n                fn three() {\n                    103\n                }\n            }\n            ": "",
    "\n            * one\n                - a\n                - b\n            * two\n        ": "",
    "Markdown": "",
    "\n            * one\n                - a\n                - b\n\n            * two\n            ": "",
    "HTML": "",
    "\n                <div>ˇ\n                </div>\n                <script>\n                    init({ˇ\n                    })\n                </script>\n                <span>ˇ\n                </span>\n            ": "",
    "\\na": "",
    "\n                <div>\n                  a\n                </div>\n                <script>\n                    init({\n                            a\n                    })\n                </script>\n                <span>\n                  a\n                </span>\n            ": "",
    "\n            class C\n            def a(b, c)\n            puts b\n            puts c\n            rescue\n            puts ": "",
    "\n            exit 1\n            end\n            end\n        ": "",
    "\n                class C\n                  def a(b, c)\n                    puts b\n                    puts c\n                  rescue\n                    puts ": "",
    "\n                    exit 1\n                  end\n                end\n            ": "",
    "fn a() {\\n\\n}": "",
    "fn a() {\\n    \\n\\n}": "",
    "x": "",
    "fn a() {\\n    x\\n    \\n}": "",
    "abc\\ndef\\nghi": "",
    "\\nabc\\ndef\\nghi": "",
    "\\n\\nabc\\ndef\\nghi": "",
    "abc\\ndef\\n\\n\\n\\nghi": "",
    "abc\\ndefghi\\njkl": "",
    "abc\\ndef\\n\\n\\n\\nghi\\njkl": "",
    "abc\\ndef\\n\\n\\nghi\\njkl": "",
    "abc\\ndef\\nghi\\n\\n\\n": "",
    "abc\\ndef\\nghi\\n\\n": "",
    "// ": "",
    "/*": "",
    "*/": "",
    "{": "",
    "}": "",
    "'": "",
    "string": "",
    "comment": "",
    "element": "",
    "{/*": "",
    "*/}": "",
    "\n                (jsx_element) @element\n                (string) @string\n                (comment) @comment.inclusive\n                [\n                    (jsx_opening_element)\n                    (jsx_closing_element)\n                    (jsx_expression)\n                ] @default\n            ": "",
    "\n            a[": "",
    "] = <C d=": "",
    ">\n                <F></F>\n                { g() }\n            </C>; // a comment\n        ": "",
    "b\\\"": "",
    "<F>": "",
    " d=": "",
    "\n                (string_literal) @string\n            ": "",
    "\n            const S: &'static str = ": "",
    ";\n        ": "",
    "ello": "",
    "\n            <ol>\n            <% people.each do |person| %>\n                <li>\n                    <%= person.name %>\n                </li>\n            <% end %>\n            </ol>\n        ": "",
    "ERB": "",
    "<!--": "",
    "-->": "",
    "# ": "",
    "\n            this is an *emphasized* word.\n        ": "",
    "\n            ```rs\n            let a = 2;\n            // let b = 3;\n            ```\n        ": "",
    "abc": "",
    "D": "",
    "E": "",
    "abcDE": "",
    "abcD": "",
    "F": "",
    "abcDF": "",
    "one\\ntwo\\nthree\\n": "",
    "1.5\\n": "",
    "THREE": "",
    "one\\n1.5\\ntwo\\nTHREE\\n": "",
    "ZERO\\n": "",
    "ZERO\\none\\ntwo\\nthree\\n": "",
    "ZERO\\none\\n1.5\\ntwo\\nTHREE\\n": "",
    "2.5\\n": "",
    "ZERO\\none\\ntwo\\n2.5\\nthree\\n": "",
    "ZERO\\none\\n1.5\\ntwo\\n2.5\\nTHREE\\n": "",
    "abcdefghijk": "",
    "ABC": "",
    "HI": "",
    "LMN": "",
    "ABCdefgHIjkLMN": "",
    "abcdefgHIjk": "",
    "hi": "",
    "ABCdefghijkLMN": "",
    "abcdefghijkLMN": "",
    "ABCdefgHIjk": "",
    "\n        fn test_empty() -> bool {\n            false\n        }": "",
    "\n        fn calculate_area(: f64) -> f64 {\n            std::f64::consts::PI * .powi(2)\n        }": "",
    "radius": "",
    "\n                fn calculate_area(radius: f64) -> f64 {\n                    std::f64::consts::PI * radius.powi(2)": "",
    "\n        struct Person {\n            first_name: String,\n        }\n\n        impl Person {\n            fn first_name(&self) -> &String {\n                &self.first_name\n            }\n        }": "",
    "last": "",
    "\n                        firstlast_name: String,\n                    }\n\n                    impl Person {\n                        fn firstlast_name(&self) -> &String {\n                            &self.firstlast_name": "",
    "MIN_PEERS": "",
    "invalid `MIN_PEERS` variable": "",
    "MAX_PEERS": "",
    "invalid `MAX_PEERS` variable": "",
    "OPERATIONS": "",
    "invalid `OPERATIONS` variable": "",
    "Adding initial peer with replica id {}": "",
    "initial text: {:?}": "",
    "buffer {} text: {:?}": "",
    "peer {} clearing active selections": "",
    "peer {} setting active selections: {:?}": "",
    "peer {} setting diagnostics: {:?}": "",
    "Adding new replica {} (replicating from {})": "",
    "New replica {} text: {:?}": "",
    "peer {} (version: {:?}) applying {} ops from the network. {:?}": "",
    "Replica {} version != Replica 0 version": "",
    "Replica {} text != Replica 0 text": "",
    "Replica {} diagnostics != Replica 0 diagnostics": "",
    "Replica {} remote selections != expected selections": "",
    "wrong ranges for text lines:\\n{:?}": "",
    "\n0_isize 123 3.4 4  \nlet word=öäpple.bar你 Öäpple word2-öÄpPlE-Pizza-word ÖÄPPLE word\n    ": "",
    "Pizza": "",
    "piz": "",
    "öäpple": "",
    "Öäpple": "",
    "öÄpPlE": "",
    "ÖÄPPLE": "",
    "öp": "",
    "öÄ": "",
    "öÄ好": "",
    "bar你": "",
    "你": "",
    "let": "",
    "word": "",
    "word2": "",
    "0_isize": "",
    "123": "",
    "3": "",
    "4": "",
    "Ruby": "",
    "rb": "",
    "\n            (class ": "",
    " @end) @indent\n            (method ": "",
    " @end) @indent\n            (rescue) @outdent\n            (then) @indent\n        ": "",
    "\n        (element\n          (start_tag) @start\n          (end_tag)? @end) @indent\n        ": "",
    "\n        (script_element\n            (raw_text) @injection.content\n            (#set! injection.language ": "",
    "))\n        ": "",
    "erb": "",
    "<%#": "",
    "%>": "",
    "\n            (\n                (code) @injection.content\n                (#set! injection.language ": "",
    ")\n                (#set! injection.combined)\n            )\n\n            (\n                (content) @injection.content\n                (#set! injection.language ": "",
    ")\n                (#set! injection.combined)\n            )\n        ": "",
    "\n        (call_expression) @indent\n        (field_expression) @indent\n        (_ ": "",
    " @end) @indent\n        (_ ": "",
    " @end) @indent\n        ": "",
    "\n        (": "",
    " @open ": "",
    " @close)\n        ": "",
    "\n        (function_item\n            body: (_\n                ": "",
    "\n                (_)* @function.inside\n                ": "",
    " )) @function.around\n\n        (line_comment)+ @comment.around\n\n        (block_comment) @comment.around\n        ": "",
    "\n        (line_comment) @annotation\n\n        (struct_item\n            ": "",
    " @context\n            name: (_) @name) @item\n        (enum_item\n            ": "",
    " @context\n            name: (_) @name) @item\n        (enum_variant\n            name: (_) @name) @item\n        (field_declaration\n            name: (_) @name) @item\n        (impl_item\n            ": "",
    " @context\n            trait: (_)? @name\n            ": "",
    "? @context\n            type: (_) @name\n            body: (_ ": "",
    " (_)* ": "",
    ")) @item\n        (function_item\n            ": "",
    " @context\n            name: (_) @name) @item\n        (mod_item\n            ": "",
    " @context\n            name: (_) @name) @item\n        ": "",
    "Json": "",
    " @close)\n        (": "",
    "\n        (object ": "",
    "md": "",
    "\n            (fenced_code_block\n                (info_string\n                    (language) @injection.language)\n                (code_fence_content) @injection.content)\n\n                ((inline) @injection.content\n                (#set! injection.language ": "",
    "Markdown-Inline": "",
    "(emphasis) @emphasis": ""
  },
  "zed/crates/language_selector/src/active_buffer_language.rs": {
    "Unknown": "",
    "change-language": "",
    "Select Language": ""
  },
  "zed/crates/language_selector/src/language_selector.rs": {
    " (current)": "",
    "Select a language…": "",
    "project was dropped": "",
    "buffer was dropped": ""
  },
  "zed/crates/language_models/src/provider/anthropic.rs": {
    "Anthropic": "",
    "type": "",
    "lowercase": "",
    "ANTHROPIC_API_KEY": "",
    "Bearer": "",
    "invalid {PROVIDER_NAME} API key": "",
    "user": "",
    "assistant": "",
    "system": "",
    "gpt-4": "",
    "App state dropped": "",
    "Missing Anthropic API Key": "",
    "anthropic/{}": "",
    "base64": "",
    "image/png": "",
    "System role should never occur here": "",
    "\\n\\n": "",
    "": "",
    "end_turn": "",
    "max_tokens": "",
    "tool_use": "",
    "refusal": "",
    "Unexpected anthropic stop_reason: {stop_reason}": "",
    "sk-ant-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx": "",
    "not signed in": "",
    "Loading credentials...": "",
    "To use Zed's assistant with Anthropic, you need to add an API key. Follow these steps:": "",
    "Create one by visiting": "",
    "Anthropic's settings": "",
    "https://console.anthropic.com/settings/keys": "",
    "Paste your API key below and hit enter to start using the assistant": "",
    "You can also assign the {ANTHROPIC_API_KEY_VAR} environment variable and restart Zed.": "",
    "API key set in {ANTHROPIC_API_KEY_VAR} environment variable.": "",
    "API key configured.": "",
    "reset-key": "",
    "Reset Key": "",
    "To reset your API key, unset the {ANTHROPIC_API_KEY_VAR} environment variable.": "",
    "Some prompt": "",
    "claude-3-5-sonnet": ""
  },
  "zed/crates/language_models/src/provider/bedrock.rs": {
    "amazon-bedrock": "",
    "Amazon Bedrock": "",
    "named_profile": "",
    "sso": "",
    "default": "",
    "type": "",
    "lowercase": "",
    "https://amazonaws.com": "",
    "ZED_ACCESS_KEY_ID": "",
    "ZED_SECRET_ACCESS_KEY": "",
    "ZED_SESSION_TOKEN": "",
    "ZED_AWS_PROFILE": "",
    "ZED_AWS_REGION": "",
    "ZED_AWS_CREDENTIALS": "",
    "ZED_AWS_ENDPOINT": "",
    "Bearer": "",
    "invalid {PROVIDER_NAME} credentials": "",
    "failed to parse credentials": "",
    "us-east-1": "",
    "zed-bedrock-provider": "",
    "initializing Bedrock client": "",
    "Bedrock client not initialized": "",
    "bedrock/{}": "",
    "App State Dropped": "",
    "failed to build reasoning block": "",
    "failed to build Bedrock tool use block": "",
    "[Tool responded with an image, but Zed doesn't support these in Bedrock models yet]": "",
    "failed to build Bedrock tool result block": "",
    "System role should never occur here": "",
    "failed to build Bedrock message": "",
    "\\n\\n": "",
    "LanguageModelToolChoice::None is not supported": "",
    "user": "",
    "assistant": "",
    "system": "",
    "gpt-4": "",
    "REDACTED": "",
    "": "",
    "XXXXXXXXXXXXXXXX": "",
    "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX": "",
    "not signed in": "",
    "Loading credentials...": "",
    "Access Key ID is set in {ZED_BEDROCK_ACCESS_KEY_ID_VAR}, Secret Key is set in {ZED_BEDROCK_SECRET_ACCESS_KEY_VAR}, Region is set in {ZED_BEDROCK_REGION_VAR} environment variables.": "",
    "You are using automatic credentials": "",
    "You are using named profile": "",
    "You are using a single sign on profile": "",
    "You are using static credentials": "",
    "reset-key": "",
    "Reset Key": "",
    "To reset your credentials, unset the {ZED_BEDROCK_ACCESS_KEY_ID_VAR}, {ZED_BEDROCK_SECRET_ACCESS_KEY_VAR}, and {ZED_BEDROCK_REGION_VAR} environment variables.": "",
    "You cannot reset credentials as they're being derived, check Zed settings to understand how": "",
    "To use Zed's assistant with Bedrock, you can set a custom authentication strategy through the settings.json, or use static credentials.": "",
    "But, to access models on AWS, you need to:": "",
    "Grant permissions to the strategy you'll use according to the:": "",
    "Prerequisites": "",
    "https://docs.aws.amazon.com/bedrock/latest/userguide/inference-prereq.html": "",
    "Select the models you would like access to:": "",
    "Bedrock Model Catalog": "",
    "https://us-east-1.console.aws.amazon.com/bedrock/home?region=us-east-1#/modelaccess": "",
    "You can also assign the {ZED_BEDROCK_ACCESS_KEY_ID_VAR}, {ZED_BEDROCK_SECRET_ACCESS_KEY_VAR} AND {ZED_BEDROCK_REGION_VAR} environment variables and restart Zed.": "",
    "Optionally, if your environment uses AWS CLI profiles, you can set {ZED_AWS_PROFILE_VAR}; if it requires a custom endpoint, you can set {ZED_AWS_ENDPOINT_VAR}; and if it requires a Session Token, you can set {ZED_BEDROCK_SESSION_TOKEN_VAR}.": "",
    "Static Keys": "",
    "This method uses your AWS access key ID and secret access key directly.": "",
    "Create an IAM user in the AWS console with programmatic access": "",
    "IAM Console": "",
    "https://us-east-1.console.aws.amazon.com/iam/home?region=us-east-1#/users": "",
    "Attach the necessary Bedrock permissions to this ": "",
    "Copy the access key ID and secret access key when provided": "",
    "Enter these credentials below": "",
    "Access Key ID": "",
    "Secret Access Key": "",
    "Session Token (Optional)": "",
    "Region": ""
  },
  "zed/crates/language_models/src/provider/cloud.rs": {
    "Zed": "",
    "lowercase": "",
    "type": "",
    "{}-thinking": "",
    "{} Thinking": "",
    "failed to fetch Zed models": "",
    "/models": "",
    "Authorization": "",
    "Bearer {token}": "",
    "failed to send list models request": "",
    "error listing models.\\nStatus: {:?}\\nBody: {body}": "",
    "terms_of_service": "",
    "Terms of Service": "",
    "https://zed.dev/terms-of-service": "",
    "accept_terms": "",
    "I accept the Terms of Service": "",
    "To start using Zed AI, please read and accept the": "",
    "/completions": "",
    "Content-Type": "",
    "application/json": "",
    "true": "",
    "Forbidden": "",
    "cloud language model completion failed after {} retries with status {status}: {body}": "",
    "cloud language model request failed with status {status}: {body}": "",
    "zed.dev/{}": "",
    "/count_tokens": "",
    "-thinking": "",
    "snake_case": "",
    "https://zed.dev/pricing": "",
    "You have access to Zed's hosted LLMs through your Zed Pro subscription.": "",
    "You have access to Zed's hosted LLMs through your Zed Pro trial.": "",
    "You have basic access to Zed's hosted LLMs through your Zed Free subscription.": "",
    "Subscribe for access to Zed's hosted LLMs. Start with a 14 day free trial.": "",
    "Subscribe for access to Zed's hosted LLMs.": "",
    "manage_settings": "",
    "Manage Subscription": "",
    "learn_more": "",
    "Learn more": "",
    "upgrade": "",
    "Upgrade": "",
    "Use Zed AI to access hosted language models.": "",
    "sign_in": "",
    "Sign In": ""
  },
  "zed/crates/language_models/src/provider/copilot_chat.rs": {
    "copilot_chat": "",
    "GitHub Copilot Chat": "",
    "Copilot must be enabled for Copilot Chat to work. Please enable Copilot and try again.": "",
    "Received the following error while signing into Copilot: {err}": "",
    "Copilot is still starting, please wait for Copilot to start then try again": "",
    "Unable to authorize with Copilot. Please make sure that you have an active Copilot and Copilot Chat subscription.": "",
    "You have signed out of Copilot. Please sign in to Copilot and try again.": "",
    "Still signing into Copilot...": "",
    "Signing out of GitHub Copilot Chat is currently not supported.": "",
    "copilot_chat/{}": "",
    "Empty prompts aren't allowed. Please provide a non-empty prompt.": "",
    "The final message must be from the user. To provide a system prompt, you must provide the system prompt followed by a user prompt.": "",
    "Response contained no choices": "",
    "Response contained no delta": "",
    "stop": "",
    "tool_calls": "",
    "Unexpected Copilot Chat stop_reason: {stop_reason:?}": "",
    "This should be caught at {} level": "",
    "[Tool responded with an image, but this model does not support vision]": "",
    "noop": "",
    "No operation": "",
    "type": "",
    "object": "",
    "GitHub Copilot API URL": "",
    "GitHub Copilot Models URL": "",
    "GitHub Copilot Auth URL": "",
    "Authorized": "",
    "sign_out": "",
    "Sign Out": "",
    "arrow-circle": "",
    "Copilot Chat requires an active GitHub Copilot subscription. Please ensure Copilot is configured and try again, or use a different Assistant provider.": "",
    "Starting Copilot…": "",
    "Signing into Copilot…": "",
    "Copilot had issues starting. Please try restarting it. If the issue persists, try reinstalling Copilot.": "",
    "To use Zed's assistant with GitHub Copilot, you need to be logged in to GitHub. Note that your GitHub account must have an active Copilot Chat subscription.": "",
    "API URL": "",
    "Auth URL": "",
    "Models list URL": "",
    "sign_in": "",
    "Sign in to use GitHub Copilot": "",
    "You can also assign the {} environment variable and restart Zed.": ""
  },
  "zed/crates/language_models/src/provider/deepseek.rs": {
    "deepseek": "",
    "DeepSeek": "",
    "DEEPSEEK_API_KEY": "",
    "Bearer": "",
    "invalid {PROVIDER_NAME} API key": "",
    "deepseek-chat": "",
    "deepseek-reasoner": "",
    "App state dropped": "",
    "Missing DeepSeek API Key": "",
    "deepseek/{}": "",
    "user": "",
    "assistant": "",
    "system": "",
    "gpt-4": "",
    "Response contained no choices": "",
    "stop": "",
    "tool_calls": "",
    "Unexpected DeepSeek stop_reason: {stop_reason:?}": "",
    "sk-00000000000000000000000000000000": "",
    "": "",
    "Loading credentials...": "",
    "To use DeepSeek in Zed, you need an API key:": "",
    "Get your API key from the": "",
    "DeepSeek console": "",
    "https://platform.deepseek.com/api_keys": "",
    "Paste your API key below and hit enter to start using the assistant": "",
    "Or set the {} environment variable.": "",
    "API key set in {}": "",
    "API key configured": "",
    "reset-key": "",
    "Reset Key": ""
  },
  "zed/crates/language_models/src/provider/google.rs": {
    "google": "",
    "Google AI": "",
    "type": "",
    "lowercase": "",
    "GOOGLE_AI_API_KEY": "",
    "Bearer": "",
    "invalid {PROVIDER_NAME} API key": "",
    "App state dropped": "",
    "Missing Google API key": "",
    "failed to stream completion": "",
    "google/{}": "",
    "image/png": "",
    "output": "",
    "Tool responded with an image": "",
    "STOP": "",
    "MAX_TOKENS": "",
    "Unexpected google finish_reason: {finish_reason}": "",
    "{}-{}": "",
    "user": "",
    "assistant": "",
    "system": "",
    "gpt-4": "",
    "not signed in": "",
    "AIzaSy...": "",
    "": "",
    "Loading credentials...": "",
    "To use Zed's assistant with Google AI, you need to add an API key. Follow these steps:": "",
    "Create one by visiting": "",
    "Google AI's console": "",
    "https://aistudio.google.com/app/apikey": "",
    "Paste your API key below and hit enter to start using the assistant": "",
    "You can also assign the {GOOGLE_AI_API_KEY_VAR} environment variable and restart Zed.": "",
    "API key set in {GOOGLE_AI_API_KEY_VAR} environment variable.": "",
    "API key configured.": "",
    "reset-key": "",
    "Reset Key": "",
    "To reset your API key, unset the {GOOGLE_AI_API_KEY_VAR} environment variable.": ""
  },
  "zed/crates/language_models/src/provider/lmstudio.rs": {
    "https://lmstudio.ai/download": "",
    "https://lmstudio.ai/models": "",
    "https://lmstudio.ai/": "",
    "lmstudio": "",
    "LM Studio": "",
    "authenticated": "",
    "App state dropped": "",
    "lmstudio/{}": "",
    "Response contained no choices": "",
    "stop": "",
    "tool_calls": "",
    "Unexpected OpenAI stop_reason: {stop_reason:?}": "",
    "Run local LLMs like Llama, Phi, and Qwen.": "",
    "Loading models...": "",
    "LM Studio needs to be running with at least one model downloaded.": "",
    "To get your first model, try running `lms get qwen2.5-coder-7b`": "",
    "lmstudio-site": "",
    "download_lmstudio_button": "",
    "Download LM Studio": "",
    "view-models": "",
    "Model Catalog": "",
    "connected": "",
    "Connected": "",
    "retry_lmstudio_models": "",
    "Connect": ""
  },
  "zed/crates/language_models/src/provider/mistral.rs": {
    "mistral": "",
    "Mistral": "",
    "MISTRAL_API_KEY": "",
    "Bearer": "",
    "invalid {PROVIDER_NAME} API key": "",
    "App state dropped": "",
    "Missing Mistral API Key": "",
    "mistral/{}": "",
    "user": "",
    "assistant": "",
    "system": "",
    "gpt-4": "",
    "[Tool responded with an image, but Zed doesn't support these in Mistral models yet]": "",
    " ": "",
    "Response contained no choices": "",
    "stop": "",
    "tool_calls": "",
    "Unexpected Mistral stop_reason: {unexpected:?}": "",
    "Received incomplete tool call: missing id or name": "",
    "0aBCDEFGhIjKLmNOpqrSTUVwxyzabCDE1f2": "",
    "not signed in": "",
    "": "",
    "Loading credentials...": "",
    "To use Zed's assistant with Mistral, you need to add an API key. Follow these steps:": "",
    "Create one by visiting": "",
    "Mistral's console": "",
    "https://console.mistral.ai/api-keys": "",
    "Ensure your Mistral account has credits": "",
    "Paste your API key below and hit enter to start using the assistant": "",
    "You can also assign the {MISTRAL_API_KEY_VAR} environment variable and restart Zed.": "",
    "API key set in {MISTRAL_API_KEY_VAR} environment variable.": "",
    "API key configured.": "",
    "reset-key": "",
    "Reset Key": "",
    "To reset your API key, unset the {MISTRAL_API_KEY_VAR} environment variable.": "",
    "System prompt": "",
    "Hello": "",
    "mistral-small-latest": "",
    "What's in this image?": "",
    "base64data": "",
    "pixtral-12b-latest": "",
    "data:image/png;base64,": ""
  },
  "zed/crates/language_models/src/provider/ollama.rs": {
    "https://ollama.com/download": "",
    "https://ollama.com/library": "",
    "https://ollama.com/": "",
    "ollama": "",
    "Ollama": "",
    "llama3.2:latest": "",
    "authenticated": "",
    "-embed": "",
    "ollama/{}": "",
    "App state dropped": "",
    "{}-{}": "",
    "Get up & running with Llama 3.3, Mistral, Gemma 2, and other LLMs with Ollama.": "",
    "Loading models...": "",
    "Ollama must be running with at least one model installed to use it in the assistant.": "",
    "Once installed, try `ollama run llama3.2`": "",
    "ollama-site": "",
    "download_ollama_button": "",
    "Download Ollama": "",
    "view-models": "",
    "All Models": "",
    "connected": "",
    "Connected": "",
    "retry_ollama_models": "",
    "Connect": ""
  },
  "zed/crates/language_models/src/provider/open_ai.rs": {
    "openai": "",
    "OpenAI": "",
    "OPENAI_API_KEY": "",
    "Bearer": "",
    "invalid {PROVIDER_NAME} API key": "",
    "App state dropped": "",
    "Missing OpenAI API Key": "",
    "openai/{}": "",
    "o1-": "",
    "Response contained no choices": "",
    "stop": "",
    "tool_calls": "",
    "Unexpected OpenAI stop_reason: {stop_reason:?}": "",
    "user": "",
    "assistant": "",
    "system": "",
    "gpt-4o": "",
    "gpt-4": "",
    "sk-000000000000000000000000000000000000000000000000": "",
    "not signed in": "",
    "": "",
    "Loading credentials...": "",
    "To use Zed's assistant with OpenAI, you need to add an API key. Follow these steps:": "",
    "Create one by visiting": "",
    "OpenAI's console": "",
    "https://platform.openai.com/api-keys": "",
    "Ensure your OpenAI account has credits": "",
    "Paste your API key below and hit enter to start using the assistant": "",
    "You can also assign the {OPENAI_API_KEY_VAR} environment variable and restart Zed.": "",
    "Note that having a subscription for another service like GitHub Copilot won't work.": "",
    "API key set in {OPENAI_API_KEY_VAR} environment variable.": "",
    "API key configured.": "",
    "reset-key": "",
    "Reset Key": "",
    "To reset your API key, unset the {OPENAI_API_KEY_VAR} environment variable.": "",
    "message": ""
  },
  "zed/crates/markdown/examples/markdown.rs": {
    "\n# Markdown Example Document\n\n## Headings\nHeadings are created by adding one or more `#` symbols before your heading text. The number of `#` you use will determine the size of the heading.\n\n```\nfunction a(b: T) {\n\n}\n```\n\nRemember, markdown processors may have slight differences and extensions, so always refer to the specific documentation or guides relevant to your platform or editor for the best practices and additional features.\n\n## Images\n\n![Alt Text](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTAiIHZpZXdCb3g9IjAgMCA1NDAgMzAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxzdHlsZT4KICAgIC5ncmVlbi1zaGFwZSB7CiAgICAgIGZpbGw6ICNDNEVFRDA7IC8qIExpZ2h0IG1vZGUgKi8KICAgIH0KCiAgICBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7CiAgICAgIC5ncmVlbi1zaGFwZSB7CiAgICAgICAgZmlsbDogIzEyNTIyNTsgLyogRGFyayBtb2RlICovCiAgICAgIH0KICAgIH0KICA8L3N0eWxlPgogIDxwYXRoIGQ9Ik00MjAgMzBMMzkwIDYwTDQ4MCAxNTBMMzkwIDI0MEwzMzAgMTgwTDMwMCAyMTBMMzkwIDMwMEw1NDAgMTUwTDQyMCAzMFoiIGNsYXNzPSJncmVlbi1zaGFwZSIvPgogIDxwYXRoIGQ9Ik0xNTAgMEwzMCAxMjBMNjAgMTUwTDE1MCA2MEwyMTAgMTIwTDI0MCA5MEwxNTAgMFoiIGNsYXNzPSJncmVlbi1zaGFwZSIvPgogIDxwYXRoIGQ9Ik0zOTAgMEw0MjAgMzBMMTUwIDMwMEwwIDE1MEwzMCAxMjBMMTUwIDI0MEwzOTAgMFoiIGZpbGw9IiMxRUE0NDYiLz4KPC9zdmc+) item one\n\n![other alt text](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTAiIHZpZXdCb3g9IjAgMCA1NDAgMzAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxzdHlsZT4KICAgIC5ncmF5LXNoYXBlIHsKICAgICAgZmlsbDogI0M2QzZDNjsgLyogTGlnaHQgbW9kZSAqLwogICAgfQoKICAgIEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHsKICAgICAgLmdyYXktc2hhcGUgewogICAgICAgIGZpbGw6ICM1NjU2NTY7IC8qIERhcmsgbW9kZSAqLwogICAgICB9CiAgICB9CiAgPC9zdHlsZT4KICA8cGF0aCBkPSJNMTUwIDBMMjQwIDkwTDIxMCAxMjBMMTIwIDMwTDE1MCAwWiIgZmlsbD0iI0YwOTQwOSIvPgogIDxwYXRoIGQ9Ik00MjAgMzBMNTQwIDE1MEw0MjAgMjcwTDM5MCAyNDBMNDgwIDE1MEwzOTAgNjBMNDIwIDMwWiIgY2xhc3M9ImdyYXktc2hhcGUiLz4KICA8cGF0aCBkPSJNMzMwIDE4MEwzMDAgMjEwTDM5MCAzMDBMNDIwIDI3MEwzMzAgMTgwWiIgZmlsbD0iI0YwOTQwOSIvPgogIDxwYXRoIGQ9Ik0xMjAgMzBMMTUwIDYwTDYwIDE1MEwxNTAgMjQwTDEyMCAyNzBMMCAxNTBMMTIwIDMwWiIgY2xhc3M9ImdyYXktc2hhcGUiLz4KICA8cGF0aCBkPSJNMzkwIDBMNDIwIDMwTDE1MCAzMDBMMTIwIDI3MEwzOTAgMFoiIGZpbGw9IiNGMDk0MDkiLz4KPC9zdmc+) item two\n\n![third alt text](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTAiIHZpZXdCb3g9IjAgMCA1NDAgMzAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxzdHlsZT4KICAgIC5ibHVlLXNoYXBlIHsKICAgICAgZmlsbDogI0E4QzdGQTsgLyogTGlnaHQgbW9kZSAqLwogICAgfQoKICAgIEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHsKICAgICAgLmJsdWUtc2hhcGUgewogICAgICAgIGZpbGw6ICMyRDUwOUU7IC8qIERhcmsgbW9kZSAqLwogICAgICB9CiAgICB9CgogICAgLmRhcmtlci1ibHVlLXNoYXBlIHsKICAgICAgICBmaWxsOiAjMUI2RUYzOwogICAgfQoKICAgIEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHsKICAgICAgICAuZGFya2VyLWJsdWUtc2hhcGUgewogICAgICAgICAgICBmaWxsOiAjNDE4NUZGOwogICAgICAgIH0KICAgIH0KCiAgPC9zdHlsZT4KICA8cGF0aCBkPSJNMTUwIDBMMTgwIDMwTDE1MCA2MEwxMjAgMzBMMTUwIDBaIiBjbGFzcz0iYmx1ZS1zaGFwZSIvPgogIDxwYXRoIGQ9Ik0yMTAgNjBMMjQwIDkwTDIxMCAxMjBMMTgwIDkwTDIxMCA2MFoiIGNsYXNzPSJibHVlLXNoYXBlIi8+CiAgPHBhdGggZD0iTTQ1MCA2MEw0ODAgOTBMNDUwIDEyMEw0MjAgOTBMNDUwIDYwWiIgY2xhc3M9ImJsdWUtc2hhcGUiLz4KICA8cGF0aCBkPSJNNTEwIDEyMEw1NDAgMTUwTDUxMCAxODBMNDgwIDE1MEw1MTAgMTIwWiIgY2xhc3M9ImJsdWUtc2hhcGUiLz4KICA8cGF0aCBkPSJNNDUwIDE4MEw0ODAgMjEwTDQ1MCAyNDBMNDIwIDIxMEw0NTAgMTgwWiIgY2xhc3M9ImJsdWUtc2hhcGUiLz4KICA8cGF0aCBkPSJNMzkwIDI0MEw0MjAgMjcwTDM5MCAzMDBMMzYwIDI3MEwzOTAgMjQwWiIgY2xhc3M9ImJsdWUtc2hhcGUiLz4KICA8cGF0aCBkPSJNMzMwIDE4MEwzNjAgMjEwTDMzMCAyNDBMMzAwIDIxMEwzMzAgMTgwWiIgY2xhc3M9ImJsdWUtc2hhcGUiLz4KICA8cGF0aCBkPSJNOTAgNjBMMTIwIDkwTDkwIDEyMEw2MCA5MEw5MCA2MFoiIGNsYXNzPSJibHVlLXNoYXBlIi8+CiAgPHBhdGggZD0iTTM5MCAwTDQyMCAzMEwxNTAgMzAwTDAgMTUwTDMwIDEyMEwxNTAgMjQwTDM5MCAwWiIgY2xhc3M9ImRhcmtlci1ibHVlLXNoYXBlIi8+Cjwvc3ZnPg==) item three\n\n": "",
    "cmd-c": "",
    "TypeScript": "",
    "Zed Plex Sans": "",
    "Zed Plex Mono": "",
    "Zed Mono": "",
    "markdown-example": "",
    "foo": ""
  },
  "zed/crates/media/src/media.rs": {
    "macos": "",
    "error getting sample timing info, code {result}": "",
    "CoreMedia": "",
    "framework": "",
    "C": "",
    "error getting parameter set, code: {result}": "",
    "could not get block buffer data": "",
    "could not create texture cache, code: {result}": "",
    "could not create texture, code: {result}": "",
    "CoreVideo": ""
  },
  "zed/crates/media/build.rs": {
    "macos": "",
    "xcrun": "",
    "--sdk": "",
    "macosx": "",
    "--show-sdk-path": "",
    "cargo:rerun-if-changed=src/bindings.h": "",
    "src/bindings.h": "",
    "-isysroot{}": "",
    "-xobjective-c": "",
    "CMItemIndex": "",
    "CMSampleTimingInfo": "",
    "CMVideoCodecType": "",
    "VTEncodeInfoFlags": "",
    "CMTimeMake": "",
    "kCVPixelFormatType_.*": "",
    "kCVReturn.*": "",
    "VTEncodeInfoFlags_.*": "",
    "kCMVideoCodecType_.*": "",
    "kCMTime.*": "",
    "kCMSampleAttachmentKey_.*": "",
    "unable to generate bindings": "",
    "OUT_DIR": "",
    "bindings.rs": "",
    "couldn't write dispatch bindings": ""
  },
  "zed/crates/node_runtime/src/node_runtime.rs": {
    "NODE_EXTRA_CA_CERTS": "",
    "using Node.js from `node.path` in settings: {:?}": "",
    "failure checking Node.js from `node.path` in settings ({}): {:?}": "",
    "using Node.js found on PATH: {:?}": "",
    "`node.ignore_system_version` is `true` in settings": "",
    "using Zed managed Node.js at {} since {}": "",
    ",\n                            err\n                        )\n                        .into(),\n                    }) as Box<dyn NodeRuntimeTrait>\n                }\n            }\n        } else if let Some(system_node_error) = system_node_error {\n            // failure case not cached, since it's cheap to check again\n            //\n            // TODO: When support is added for setting `options.allow_binary_download`, update this\n            // error message.\n            return Box::new(UnavailableNodeRuntime {\n                error_message: format!(\n                    ": "",
    ",\n                    system_node_error\n                )\n                .into(),\n            });\n        } else {\n            // failure case is cached because it will always happen with these options\n            //\n            // TODO: When support is added for setting `options.allow_binary_download`, update this\n            // error message.\n            Box::new(UnavailableNodeRuntime {\n                error_message: ": "",
    "\n                    .to_string()\n                    .into(),\n            })\n        };\n\n        state.instance = Some(instance.boxed_clone());\n        state.last_options = Some(options);\n        return instance;\n    }\n\n    pub async fn binary_path(&self) -> Result<PathBuf> {\n        self.instance().await.binary_path()\n    }\n\n    pub async fn run_npm_subcommand(\n        &self,\n        directory: &Path,\n        subcommand: &str,\n        args: &[&str],\n    ) -> Result<Output> {\n        let http = self.0.lock().await.http.clone();\n        self.instance()\n            .await\n            .run_npm_subcommand(Some(directory), http.proxy(), subcommand, args)\n            .await\n    }\n\n    pub async fn npm_package_installed_version(\n        &self,\n        local_package_directory: &Path,\n        name: &str,\n    ) -> Result<Option<String>> {\n        self.instance()\n            .await\n            .npm_package_installed_version(local_package_directory, name)\n            .await\n    }\n\n    pub async fn npm_package_latest_version(&self, name: &str) -> Result<String> {\n        let http = self.0.lock().await.http.clone();\n        let output = self\n            .instance()\n            .await\n            .run_npm_subcommand(\n                None,\n                http.proxy(),\n                ": "",
    ",\n                &[\n                    name,\n                    ": "",
    ",\n                    ": "",
    ",\n                ],\n            )\n            .await?;\n\n        let mut info: NpmInfo = serde_json::from_slice(&output.stdout)?;\n        info.dist_tags\n            .latest\n            .or_else(|| info.versions.pop())\n            .with_context(|| format!(": "",
    "))\n    }\n\n    pub async fn npm_install_packages(\n        &self,\n        directory: &Path,\n        packages: &[(&str, &str)],\n    ) -> Result<()> {\n        if packages.is_empty() {\n            return Ok(());\n        }\n\n        let packages: Vec<_> = packages\n            .iter()\n            .map(|(name, version)| format!(": "",
    "))\n            .collect();\n\n        let mut arguments: Vec<_> = packages.iter().map(|p| p.as_str()).collect();\n        arguments.extend_from_slice(&[\n            ": "",
    ",\n            ": "",
    ",\n        ]);\n\n        // This is also wrong because the directory is wrong.\n        self.run_npm_subcommand(directory, ": "",
    ", &arguments)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn should_install_npm_package(\n        &self,\n        package_name: &str,\n        local_executable_path: &Path,\n        local_package_directory: &Path,\n        latest_version: &str,\n    ) -> bool {\n        // In the case of the local system not having the package installed,\n        // or in the instances where we fail to parse package.json data,\n        // we attempt to install the package.\n        if fs::metadata(local_executable_path).await.is_err() {\n            return true;\n        }\n\n        let Some(installed_version) = self\n            .npm_package_installed_version(local_package_directory, package_name)\n            .await\n            .log_err()\n            .flatten()\n        else {\n            return true;\n        };\n\n        let Some(installed_version) = Version::parse(&installed_version).log_err() else {\n            return true;\n        };\n        let Some(latest_version) = Version::parse(latest_version).log_err() else {\n            return true;\n        };\n\n        installed_version < latest_version\n    }\n}\n\nenum ArchiveType {\n    TarGz,\n    Zip,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = ": "",
    ")]\npub struct NpmInfo {\n    #[serde(default)]\n    dist_tags: NpmInfoDistTags,\n    versions: Vec<String>,\n}\n\n#[derive(Debug, Deserialize, Default)]\npub struct NpmInfoDistTags {\n    latest: Option<String>,\n}\n\n#[async_trait::async_trait]\ntrait NodeRuntimeTrait: Send + Sync {\n    fn boxed_clone(&self) -> Box<dyn NodeRuntimeTrait>;\n    fn binary_path(&self) -> Result<PathBuf>;\n\n    async fn run_npm_subcommand(\n        &self,\n        directory: Option<&Path>,\n        proxy: Option<&Url>,\n        subcommand: &str,\n        args: &[&str],\n    ) -> Result<Output>;\n\n    async fn npm_package_installed_version(\n        &self,\n        local_package_directory: &Path,\n        name: &str,\n    ) -> Result<Option<String>>;\n}\n\n#[derive(Clone)]\nstruct ManagedNodeRuntime {\n    installation_path: PathBuf,\n}\n\nimpl ManagedNodeRuntime {\n    const VERSION: &str = ": "",
    ";\n\n    #[cfg(not(windows))]\n    const NODE_PATH: &str = ": "",
    ";\n    #[cfg(windows)]\n    const NODE_PATH: &str = ": "",
    ";\n\n    #[cfg(not(windows))]\n    const NPM_PATH: &str = ": "",
    ";\n    #[cfg(windows)]\n    const NPM_PATH: &str = ": "",
    ";\n\n    async fn install_if_needed(http: &Arc<dyn HttpClient>) -> Result<Self> {\n        log::info!(": "",
    ");\n\n        let os = match consts::OS {\n            ": "",
    " => ": "",
    ",\n            other => bail!(": "",
    "),\n        };\n\n        let arch = match consts::ARCH {\n            ": "",
    "),\n        };\n\n        let version = Self::VERSION;\n        let folder_name = format!(": "",
    ");\n        let node_containing_dir = paths::data_dir().join(": "",
    ");\n        let node_dir = node_containing_dir.join(folder_name);\n        let node_binary = node_dir.join(Self::NODE_PATH);\n        let npm_file = node_dir.join(Self::NPM_PATH);\n        let node_ca_certs = env::var(NODE_CA_CERTS_ENV_VAR).unwrap_or_else(|_| String::new());\n\n        let valid = if fs::metadata(&node_binary).await.is_ok() {\n            let result = util::command::new_smol_command(&node_binary)\n                .env_clear()\n                .env(NODE_CA_CERTS_ENV_VAR, node_ca_certs)\n                .arg(npm_file)\n                .arg(": "",
    ")\n                .args([": "",
    ".into(), node_dir.join(": "",
    ")])\n                .args([": "",
    ")])\n                .output()\n                .await;\n            match result {\n                Ok(output) => {\n                    if output.status.success() {\n                        true\n                    } else {\n                        log::warn!(\n                            ": "",
    ",\n                            node_binary.display(),\n                            output\n                        );\n                        false\n                    }\n                }\n                Err(err) => {\n                    log::warn!(\n                        ": "",
    ",\n                        node_binary.display(),\n                        err\n                    );\n                    false\n                }\n            }\n        } else {\n            false\n        };\n\n        if !valid {\n            _ = fs::remove_dir_all(&node_containing_dir).await;\n            fs::create_dir(&node_containing_dir)\n                .await\n                .context(": "",
    ")?;\n\n            let archive_type = match consts::OS {\n                ": "",
    " | ": "",
    " => ArchiveType::TarGz,\n                ": "",
    " => ArchiveType::Zip,\n                other => bail!(": "",
    "),\n            };\n\n            let version = Self::VERSION;\n            let file_name = format!(\n                ": "",
    ",\n                extension = match archive_type {\n                    ArchiveType::TarGz => ": "",
    ",\n                    ArchiveType::Zip => ": "",
    ",\n                }\n            );\n\n            let url = format!(": "",
    ");\n            log::info!(": "",
    ");\n            let mut response = http\n                .get(&url, Default::default(), true)\n                .await\n                .context(": "",
    ")?;\n            log::info!(": "",
    ");\n\n            let body = response.body_mut();\n            match archive_type {\n                ArchiveType::TarGz => {\n                    let decompressed_bytes = GzipDecoder::new(BufReader::new(response.body_mut()));\n                    let archive = Archive::new(decompressed_bytes);\n                    archive.unpack(&node_containing_dir).await?;\n                }\n                ArchiveType::Zip => extract_zip(&node_containing_dir, body).await?,\n            }\n            log::info!(": "",
    ", node_containing_dir.display())\n        }\n\n        // Note: Not in the `if !valid {}` so we can populate these for existing installations\n        _ = fs::create_dir(node_dir.join(": "",
    ")).await;\n        _ = fs::write(node_dir.join(": "",
    "), []).await;\n        _ = fs::write(node_dir.join(": "",
    "), []).await;\n\n        anyhow::Ok(ManagedNodeRuntime {\n            installation_path: node_dir,\n        })\n    }\n}\n\nfn path_with_node_binary_prepended(node_binary: &Path) -> Option<OsString> {\n    let existing_path = env::var_os(": "",
    ");\n    let node_bin_dir = node_binary.parent().map(|dir| dir.as_os_str());\n    match (existing_path, node_bin_dir) {\n        (Some(existing_path), Some(node_bin_dir)) => {\n            if let Ok(joined) = env::join_paths(\n                [PathBuf::from(node_bin_dir)]\n                    .into_iter()\n                    .chain(env::split_paths(&existing_path)),\n            ) {\n                Some(joined)\n            } else {\n                Some(existing_path)\n            }\n        }\n        (Some(existing_path), None) => Some(existing_path),\n        (None, Some(node_bin_dir)) => Some(node_bin_dir.to_owned()),\n        _ => None,\n    }\n}\n\n#[async_trait::async_trait]\nimpl NodeRuntimeTrait for ManagedNodeRuntime {\n    fn boxed_clone(&self) -> Box<dyn NodeRuntimeTrait> {\n        Box::new(self.clone())\n    }\n\n    fn binary_path(&self) -> Result<PathBuf> {\n        Ok(self.installation_path.join(Self::NODE_PATH))\n    }\n\n    async fn run_npm_subcommand(\n        &self,\n        directory: Option<&Path>,\n        proxy: Option<&Url>,\n        subcommand: &str,\n        args: &[&str],\n    ) -> Result<Output> {\n        let attempt = || async move {\n            let node_binary = self.installation_path.join(Self::NODE_PATH);\n            let npm_file = self.installation_path.join(Self::NPM_PATH);\n            let env_path = path_with_node_binary_prepended(&node_binary).unwrap_or_default();\n\n            anyhow::ensure!(\n                smol::fs::metadata(&node_binary).await.is_ok(),\n                ": "",
    "\n            );\n            anyhow::ensure!(\n                smol::fs::metadata(&npm_file).await.is_ok(),\n                ": "",
    "\n            );\n\n            let node_ca_certs = env::var(NODE_CA_CERTS_ENV_VAR).unwrap_or_else(|_| String::new());\n\n            let mut command = util::command::new_smol_command(node_binary);\n            command.env_clear();\n            command.env(": "",
    ", env_path);\n            command.env(NODE_CA_CERTS_ENV_VAR, node_ca_certs);\n            command.arg(npm_file).arg(subcommand);\n            command.args([": "",
    ".into(), self.installation_path.join(": "",
    ")]);\n            command.args([\n                ": "",
    ".into(),\n                self.installation_path.join(": "",
    "),\n            ]);\n            command.args([\n                ": "",
    "),\n            ]);\n            command.args(args);\n            configure_npm_command(&mut command, directory, proxy);\n            command.output().await.map_err(|e| anyhow!(": "",
    "))\n        };\n\n        let mut output = attempt().await;\n        if output.is_err() {\n            output = attempt().await;\n            anyhow::ensure!(\n                output.is_ok(),\n                ": "",
    ",\n                output.err()\n            );\n        }\n\n        if let Ok(output) = &output {\n            anyhow::ensure!(\n                output.status.success(),\n                ": "",
    ",\n                String::from_utf8_lossy(&output.stdout),\n                String::from_utf8_lossy(&output.stderr)\n            );\n        }\n\n        output.map_err(|e| anyhow!(": "",
    "))\n    }\n    async fn npm_package_installed_version(\n        &self,\n        local_package_directory: &Path,\n        name: &str,\n    ) -> Result<Option<String>> {\n        read_package_installed_version(local_package_directory.join(": "",
    "), name).await\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct SystemNodeRuntime {\n    node: PathBuf,\n    npm: PathBuf,\n    global_node_modules: PathBuf,\n    scratch_dir: PathBuf,\n}\n\nimpl SystemNodeRuntime {\n    const MIN_VERSION: semver::Version = Version::new(20, 0, 0);\n    async fn new(node: PathBuf, npm: PathBuf) -> Result<Self> {\n        let output = util::command::new_smol_command(&node)\n            .arg(": "",
    ")\n            .output()\n            .await\n            .with_context(|| format!(": "",
    ", node))?;\n        if !output.status.success() {\n            anyhow::bail!(\n                ": "",
    ",\n                String::from_utf8_lossy(&output.stdout),\n                String::from_utf8_lossy(&output.stderr),\n            );\n        }\n        let version_str = String::from_utf8_lossy(&output.stdout);\n        let version = semver::Version::parse(version_str.trim().trim_start_matches('v'))?;\n        if version < Self::MIN_VERSION {\n            anyhow::bail!(\n                ": "",
    ",\n                node.to_string_lossy(),\n                Self::MIN_VERSION,\n                version\n            )\n        }\n\n        let scratch_dir = paths::data_dir().join(": "",
    ");\n        fs::create_dir(&scratch_dir).await.ok();\n        fs::create_dir(scratch_dir.join(": "",
    ")).await.ok();\n\n        let mut this = Self {\n            node,\n            npm,\n            global_node_modules: PathBuf::default(),\n            scratch_dir,\n        };\n        let output = this.run_npm_subcommand(None, None, ": "",
    ", &[": "",
    "]).await?;\n        this.global_node_modules =\n            PathBuf::from(String::from_utf8_lossy(&output.stdout).to_string());\n\n        Ok(this)\n    }\n\n    async fn detect() -> std::result::Result<Self, DetectError> {\n        let node = which::which(": "",
    ").map_err(DetectError::NotInPath)?;\n        let npm = which::which(": "",
    ").map_err(DetectError::NotInPath)?;\n        Self::new(node, npm).await.map_err(DetectError::Other)\n    }\n}\n\nenum DetectError {\n    NotInPath(which::Error),\n    Other(anyhow::Error),\n}\n\nimpl Display for DetectError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            DetectError::NotInPath(err) => {\n                write!(f, ": "",
    ", err)\n            }\n            DetectError::Other(err) => {\n                write!(f, ": "",
    ", err)\n            }\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl NodeRuntimeTrait for SystemNodeRuntime {\n    fn boxed_clone(&self) -> Box<dyn NodeRuntimeTrait> {\n        Box::new(self.clone())\n    }\n\n    fn binary_path(&self) -> Result<PathBuf> {\n        Ok(self.node.clone())\n    }\n\n    async fn run_npm_subcommand(\n        &self,\n        directory: Option<&Path>,\n        proxy: Option<&Url>,\n        subcommand: &str,\n        args: &[&str],\n    ) -> anyhow::Result<Output> {\n        let node_ca_certs = env::var(NODE_CA_CERTS_ENV_VAR).unwrap_or_else(|_| String::new());\n        let mut command = util::command::new_smol_command(self.npm.clone());\n        let path = path_with_node_binary_prepended(&self.node).unwrap_or_default();\n        command\n            .env_clear()\n            .env(": "",
    ", path)\n            .env(NODE_CA_CERTS_ENV_VAR, node_ca_certs)\n            .arg(subcommand)\n            .args([": "",
    ".into(), self.scratch_dir.join(": "",
    ")])\n            .args(args);\n        configure_npm_command(&mut command, directory, proxy);\n        let output = command.output().await?;\n        anyhow::ensure!(\n            output.status.success(),\n            ": "",
    ",\n            String::from_utf8_lossy(&output.stdout),\n            String::from_utf8_lossy(&output.stderr)\n        );\n        Ok(output)\n    }\n\n    async fn npm_package_installed_version(\n        &self,\n        local_package_directory: &Path,\n        name: &str,\n    ) -> Result<Option<String>> {\n        read_package_installed_version(local_package_directory.join(": "",
    "), name).await\n        // todo: allow returning a globally installed version (requires callers not to hard-code the path)\n    }\n}\n\npub async fn read_package_installed_version(\n    node_module_directory: PathBuf,\n    name: &str,\n) -> Result<Option<String>> {\n    let package_json_path = node_module_directory.join(name).join(": "",
    ");\n\n    let mut file = match fs::File::open(package_json_path).await {\n        Ok(file) => file,\n        Err(err) => {\n            if err.kind() == io::ErrorKind::NotFound {\n                return Ok(None);\n            }\n\n            Err(err)?\n        }\n    };\n\n    #[derive(Deserialize)]\n    struct PackageJson {\n        version: String,\n    }\n\n    let mut contents = String::new();\n    file.read_to_string(&mut contents).await?;\n    let package_json: PackageJson = serde_json::from_str(&contents)?;\n    Ok(Some(package_json.version))\n}\n\n#[derive(Clone)]\npub struct UnavailableNodeRuntime {\n    error_message: Arc<String>,\n}\n\n#[async_trait::async_trait]\nimpl NodeRuntimeTrait for UnavailableNodeRuntime {\n    fn boxed_clone(&self) -> Box<dyn NodeRuntimeTrait> {\n        Box::new(self.clone())\n    }\n    fn binary_path(&self) -> Result<PathBuf> {\n        bail!(": "",
    ", self.error_message)\n    }\n\n    async fn run_npm_subcommand(\n        &self,\n        _: Option<&Path>,\n        _: Option<&Url>,\n        _: &str,\n        _: &[&str],\n    ) -> anyhow::Result<Output> {\n        bail!(": "",
    ", self.error_message)\n    }\n\n    async fn npm_package_installed_version(\n        &self,\n        _local_package_directory: &Path,\n        _: &str,\n    ) -> Result<Option<String>> {\n        bail!(": "",
    ", self.error_message)\n    }\n}\n\nfn configure_npm_command(\n    command: &mut smol::process::Command,\n    directory: Option<&Path>,\n    proxy: Option<&Url>,\n) {\n    if let Some(directory) = directory {\n        command.current_dir(directory);\n        command.args([": "",
    ".into(), directory.to_path_buf()]);\n    }\n\n    if let Some(proxy) = proxy {\n        // Map proxy settings from `http://localhost:10809` to `http://127.0.0.1:10809`\n        // NodeRuntime without environment information can not parse `localhost`\n        // correctly.\n        // TODO: map to `[::1]` if we are using ipv6\n        let proxy = proxy\n            .to_string()\n            .to_ascii_lowercase()\n            .replace(": "",
    ", ": "",
    ");\n\n        command.args([": "",
    ", &proxy]);\n    }\n\n    #[cfg(windows)]\n    {\n        // SYSTEMROOT is a critical environment variables for Windows.\n        if let Some(val) = env::var(": "",
    ")\n            .context(": "",
    ")\n            .log_err()\n        {\n            command.env(": "",
    ", val);\n        }\n        // Without ComSpec, the post-install will always fail.\n        if let Some(val) = env::var(": ""
  },
  "zed/crates/notifications/src/notification_store.rs": {
    "Notification store was dropped while loading notifications": ""
  },
  "zed/crates/ollama/src/ollama.rs": {
    "http://localhost:11434": "",
    "schemars": "",
    "5m": "",
    "10m": "",
    "1h": "",
    "1d": "",
    "phi": "",
    "tinyllama": "",
    "granite-code": "",
    "llama2": "",
    "yi": "",
    "vicuna": "",
    "stablelm2": "",
    "llama3": "",
    "gemma2": "",
    "gemma": "",
    "codegemma": "",
    "starcoder": "",
    "aya": "",
    "codellama": "",
    "starcoder2": "",
    "mistral": "",
    "codestral": "",
    "mixstral": "",
    "llava": "",
    "qwen2": "",
    "qwen2.5-coder": "",
    "dolphin-mixtral": "",
    "llama3.1": "",
    "llama3.2": "",
    "llama3.3": "",
    "phi3": "",
    "phi3.5": "",
    "phi4": "",
    "command-r": "",
    "qwen3": "",
    "gemma3": "",
    "deepseek-coder-v2": "",
    "deepseek-v3": "",
    "deepseek-r1": "",
    "yi-coder": "",
    "devstral": "",
    ":latest": "",
    "role": "",
    "lowercase": "",
    "Option::is_none": "",
    "type": "",
    "tools": "",
    "vision": "",
    "thinking": "",
    "{api_url}/api/chat": "",
    "Content-Type": "",
    "application/json": "",
    "Failed to connect to API: {} {}": "",
    "Unable to parse chat response": "",
    "Failed to connect to Ollama API: {} {}": "",
    "{api_url}/api/tags": "",
    "Accept": "",
    "Unable to parse Ollama tag listing": "",
    "{api_url}/api/show": "",
    "model": "",
    "created_at": "",
    "2023-12-12T14:13:43.416799Z": "",
    "message": "",
    "assistant": "",
    "content": "",
    "Hello! How are you today?": "",
    "done": "",
    "total_duration": "",
    "load_duration": "",
    "prompt_eval_count": "",
    "prompt_eval_duration": "",
    "eval_count": "",
    "eval_duration": "",
    "2023-08-04T08:52:19.385406455-07:00": "",
    "The": "",
    "images": "",
    "2023-08-04T19:22:45.499127Z": "",
    "": "",
    "llama3.2:3b": "",
    "2025-04-28T20:02:02.140489Z": "",
    "tool_calls": "",
    "function": "",
    "name": "",
    "weather": "",
    "arguments": "",
    "city": "",
    "london": "",
    "done_reason": "",
    "stop": "",
    "Deserialized wrong role": "",
    "license": "",
    "LLAMA 3.2 COMMUNITY LICENSE AGREEMENT...": "",
    "details": "",
    "parent_model": "",
    "format": "",
    "gguf": "",
    "family": "",
    "llama": "",
    "families": "",
    "parameter_size": "",
    "3.2B": "",
    "quantization_level": "",
    "Q4_K_M": "",
    "model_info": "",
    "general.architecture": "",
    "general.basename": "",
    "Llama-3.2": "",
    "general.file_type": "",
    "general.finetune": "",
    "Instruct": "",
    "general.languages": "",
    "en": "",
    "de": "",
    "fr": "",
    "it": "",
    "pt": "",
    "hi": "",
    "es": "",
    "th": "",
    "general.parameter_count": "",
    "general.quantization_version": "",
    "general.size_label": "",
    "3B": "",
    "general.tags": "",
    "facebook": "",
    "meta": "",
    "pytorch": "",
    "llama-3": "",
    "text-generation": "",
    "general.type": "",
    "llama.attention.head_count": "",
    "llama.attention.head_count_kv": "",
    "llama.attention.key_length": "",
    "llama.attention.layer_norm_rms_epsilon": "",
    "llama.attention.value_length": "",
    "llama.block_count": "",
    "llama.context_length": "",
    "llama.embedding_length": "",
    "llama.feed_forward_length": "",
    "llama.rope.dimension_count": "",
    "llama.rope.freq_base": "",
    "llama.vocab_size": "",
    "tokenizer.ggml.bos_token_id": "",
    "tokenizer.ggml.eos_token_id": "",
    "tokenizer.ggml.merges": "",
    "tokenizer.ggml.model": "",
    "gpt2": "",
    "tokenizer.ggml.pre": "",
    "llama-bpe": "",
    "tokenizer.ggml.token_type": "",
    "tokenizer.ggml.tokens": "",
    "tensors": "",
    "rope_freqs.weight": "",
    "F32": "",
    "shape": "",
    "token_embd.weight": "",
    "Q4_K_S": "",
    "capabilities": "",
    "completion": "",
    "modified_at": "",
    "2025-04-29T21:24:41.445877632+03:00": "",
    "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==": "",
    "What do you see in this image?": "",
    "Hello, world!": "",
    "What do you see?": "",
    "messages": ""
  },
  "zed/crates/open_ai/src/open_ai.rs": {
    "https://api.openai.com/v1": "",
    "lowercase": "",
    "user": "",
    "assistant": "",
    "system": "",
    "tool": "",
    "invalid role '{value}'": "",
    "schemars": "",
    "gpt-3.5-turbo": "",
    "gpt-4": "",
    "gpt-4-turbo": "",
    "gpt-4o": "",
    "gpt-4o-mini": "",
    "gpt-4.1": "",
    "gpt-4.1-mini": "",
    "gpt-4.1-nano": "",
    "o1": "",
    "o3-mini": "",
    "o3": "",
    "o4-mini": "",
    "custom": "",
    "gpt-4-turbo-preview": "",
    "invalid model id '{invalid_id}'": "",
    "Option::is_none": "",
    "Vec::is_empty": "",
    "type": "",
    "snake_case": "",
    "role": "",
    "text": "",
    "image_url": "",
    "is_none_or_empty": "",
    "{api_url}/chat/completions": "",
    "Content-Type": "",
    "application/json": "",
    "Authorization": "",
    "Bearer {}": "",
    "data: ": "",
    "[DONE]": "",
    "Failed to connect to OpenAI API: {}": "",
    "Failed to connect to OpenAI API: {} {}": "",
    "text-embedding-3-small": "",
    "text-embedding-3-large": "",
    "{api_url}/embeddings": "",
    "error during embedding, status: {:?}, body: {:?}": "",
    "failed to parse OpenAI embedding response": ""
  },
  "zed/crates/outline/src/outline.rs": {
    "Search buffer symbols...": "",
    "/dir": "",
    "a.rs": "",
    "\n                                       // display line 0\n                    struct SingleLine; // display line 1\n                                       // display line 2\n                    struct MultiLine { // display line 3\n                        field_1: i32,  // display line 4\n                        field_2: i32,  // display line 5\n                    }                  // display line 6\n                ": "",
    "/dir/a.rs": "",
    "": "",
    "struct SingleLine": "",
    "struct MultiLine": "",
    "field_1": "",
    "field_2": "",
    "Initially opened outline view should have no highlights": "",
    "Second struct's rows should be highlighted": "",
    "First struct's row should be highlighted": "",
    "No rows should be highlighted after outline view is cancelled and closed": "",
    "Reopened outline view should have no highlights": "",
    "No rows should be highlighted after outline view is confirmed and closed": "",
    "Rust": "",
    "rs": "",
    "(struct_item\n            (visibility_modifier)? @context\n            ": "",
    " @context\n            name: (_) @name) @item\n\n        (enum_item\n            (visibility_modifier)? @context\n            ": "",
    " @context\n            name: (_) @name) @item\n\n        (enum_variant\n            (visibility_modifier)? @context\n            name: (_) @name) @item\n\n        (impl_item\n            ": "",
    " @context\n            trait: (_)? @name\n            ": "",
    "? @context\n            type: (_) @name) @item\n\n        (trait_item\n            (visibility_modifier)? @context\n            ": "",
    " @context\n            name: (_) @name) @item\n\n        (function_item\n            (visibility_modifier)? @context\n            (function_modifiers)? @context\n            ": "",
    " @context\n            name: (_) @name) @item\n\n        (function_signature_item\n            (visibility_modifier)? @context\n            (function_modifiers)? @context\n            ": "",
    " @context\n            name: (_) @name) @item\n\n        (macro_definition\n            . ": "",
    " @context\n            name: (_) @name) @item\n\n        (mod_item\n            (visibility_modifier)? @context\n            ": "",
    " @context\n            name: (_) @name) @item\n\n        (type_item\n            (visibility_modifier)? @context\n            ": "",
    " @context\n            name: (_) @name) @item\n\n        (associated_type\n            ": "",
    " @context\n            name: (_) @name) @item\n\n        (const_item\n            (visibility_modifier)? @context\n            ": "",
    " @context\n            name: (_) @name) @item\n\n        (field_declaration\n            (visibility_modifier)? @context\n            name: (_) @name) @item\n": "",
    "Expected one caret selection but got: {selections:?}": "",
    "Expected a single caret selection, but got: {selection:?}": ""
  },
  "zed/crates/outline_panel/src/outline_panel.rs": {
    "OutlinePanel": "",
    "Highlighted text that does not match the buffer text": "",
    "…": "",
    "loading outline panel": "",
    "Filter...": "",
    "have a &mut Workspace": "",
    "{}-{:?}": "",
    "menu": "",
    "editing": "",
    "not_editing": "",
    "macos": "",
    "Reveal in Finder": "",
    "Reveal in File Manager": "",
    "Open in Terminal": "",
    "Unfold Directory": "",
    "Fold Directory": "",
    "Copy Path": "",
    "Copy Relative Path": "",
    "Lines {}- {}": "",
    "{:?}|{:?}{:?}|{:?}": "",
    "Untitled": "",
    "Unknown buffer": "",
    "search-{match_range:?}": "",
    "Empty folded dirs receiver": "",
    "project-panel-vertical-scroll": "",
    "project-panel-horizontal-scroll": "",
    "No matches for query": "",
    "No outlines available": "",
    "Toggle this panel with {keystroke}": "",
    "entries": "",
    "outline-panel-menu": "",
    "Unpin Outline": "",
    "Pin Active Outline": "",
    "buffers_inside_directory called on a non-directory entry {dir_entry:?}": "",
    "Outline Panel": "",
    "outline-panel": "",
    "Searching:": "",
    "  <==== selected": "",
    "/rust-analyzer": "",
    "Project search view expected to appear after new search event trigger": "",
    "param_names_for_lifetime_elision_hints": "",
    "/rust-analyzer/\n  crates/\n    ide/src/\n      inlay_hints/\n        fn_lifetime_fn.rs\n          search: match config.param_names_for_lifetime_elision_hints {\n          search: allocated_lifetimes.push(if config.param_names_for_lifetime_elision_hints {\n          search: Some(it) if config.param_names_for_lifetime_elision_hints => {\n          search: InlayHintsConfig { param_names_for_lifetime_elision_hints: true, ..TEST_CONFIG },\n      inlay_hints.rs\n        search: pub param_names_for_lifetime_elision_hints: bool,\n        search: param_names_for_lifetime_elision_hints: self\n      static_index.rs\n        search: param_names_for_lifetime_elision_hints: false,\n    rust-analyzer/src/\n      cli/\n        analysis_stats.rs\n          search: param_names_for_lifetime_elision_hints: true,\n      config.rs\n        search: param_names_for_lifetime_elision_hints: self": "",
    "{line_to_select}{SELECTED_MARKER}": "",
    "search: match config.param_names_for_lifetime_elision_hints {": "",
    "fn_lifetime_fn.rs": "",
    "/rust-analyzer/\n  crates/\n    ide/src/\n      inlay_hints/\n        fn_lifetime_fn.rs{SELECTED_MARKER}\n      inlay_hints.rs\n        search: pub param_names_for_lifetime_elision_hints: bool,\n        search: param_names_for_lifetime_elision_hints: self\n      static_index.rs\n        search: param_names_for_lifetime_elision_hints: false,\n    rust-analyzer/src/\n      cli/\n        analysis_stats.rs\n          search: param_names_for_lifetime_elision_hints: true,\n      config.rs\n        search: param_names_for_lifetime_elision_hints: self": "",
    "inlay_hints/": "",
    "ide/src/": "",
    "/rust-analyzer/\n  crates/\n    ide/src/{SELECTED_MARKER}\n    rust-analyzer/src/\n      cli/\n        analysis_stats.rs\n          search: param_names_for_lifetime_elision_hints: true,\n      config.rs\n        search: param_names_for_lifetime_elision_hints: self": "",
    "a": "",
    "\\n": "",
    "": "",
    "{}/": "",
    "{root_path}\n  crates/\n    ide/src/\n      inlay_hints/\n        fn_lifetime_fn.rs\n          search: match config.param_names_for_lifetime_elision_hints {{\n          search: allocated_lifetimes.push(if config.param_names_for_lifetime_elision_hints {{\n          search: Some(it) if config.param_names_for_lifetime_elision_hints => {{\n          search: InlayHintsConfig {{ param_names_for_lifetime_elision_hints: true, ..TEST_CONFIG }},\n      inlay_hints.rs\n        search: pub param_names_for_lifetime_elision_hints: bool,\n        search: param_names_for_lifetime_elision_hints: self\n      static_index.rs\n        search: param_names_for_lifetime_elision_hints: false,\n    rust-analyzer/src/\n      cli/\n        analysis_stats.rs\n          search: param_names_for_lifetime_elision_hints: true,\n      config.rs\n        search: param_names_for_lifetime_elision_hints: self": "",
    "should have an active editor open": "",
    "search: ": "",
    "Should place the initial editor selection on the corresponding search result": "",
    "search: Some(it) if config.param_names_for_lifetime_elision_hints => {": "",
    "Should still have the initial caret position after SelectNext calls": "",
    "After opening, should move the caret to the opened outline entry's position": "",
    "search: InlayHintsConfig { param_names_for_lifetime_elision_hints: true, ..TEST_CONFIG },": "",
    "Should again preserve the selection after another SelectNext call": "",
    "After opening an excerpt, new editor should be open": "",
    "fn_lifetime_fn.rs  <==== selected": "",
    "When opening the excerpt, should navigate to the place corresponding the outline entry": "",
    "/root": "",
    "one": "",
    "a.txt": "",
    "aaa aaa": "",
    "two": "",
    "b.txt": "",
    "a aaa": "",
    "/root/one": "",
    "/root/two": "",
    "Were opening another worktree directory": "",
    "Directory should be opened successfully": "",
    "aaa": "",
    "/root/one/\n  a.txt\n    search: aaa aaa  <==== selected\n    search: aaa aaa\n/root/two/\n  b.txt\n    search: a aaa": "",
    "/root/one/\n  a.txt  <==== selected\n/root/two/\n  b.txt\n    search: a aaa": "",
    "/root/one/\n  a.txt\n/root/two/  <==== selected": "",
    "/root/one/\n  a.txt\n/root/two/  <==== selected\n  b.txt\n    search: a aaa": "",
    "src": "",
    "lib.rs": "",
    "\n#[derive(Clone, Debug, PartialEq, Eq, Hash)]\nstruct OutlineEntryExcerpt {\n    id: ExcerptId,\n    buffer_id: BufferId,\n    range: ExcerptRange<language::Anchor>,\n}": "",
    "\n                (struct_item\n                    (visibility_modifier)? @context\n                    ": "",
    " @context\n                    name: (_) @name) @item\n\n                (field_declaration\n                    (visibility_modifier)? @context\n                    name: (_) @name) @item\n": "",
    "/root/src/lib.rs": "",
    "Failed to open Rust source file": "",
    "Should open an editor for Rust source file": "",
    "\noutline: struct OutlineEntryExcerpt\n  outline: id\n  outline: buffer_id\n  outline: range": "",
    "\noutline: struct OutlineEntryExcerpt  <==== selected\n  outline: id\n  outline: buffer_id\n  outline: range": "",
    "\noutline: struct OutlineEntryExcerpt\n  outline: id  <==== selected\n  outline: buffer_id\n  outline: range": "",
    "\noutline: struct OutlineEntryExcerpt\n  outline: id\n  outline: buffer_id  <==== selected\n  outline: range": "",
    "\noutline: struct OutlineEntryExcerpt\n  outline: id\n  outline: buffer_id\n  outline: range  <==== selected": "",
    "/frontend-project": "",
    "public": "",
    "lottie": "",
    "syntax-tree.json": "",
    "{ ": "",
    ": ": "",
    " }": "",
    "app": "",
    "(site)": "",
    "(about)": "",
    "jobs": "",
    "[slug]": "",
    "page.tsx": "",
    "static": "",
    "(blog)": "",
    "post": "",
    "components": "",
    "ErrorBoundary.tsx": "",
    "/frontend-project/\n  public/lottie/\n    syntax-tree.json\n      search: { ": "",
    " }  <==== selected\n  src/\n    app/(site)/\n      (about)/jobs/[slug]/\n        page.tsx\n          search: static\n      (blog)/post/[slug]/\n        page.tsx\n          search: static\n    components/\n      ErrorBoundary.tsx\n        search: static": "",
    " }\n  src/\n    app/(site)/  <==== selected\n    components/\n      ErrorBoundary.tsx\n        search: static": "",
    " }\n  src/\n    app/(site)/\n    components/\n      ErrorBoundary.tsx\n        search: static  <==== selected": "",
    "Should have an active editor": "",
    " }\n  src/\n    app/(site)/\n    components/\n      ErrorBoundary.tsx  <==== selected": "",
    " }\n  src/\n    app/(site)/\n    components/\n      ErrorBoundary.tsx  <==== selected\n        search: static": "",
    "Failed to load outline panel": "",
    "no outline panel": "",
    "  ": "",
    "Did not cover external files with tests": "",
    "{}/{}": "",
    "/": "",
    "outline: {}": "",
    "search: {}": "",
    "crates": "",
    "ide": "",
    "inlay_hints": "",
    "\n        pub(super) fn hints(\n            acc: &mut Vec<InlayHint>,\n            config: &InlayHintsConfig,\n            func: ast::Fn,\n        ) -> Option<()> {\n            // ... snip\n\n            let mut used_names: FxHashMap<SmolStr, usize> =\n                match config.param_names_for_lifetime_elision_hints {\n                    true => generic_param_list\n                        .iter()\n                        .flat_map(|gpl| gpl.lifetime_params())\n                        .filter_map(|param| param.lifetime())\n                        .filter_map(|lt| Some((SmolStr::from(lt.text().as_str().get(1..)?), 0)))\n                        .collect(),\n                    false => Default::default(),\n                };\n            {\n                let mut potential_lt_refs = potential_lt_refs.iter().filter(|&&(.., is_elided)| is_elided);\n                if self_param.is_some() && potential_lt_refs.next().is_some() {\n                    allocated_lifetimes.push(if config.param_names_for_lifetime_elision_hints {\n                        // self can't be used as a lifetime, so no need to check for collisions\n                        ": "",
    ".into()\n                    } else {\n                        gen_idx_name()\n                    });\n                }\n                potential_lt_refs.for_each(|(name, ..)| {\n                    let name = match name {\n                        Some(it) if config.param_names_for_lifetime_elision_hints => {\n                            if let Some(c) = used_names.get_mut(it.text().as_str()) {\n                                *c += 1;\n                                SmolStr::from(format!(": "",
    ", text = it.text().as_str()))\n                            } else {\n                                used_names.insert(it.text().as_str().into(), 0);\n                                SmolStr::from_iter([": "",
    ", it.text().as_str()])\n                            }\n                        }\n                        _ => gen_idx_name(),\n                    };\n                    allocated_lifetimes.push(name);\n                });\n            }\n\n            // ... snip\n        }\n\n        // ... snip\n\n            #[test]\n            fn hints_lifetimes_named() {\n                check_with_config(\n                    InlayHintsConfig { param_names_for_lifetime_elision_hints: true, ..TEST_CONFIG },\n                    r#": "",
    "#,\n                );\n            }\n\n        // ... snip\n        ": "",
    "inlay_hints.rs": "",
    "\n    #[derive(Clone, Debug, PartialEq, Eq)]\n    pub struct InlayHintsConfig {\n        // ... snip\n        pub param_names_for_lifetime_elision_hints: bool,\n        pub max_length: Option<usize>,\n        // ... snip\n    }\n\n    impl Config {\n        pub fn inlay_hints(&self) -> InlayHintsConfig {\n            InlayHintsConfig {\n                // ... snip\n                param_names_for_lifetime_elision_hints: self\n                    .inlayHints_lifetimeElisionHints_useParameterNames()\n                    .to_owned(),\n                max_length: self.inlayHints_maxLength().to_owned(),\n                // ... snip\n            }\n        }\n    }\n    ": "",
    "static_index.rs": "",
    "\n// ... snip\n        fn add_file(&mut self, file_id: FileId) {\n            let current_crate = crates_for(self.db, file_id).pop().map(Into::into);\n            let folds = self.analysis.folding_ranges(file_id).unwrap();\n            let inlay_hints = self\n                .analysis\n                .inlay_hints(\n                    &InlayHintsConfig {\n                        // ... snip\n                        closure_style: hir::ClosureStyle::ImplFn,\n                        param_names_for_lifetime_elision_hints: false,\n                        binding_mode_hints: false,\n                        max_length: Some(25),\n                        closure_capture_hints: false,\n                        // ... snip\n                    },\n                    file_id,\n                    None,\n                )\n                .unwrap();\n            // ... snip\n    }\n// ... snip\n    ": "",
    "rust-analyzer": "",
    "cli": "",
    "analysis_stats.rs": "",
    "\n        // ... snip\n                for &file_id in &file_ids {\n                    _ = analysis.inlay_hints(\n                        &InlayHintsConfig {\n                            // ... snip\n                            implicit_drop_hints: true,\n                            lifetime_elision_hints: ide::LifetimeElisionHints::Always,\n                            param_names_for_lifetime_elision_hints: true,\n                            hide_named_constructor_hints: false,\n                            hide_closure_initialization_hints: false,\n                            closure_style: hir::ClosureStyle::ImplFn,\n                            max_length: Some(25),\n                            closing_brace_hints_min_lines: Some(20),\n                            fields_to_resolve: InlayFieldsToResolve::empty(),\n                            range_exclusive_hints: true,\n                        },\n                        file_id.into(),\n                        None,\n                    );\n                }\n        // ... snip\n                                    ": "",
    "config.rs": "",
    "\n                config_data! {\n                    /// Configs that only make sense when they are set by a client. As such they can only be defined\n                    /// by setting them using client's settings (e.g `settings.json` on VS Code).\n                    client: struct ClientDefaultConfigData <- ClientConfigInput -> {\n                        // ... snip\n                        /// Maximum length for inlay hints. Set to null to have an unlimited length.\n                        inlayHints_maxLength: Option<usize>                        = Some(25),\n                        // ... snip\n                        /// Whether to prefer using parameter names as the name for elided lifetime hints if possible.\n                        inlayHints_lifetimeElisionHints_useParameterNames: bool    = false,\n                        // ... snip\n                    }\n                }\n\n                impl Config {\n                    // ... snip\n                    pub fn inlay_hints(&self) -> InlayHintsConfig {\n                        InlayHintsConfig {\n                            // ... snip\n                            param_names_for_lifetime_elision_hints: self\n                                .inlayHints_lifetimeElisionHints_useParameterNames()\n                                .to_owned(),\n                            max_length: self.inlayHints_maxLength().to_owned(),\n                            // ... snip\n                        }\n                    }\n                    // ... snip\n                }\n                ": "",
    "Rust": "",
    "rs": "",
    "\n                (field_identifier) @field\n                (struct_expression) @struct\n            ": "",
    "\n                (macro_invocation\n                    (token_tree) @injection.content\n                    (#set! injection.language ": "",
    "))\n            ": "",
    "Active editor should have exactly one selection after any outline panel interactions": ""
  },
  "zed/crates/paths/src/paths.rs": {
    ".editorconfig": "",
    ".zed_server": "",
    "set_custom_data_dir called after data_dir or config_dir was initialized": "",
    "failed to create custom data directory": "",
    "config": "",
    "windows": "",
    "failed to determine RoamingAppData directory": "",
    "Zed": "",
    "linux": "",
    "freebsd": "",
    "FLATPAK_XDG_CONFIG_HOME": "",
    "failed to determine XDG_CONFIG_HOME directory": "",
    "zed": "",
    ".config": "",
    "macos": "",
    "Library/Application Support/Zed": "",
    "FLATPAK_XDG_DATA_HOME": "",
    "failed to determine XDG_DATA_HOME directory": "",
    "failed to determine LocalAppData directory": "",
    "failed to determine cachesDirectory directory": "",
    "FLATPAK_XDG_CACHE_HOME": "",
    "failed to determine XDG_CACHE_HOME directory": "",
    ".cache": "",
    "Library/Logs/Zed": "",
    "logs": "",
    "server_state": "",
    "Zed.log": "",
    "Zed.log.old": "",
    "db": "",
    "Library/Logs/DiagnosticReports": "",
    "Retired": "",
    "settings.json": "",
    "global_settings.json": "",
    "settings_backup.json": "",
    "keymap.json": "",
    "keymap_backup.json": "",
    "tasks.json": "",
    "debug.json": "",
    "extensions": "",
    "remote_extensions": "",
    "uploads": "",
    "themes": "",
    "snippets": "",
    "conversations": "",
    "prompts": "",
    "assets": "",
    "prompt_overrides": "",
    "embeddings": "",
    "languages": "",
    "debug_adapters": "",
    "copilot": "",
    "supermaven": "",
    "prettier": "",
    "remote_servers": "",
    ".zed": "",
    ".vscode": "",
    ".zed/settings.json": "",
    ".zed/tasks.json": "",
    ".vscode/tasks.json": "",
    ".zed/debug.json": "",
    ".vscode/launch.json": "",
    ".ssh/config": "",
    "/etc/ssh/ssh_config": "",
    "Code/User/settings.json": "",
    "Library/Application Support": "",
    "Cursor/User/settings.json": ""
  },
  "zed/crates/prettier/src/prettier.rs": {
    "test-support": "",
    "prettier_server.js": "",
    "./prettier_server.js": "",
    "prettier": "",
    "prettier-plugin-tailwindcss": "",
    "\\nformatted by test prettier": "",
    ".prettierrc": "",
    ".prettierrc.json": "",
    ".prettierrc.json5": "",
    ".prettierrc.yaml": "",
    ".prettierrc.yml": "",
    ".prettierrc.toml": "",
    ".prettierrc.js": "",
    ".prettierrc.cjs": "",
    "package.json": "",
    "prettier.config.js": "",
    "prettier.config.cjs": "",
    ".editorconfig": "",
    ".prettierignore": "",
    "node_modules": "",
    "Skipping prettier location for path {path_to_check:?} that is inside node_modules": "",
    "failed to get metadata for initial path {path_to_check:?}": "",
    "empty metadata for initial path {path_to_check:?}": "",
    "Found prettier path {path_to_check:?} in installed prettiers": "",
    "Found prettier path {path_to_check:?} in the node_modules": "",
    "workspaces": "",
    "traversing path parents, should be able to strip prefix": "",
    "Skipping non-string 'workspaces' value: {value:?}": "",
    "Path {path_to_check:?} is the workspace root for project in {closest_package_json_path:?}, but it has no prettier installed": "",
    "Found prettier path {path_to_check:?} in the workspace root for project in {closest_package_json_path:?}": "",
    "Skipping path {path_to_check:?} workspace root with workspaces {workspaces:?} that have no prettier installed": "",
    "Failed to parse workspaces for {path_to_check:?} from package.json, got {unknown:?}. Skipping.": "",
    "Skipping path {path_to_check:?} that has no prettier dependency and no workspaces section in its package.json": "",
    "Found no prettier in ancestors of {locate_from:?}": "",
    "Skipping prettier ignore location for path {path_to_check:?} that is inside node_modules": "",
    "Found prettier ignore at {path_to_check:?}": "",
    "fetching metadata for {ignore_path:?}": "",
    "Found prettier ignore at {ignore_path:?}": "",
    "Found prettier ignore at workspace root {workspace_ignore:?}": "",
    "Found no prettier ignore in ancestors of {locate_from:?}": "",
    "Prettier dir {prettier_dir:?} is not a directory": "",
    "no prettier server package found at {prettier_server:?}": "",
    "prettier server creation": "",
    "prettier server initialization": "",
    "Cannot format: prettier is not allowed for language {buffer_language:?}": "",
    "Prettier node_modules dir does not exist: {prettier_node_modules:?}": "",
    "dist": "",
    "index.mjs": "",
    "index.js": "",
    "plugin.js": "",
    "src": "",
    "lib": "",
    "standalone.js": "",
    "prettier-plugin-latex.js": "",
    "tabWidth": "",
    "printWidth": "",
    "useTabs": "",
    "Have not found plugin path for {plugin_name:?} inside {prettier_node_modules:?}": "",
    "Formatting unsaved file with prettier failed. No prettier parser configured for language {buffer_language:?}": "",
    "Cannot determine prettier parser for unsaved file": "",
    "Formatting file {:?} with prettier, plugins :{:?}, options: {:?}, ignore_path: {:?}": "",
    "prettier params calculation": "",
    "prettier format": "",
    "rust": "",
    "prettier does not support Rust": "",
    "Should not format buffer without a language with prettier": "",
    "prettier clear cache": "",
    "fetching metadata for {possible_node_modules_location:?}": "",
    "fetching metadata for package json {possible_package_json:?}": "",
    "reading {possible_package_json:?} file contents": "",
    "parsing {possible_package_json:?} file contents": "",
    "camelCase": "",
    "filepath": "",
    "prettier/format": "",
    "prettier/clear_cache": "",
    "/root": "",
    ".config": "",
    "zed": "",
    "settings.json": "",
    "{ ": "",
    ": ": "",
    " }": "",
    "work": "",
    "project": "",
    "// index.js file contents": "",
    "expect": "",
    "build": "",
    "print.js": "",
    "// print.js file contents": "",
    "{\n                                    ": "",
    ": {\n                                        ": "",
    "\n                                    }\n                                }": "",
    "// Dummy prettier package file": "",
    "{}": "",
    "/root/.config/zed/settings.json": "",
    "Should find no prettier for path hierarchy without it": "",
    "/root/work/project/src/index.js": "",
    "/root/work/project": "",
    "Should successfully find a prettier for path hierarchy that has node_modules with prettier, but no package.json mentions of it": "",
    "/root/work/project/node_modules/expect/build/print.js": "",
    "Should not format files inside node_modules/": "",
    "web_blog": "",
    "{\n                                ": "",
    ": {\n                                    ": "",
    "\n                                }\n                            }": "",
    "pages": "",
    "[slug].tsx": "",
    "// [slug].tsx file contents": "",
    "{\n                        ": "",
    ": {\n                            ": "",
    "\n                        },\n                        ": "",
    ": false,\n                            ": "",
    ": 80,\n                            ": "",
    ",\n                            ": "",
    ": 4\n                        }\n                    }": "",
    "/root/web_blog/pages/[slug].tsx": "",
    "/root/web_blog": "",
    "Should find a preinstalled prettier in the project root": "",
    "/root/web_blog/node_modules/expect/build/print.js": "",
    "Should not allow formatting node_modules/ contents": "",
    "{\n                            ": "",
    ": {\n                                ": "",
    "\n                            },\n                            ": "",
    ": false,\n                                ": "",
    ": 80,\n                                ": "",
    ",\n                                ": "",
    ": 4\n                            }\n                        }": "",
    "/root/work/web_blog/pages/[slug].tsx": "",
    "Should find no prettier when node_modules don't have it": "",
    "/root/work": "",
    "Should return closest cached value found without path checks": "",
    "/root/work/web_blog/node_modules/expect/build/print.js": "",
    "Should not allow formatting files inside node_modules/": "",
    "Should ignore cache lookup for files inside node_modules/": "",
    "full-stack-foundations": "",
    "exercises": "",
    "03.loading": "",
    "01.problem.loader": "",
    "app": "",
    "routes": "",
    "users+": "",
    "$username_+": "",
    "notes.tsx": "",
    "// notes.tsx file contents": "",
    "test.js": "",
    "// test.js contents": "",
    "{\n                                        ": "",
    ": {\n                                            ": "",
    "\n                                        }\n                                    }": "",
    ": [": "",
    ", ": "",
    "]\n                        }": "",
    "/root/work/full-stack-foundations/exercises/03.loading/01.problem.loader/app/routes/users+/$username_+/notes.tsx": "",
    "/root/work/full-stack-foundations": "",
    "Should ascend to the multi-workspace root and find the prettier there": "",
    "/root/work/full-stack-foundations/node_modules/prettier/index.js": "",
    "Should not allow formatting files inside root node_modules/": "",
    "/root/work/full-stack-foundations/exercises/03.loading/01.problem.loader/node_modules/test.js": "",
    "Should not allow formatting files inside submodule's node_modules/": "",
    "Expected to fail for prettier in package.json but not in node_modules found, but got path {path:?}": "",
    "\\\\\\\\": "",
    "/": "",
    "/root/work/full-stack-foundations/exercises/03.loading/01.problem.loader": "",
    "Error message should mention which project had prettier defined": "",
    "Error message should mention potential candidates without prettier node_modules contents": "",
    "ignored.js": "",
    "// this file should be ignored": "",
    "\n                    }": "",
    "/root/project/src/index.js": "",
    "/root/project": "",
    "Should find prettierignore in project root": "",
    "monorepo": "",
    "packages": "",
    "web": "",
    "// index.js contents": "",
    "// this should be ignored": "",
    "\n                            }": "",
    "],\n                        ": "",
    "\n                        }\n                    }": "",
    "/root/monorepo/packages/web/src/index.js": "",
    "/root/monorepo/packages/web": "",
    "Should find prettierignore in child package": "",
    "main.js": "",
    "// this should not be ignored": "",
    "/root/monorepo/packages/web/src/main.js": "",
    "Should find child package prettierignore first": "",
    "/root/monorepo/packages/web/src/ignored.js": ""
  },
  "zed/crates/project/src/buffer_store.rs": {
    "missing variant": "",
    "no worktree found for id {}": "",
    "received chunk for buffer {} without initial state": "",
    "missing transaction": "",
    "buffer doesn't have a file": "",
    "no such worktree": "",
    "": "",
    "{e}": "",
    "buffer {remote_id} was already registered": "",
    "unknown buffer id {buffer_id}": "",
    "tried to register shared lsp handle, but buffer was not shared": "",
    "missing original_sender_id on SynchronizeBuffers request": "",
    "buffer store is not a remote": "",
    "invalid file": "",
    "project is not shared": "",
    "peer_id {} closed buffer_id {} which was either not open or already closed": "",
    "missing line ending": "",
    "local-only method called in a non-local context": "",
    "not a remote buffer store": ""
  },
  "zed/crates/project/src/color_extractor.rs": {
    "(#(?:[\\da-fA-F]{3}){1,2})": "",
    "(rgba?|hsla?)\\(\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*(?:,\\s*(1|0?\\.\\d+))?\\s*\\)": "",
    "Failed to create RELAXED_HEX_REGEX": "",
    "^{HEX}$": "",
    "Failed to create STRICT_HEX_REGEX": "",
    "Failed to create RELAXED_RGB_OR_HSL_REGEX": "",
    "^{RGB_OR_HSL}$": "",
    "Failed to create STRICT_RGB_OR_HSL_REGEX": "",
    "rgb": "",
    "rgba": "",
    "hsl": "",
    "hsla": "",
    "%": "",
    "f0f": "",
    "#fof": "",
    "rgb(255, 0, 0, 0.0)": "",
    "hsl(120, 0, 0, 0.0)": "",
    "rgba(255, 0, 0)": "",
    "hsla(120, 0, 0)": "",
    "rgba(255, 0, 0, 0)": "",
    "hsla(120, 0, 0, 0)": "",
    "rgba(255, 0, 0, 1.0)": "",
    "hsla(120, 0, 0, 1.0)": "",
    "#f0f": "",
    "#ff0000": "",
    "rgb(255, 0, 0)": "",
    "rgba(255, 0, 0, 0.4)": "",
    "rgba(255, 0, 0, 1)": "",
    "rgb(20%, 0%, 0%)": "",
    "rgba(20%, 0%, 0%, 1)": "",
    "rgb(0%, 20%, 0%)": "",
    "rgba(0%, 20%, 0%, 1)": "",
    "rgb(0%, 0%, 20%)": "",
    "rgba(0%, 0%, 20%, 1)": "",
    "hsl(0, 100%, 50%)": "",
    "hsl(120, 100%, 50%)": "",
    "hsla(0, 100%, 50%, 0.0)": "",
    "hsla(0, 100%, 50%, 0.4)": "",
    "hsla(0, 100%, 50%, 1)": "",
    "hsla(120, 100%, 50%, 0.0)": "",
    "hsla(120, 100%, 50%, 0.4)": "",
    "hsla(120, 100%, 50%, 1)": "",
    "{} foo": "",
    "": "",
    "foo {}": "",
    "foo {} foo": ""
  },
  "zed/crates/project/src/direnv.rs": {
    "windows": "",
    "test-support": "",
    "Failed to run direnv. See logs for more info": "",
    "Direnv returned invalid json. See logs for more info": "",
    "direnv": "",
    "export": "",
    "json": "",
    "TERM": "",
    "dumb": "",
    "Loading direnv environment failed ({}), stderr: {}": "",
    "json parse error {}, while parsing output of `{} {}`:\\n{}": "",
    " ": ""
  },
  "zed/crates/project/src/environment.rs": {
    "test-support": "",
    "using project environment variables from CLI": "",
    "attempted to get project environment for a non-local worktree at {abs_path:?}": "",
    "ZED_ENVIRONMENT": "",
    "cli": "",
    "worktree-shell": "",
    "{}": "",
    "Failed to load shell environment in {}: not a directory": "",
    "Failed to load shell environment in {}: {}": "",
    "ZED_FAKE_TEST_ENV": "",
    "true": "",
    "windows": "",
    "Failed to load environment variables. See log for details": "",
    "PATH": "",
    "using project environment variables shell launched in {:?}. PATH={:?}": "",
    "{error}": ""
  },
  "zed/crates/project/src/image_store.rs": {
    "{}": "",
    "absolutizing image file path": "",
    "failed to load image metadata": "",
    "Failed to load image content": "",
    "svg": "",
    "no such worktree": "",
    "Image format {format:?} not supported": "",
    "Opening images from remote is not supported": "",
    "Reloading images from remote is not supported": "",
    "/root": "",
    "/root/image_1.png": "",
    "image_1.png": ""
  },
  "zed/crates/project/src/lsp_command.rs": {
    "Invalid file path provided to LSP request: {path:?}": "",
    "Prepare rename": "",
    "Rename not supported": "",
    "invalid position": "",
    "Missing start or end position in remote project PrepareRenameResponse": "",
    "Rename": "",
    "missing transaction": "",
    "Get definition": "",
    "Get declaration": "",
    "Get implementation": "",
    "Get type definition": "",
    "no language server found for buffer": "",
    "missing origin start": "",
    "missing origin end": "",
    "missing target": "",
    "missing target start": "",
    "missing target end": "",
    "Find all references": "",
    "Finding references...": "",
    "Get document highlights": "",
    "Get document symbols": "",
    "invalid start": "",
    "invalid end": "",
    "invalid selection start": "",
    "invalid selection end": "",
    "Get signature help": "",
    "waiting for version for buffer {}": "",
    "Get hover": "",
    "Get completion": "",
    "no language server with id {server_id}": "",
    "completion out of expected range": "",
    "completion (insert) out of expected range": "",
    "Get code actions": "",
    "Missing the language server that just returned a response {server_id}": "",
    "Formatting on typing": "",
    "lsp to project inlay hint conversion": "",
    "failed to serialize resolve json data": "",
    "incorrect proto inlay hint message: no resolve state in hint {message_hint:?}": "",
    "incorrect proto inlay hint message: non-json resolve state {lsp_resolve_state:?}": "",
    "No lsp resolve data for the hint that can be resolved: {message_hint:?}": "",
    "Unexpected resolve state {invalid} for hint {message_hint:?}": "",
    "missing label": "",
    "invalid uri in hint part {part:?}": "",
    "Inlay hints": "",
    "typescript-language-server": "",
    "lsp to project inlay hints conversion": "",
    "Code Lens": "",
    "deserializing proto code lens response": "",
    "Linked editing range": "",
    "deserializing diagnostics": "",
    "invalid start range": "",
    "invalid end range": "",
    "Get diagnostics": "",
    "missing url on buffer {}": "",
    "proto::GetDocumentDiagnostics is not expected to be converted from proto directly, as it needs `previous_result_id` fetched first": "",
    "serializing diagnostics": "",
    "Unexpected state: file {uri} has two different sets of diagnostics reported": "",
    "E001": "",
    "test-source": "",
    "Test error message": "",
    "detail": "",
    "test detail": "",
    "Failed to serialize diagnostic": "",
    "ERR": "",
    "Prism": "",
    "assigned but unused variable - a": "",
    "Failed to deserialize diagnostic": "",
    "file:///test.rs": "",
    "Related info message": "",
    "Test message": ""
  },
  "zed/crates/project/src/lsp_store.rs": {
    "test-support": "",
    "attempting to start language server {:?}, path: {root_path:?}, id: {server_id}": "",
    "{err}\\n-- stderr--\\n{log}": "",
    "Failed to start language server {server_name:?}: {err:#?}": "",
    "server stderr: {log}": "",
    "": "",
    "workspace/didChangeWatchedFiles": "",
    "textDocument/rangeFormatting": "",
    "textDocument/onTypeFormatting": "",
    "textDocument/formatting": "",
    "workspace/didChangeConfiguration": "",
    "textDocument/rename": "",
    "unhandled capability registration: {reg:?}": "",
    "unhandled capability unregistration: {unreg:?}": "",
    "formatting buffer '{:?}'": "",
    "unknown": "",
    "transaction already open": "",
    "transaction started": "",
    "no formatting transaction": "",
    "no changes made while formatting": "",
    "forgetting format transaction": "",
    "Buffer edited while formatting. Aborting": "",
    "removing trailing whitespace": "",
    "ensuring final newline": "",
    "going to run code actions on format": "",
    "Formatter set to auto: defaulting to prettier": "",
    "Formatter set to auto: defaulting to primary language server": "",
    "prettier": "",
    "formatting": "",
    "Formatting buffer via prettier": "",
    "No changes": "",
    "command": "",
    "Formatting buffer via external command": "",
    "Failed to format buffer via external command: {}": "",
    "language-server": "",
    "Formatting buffer using language server": "",
    "Cannot format buffer that is not backed by a file on disk using language servers. Skipping": "",
    "No language server found to format buffer '{:?}'. Skipping": "",
    "Formatting buffer '{:?}' using language server '{:?}'": "",
    "formatting ranges": "",
    "Failed to format ranges via language server": "",
    "formatting full": "",
    "failed to format via language server": "",
    "code-actions": "",
    "Formatting buffer using code actions": "",
    "Cannot format buffer that is not backed by a file on disk using code actions. Skipping": "",
    "No code action kinds enabled, skipping": "",
    "Attempting to resolve code actions {:?}": "",
    "Failed to resolve code actions with kinds {:?} for language server {}": "",
    ", ": "",
    "Failed to resolve code actions with kinds {:?} with language server {}": "",
    "No code actions were resolved, continuing": "",
    "code action '{}' with title \\\"{}\\\" on server {}": "",
    "Executing {}": "",
    "Failed to resolve {}. Error: {}": "",
    "No changes for code action. Skipping {}": "",
    "Code actions which create, delete, or rename files are not supported on format. Skipping {}": "",
    "Failed to convert URI '{:?}' to file path. Skipping {}": "",
    "File path '{:?}' does not match buffer path '{:?}'. Skipping {}": "",
    "Code actions which produce snippet edits are not supported during formatting. Skipping {}": "",
    "Failed to resolve edits from LSP for buffer {:?} while handling {}": "",
    "No edits resolved from LSP": "",
    "Executing code action command '{}'. This may cause formatting to abort unnecessarily as well as splitting formatting into two entries in the undo history": "",
    "Cannot execute a command {} not listed in the language server capabilities of server {}": "",
    "Executing command {}": "",
    "Failed to execute command '{}' as part of {}": "",
    "Successfully captured {} edits that resulted from command {}": "",
    "Unexpected edits to buffers other than the buffer actively being formatted due to command {}. Impacted buffers: [{}].": "",
    "{} language server does not support range formatting": "",
    "lsp_format": "",
    "Formatting via LSP": "",
    "format-full": "",
    "format-range": "",
    "{buffer_path}": "",
    "Untitled": "",
    "failed to acquire stdin": "",
    "command failed with exit code {:?}:\\nstdout: {}\\nstderr: {}": "",
    "To find LSP adapter": "",
    "Language server ID should be available, as it's registered on demand": "",
    "`{}` is not parseable as an URI": "",
    "no snapshots found for buffer {buffer_id} and server {server_id}": "",
    "snapshot not found for buffer {buffer_id} server {server_id} at version {version}": "",
    "resolving a formatting code action": "",
    "project dropped": "",
    "execute command": "",
    "Cannot execute a command {} not listed in the language server capabilities": "",
    "can't convert URI to path": "",
    "/": "",
    "project project closed": "",
    "language server not found": "",
    "Processing new watcher paths for language server with id {}": "",
    "Failed to strip prefix for string pattern: {}, with prefix: {}, with error: {}": "",
    "Failed to strip prefix for relative pattern: {}, with prefix: {}, with error: {}": "",
    "language server {}: unregistered workspace/DidChangeWatchedFiles capability with id {}": "",
    "language server {}: failed to unregister workspace/DidChangeWatchedFiles capability with id {}. not registered.": "",
    "No extension events global found. Skipping JSON schema auto-reload setup": "",
    "generate new workspace configuration for JSON language server while trying to refresh JSON Schemas": "",
    "language-less": "",
    "bad refcounting": "",
    "oops!": "",
    "{} via {} failed: {}": "",
    "{message}": "",
    "no app context": "",
    "missing transaction": "",
    "resolving a code action": "",
    "no app present": "",
    "no upstream client and not local": "",
    "inlay hints proto request": "",
    "inlay hints proto resolve response conversion": "",
    "inlay hint resolve LSP request": "",
    "No upstream client or local language server": "",
    "Unexpected response: {unexpected:?}": "",
    "Fetching completions from server {server_id} timed out, timeout ms: {}": "",
    "server_id mismatch, querying completion resolve for {server_id} but completion server id is {completion_server_id}": "",
    "resolve completion": "",
    "server_id mismatch, applying completion resolve for {server_id} but completion server id is {completion_server_id}": "",
    ",\n                completion.label.text(),\n                new_label.text(),\n                completion.label.filter_text(),\n                new_label.filter_text()\n            );\n        }\n\n        Ok(())\n    }\n\n    async fn resolve_completion_remote(\n        project_id: u64,\n        server_id: LanguageServerId,\n        buffer_id: BufferId,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        client: AnyProtoClient,\n    ) -> Result<()> {\n        let lsp_completion = {\n            let completion = &completions.borrow()[completion_index];\n            match &completion.source {\n                CompletionSource::Lsp {\n                    lsp_completion,\n                    resolved,\n                    server_id: completion_server_id,\n                    ..\n                } => {\n                    anyhow::ensure!(\n                        server_id == *completion_server_id,\n                        ": "",
    "\n                    );\n                    if *resolved {\n                        return Ok(());\n                    }\n                    serde_json::to_string(lsp_completion).unwrap().into_bytes()\n                }\n                CompletionSource::Custom | CompletionSource::BufferWord { .. } => {\n                    return Ok(());\n                }\n            }\n        };\n        let request = proto::ResolveCompletionDocumentation {\n            project_id,\n            language_server_id: server_id.0 as u64,\n            lsp_completion,\n            buffer_id: buffer_id.into(),\n        };\n\n        let response = client\n            .request(request)\n            .await\n            .context(": "",
    ")?;\n        let resolved_lsp_completion = serde_json::from_slice(&response.lsp_completion)?;\n\n        let documentation = if response.documentation.is_empty() {\n            CompletionDocumentation::Undocumented\n        } else if response.documentation_is_markdown {\n            CompletionDocumentation::MultiLineMarkdown(response.documentation.into())\n        } else if response.documentation.lines().count() <= 1 {\n            CompletionDocumentation::SingleLine(response.documentation.into())\n        } else {\n            CompletionDocumentation::MultiLinePlainText(response.documentation.into())\n        };\n\n        let mut completions = completions.borrow_mut();\n        let completion = &mut completions[completion_index];\n        completion.documentation = Some(documentation);\n        if let CompletionSource::Lsp {\n            insert_range,\n            lsp_completion,\n            resolved,\n            server_id: completion_server_id,\n            lsp_defaults: _,\n        } = &mut completion.source\n        {\n            let completion_insert_range = response\n                .old_insert_start\n                .and_then(deserialize_anchor)\n                .zip(response.old_insert_end.and_then(deserialize_anchor));\n            *insert_range = completion_insert_range.map(|(start, end)| start..end);\n\n            if *resolved {\n                return Ok(());\n            }\n            anyhow::ensure!(\n                server_id == *completion_server_id,\n                ": "",
    "\n            );\n            *lsp_completion = Box::new(resolved_lsp_completion);\n            *resolved = true;\n        }\n\n        let replace_range = response\n            .old_replace_start\n            .and_then(deserialize_anchor)\n            .zip(response.old_replace_end.and_then(deserialize_anchor));\n        if let Some((old_replace_start, old_replace_end)) = replace_range {\n            if !response.new_text.is_empty() {\n                completion.new_text = response.new_text;\n                completion.replace_range = old_replace_start..old_replace_end;\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn apply_additional_edits_for_completion(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        push_to_history: bool,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Option<Transaction>>> {\n        if let Some((client, project_id)) = self.upstream_client() {\n            let buffer = buffer_handle.read(cx);\n            let buffer_id = buffer.remote_id();\n            cx.spawn(async move |_, cx| {\n                let request = {\n                    let completion = completions.borrow()[completion_index].clone();\n                    proto::ApplyCompletionAdditionalEdits {\n                        project_id,\n                        buffer_id: buffer_id.into(),\n                        completion: Some(Self::serialize_completion(&CoreCompletion {\n                            replace_range: completion.replace_range,\n                            new_text: completion.new_text,\n                            source: completion.source,\n                        })),\n                    }\n                };\n\n                if let Some(transaction) = client.request(request).await?.transaction {\n                    let transaction = language::proto::deserialize_transaction(transaction)?;\n                    buffer_handle\n                        .update(cx, |buffer, _| {\n                            buffer.wait_for_edits(transaction.edit_ids.iter().copied())\n                        })?\n                        .await?;\n                    if push_to_history {\n                        buffer_handle.update(cx, |buffer, _| {\n                            buffer.push_transaction(transaction.clone(), Instant::now());\n                            buffer.finalize_last_transaction();\n                        })?;\n                    }\n                    Ok(Some(transaction))\n                } else {\n                    Ok(None)\n                }\n            })\n        } else {\n            let Some(server) = buffer_handle.update(cx, |buffer, cx| {\n                let completion = &completions.borrow()[completion_index];\n                let server_id = completion.source.server_id()?;\n                Some(\n                    self.language_server_for_local_buffer(buffer, server_id, cx)?\n                        .1\n                        .clone(),\n                )\n            }) else {\n                return Task::ready(Ok(None));\n            };\n            let snapshot = buffer_handle.read(&cx).snapshot();\n\n            cx.spawn(async move |this, cx| {\n                Self::resolve_completion_local(\n                    server.clone(),\n                    &snapshot,\n                    completions.clone(),\n                    completion_index,\n                )\n                .await\n                .context(": "",
    ")?;\n                let completion = completions.borrow()[completion_index].clone();\n                let additional_text_edits = completion\n                    .source\n                    .lsp_completion(true)\n                    .as_ref()\n                    .and_then(|lsp_completion| lsp_completion.additional_text_edits.clone());\n                if let Some(edits) = additional_text_edits {\n                    let edits = this\n                        .update(cx, |this, cx| {\n                            this.as_local_mut().unwrap().edits_from_lsp(\n                                &buffer_handle,\n                                edits,\n                                server.server_id(),\n                                None,\n                                cx,\n                            )\n                        })?\n                        .await?;\n\n                    buffer_handle.update(cx, |buffer, cx| {\n                        buffer.finalize_last_transaction();\n                        buffer.start_transaction();\n\n                        for (range, text) in edits {\n                            let primary = &completion.replace_range;\n                            let start_within = primary.start.cmp(&range.start, buffer).is_le()\n                                && primary.end.cmp(&range.start, buffer).is_ge();\n                            let end_within = range.start.cmp(&primary.end, buffer).is_le()\n                                && range.end.cmp(&primary.end, buffer).is_ge();\n\n                            //Skip additional edits which overlap with the primary completion edit\n                            //https://github.com/zed-industries/zed/pull/1871\n                            if !start_within && !end_within {\n                                buffer.edit([(range, text)], None, cx);\n                            }\n                        }\n\n                        let transaction = if buffer.end_transaction(cx).is_some() {\n                            let transaction = buffer.finalize_last_transaction().unwrap().clone();\n                            if !push_to_history {\n                                buffer.forget_transaction(transaction.id);\n                            }\n                            Some(transaction)\n                        } else {\n                            None\n                        };\n                        Ok(transaction)\n                    })?\n                } else {\n                    Ok(None)\n                }\n            })\n        }\n    }\n\n    pub fn pull_diagnostics(\n        &mut self,\n        buffer_handle: Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<LspPullDiagnostics>>> {\n        let buffer = buffer_handle.read(cx);\n        let buffer_id = buffer.remote_id();\n\n        if let Some((client, upstream_project_id)) = self.upstream_client() {\n            let request_task = client.request(proto::MultiLspQuery {\n                buffer_id: buffer_id.to_proto(),\n                version: serialize_version(&buffer_handle.read(cx).version()),\n                project_id: upstream_project_id,\n                strategy: Some(proto::multi_lsp_query::Strategy::All(\n                    proto::AllLanguageServers {},\n                )),\n                request: Some(proto::multi_lsp_query::Request::GetDocumentDiagnostics(\n                    proto::GetDocumentDiagnostics {\n                        project_id: upstream_project_id,\n                        buffer_id: buffer_id.to_proto(),\n                        version: serialize_version(&buffer_handle.read(cx).version()),\n                    },\n                )),\n            });\n            cx.background_spawn(async move {\n                Ok(request_task\n                    .await?\n                    .responses\n                    .into_iter()\n                    .filter_map(|lsp_response| match lsp_response.response? {\n                        proto::lsp_response::Response::GetDocumentDiagnosticsResponse(response) => {\n                            Some(response)\n                        }\n                        unexpected => {\n                            debug_panic!(": "",
    ");\n                            None\n                        }\n                    })\n                    .flat_map(GetDocumentDiagnostics::diagnostics_from_proto)\n                    .collect())\n            })\n        } else {\n            let server_ids = buffer_handle.update(cx, |buffer, cx| {\n                self.language_servers_for_local_buffer(buffer, cx)\n                    .map(|(_, server)| server.server_id())\n                    .collect::<Vec<_>>()\n            });\n            let pull_diagnostics = server_ids\n                .into_iter()\n                .map(|server_id| {\n                    let result_id = self.result_id(server_id, buffer_id, cx);\n                    self.request_lsp(\n                        buffer_handle.clone(),\n                        LanguageServerToQuery::Other(server_id),\n                        GetDocumentDiagnostics {\n                            previous_result_id: result_id,\n                        },\n                        cx,\n                    )\n                })\n                .collect::<Vec<_>>();\n\n            cx.background_spawn(async move {\n                let mut responses = Vec::new();\n                for diagnostics in join_all(pull_diagnostics).await {\n                    responses.extend(diagnostics?);\n                }\n                Ok(responses)\n            })\n        }\n    }\n\n    pub fn inlay_hints(\n        &mut self,\n        buffer_handle: Entity<Buffer>,\n        range: Range<Anchor>,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<Vec<InlayHint>>> {\n        let buffer = buffer_handle.read(cx);\n        let range_start = range.start;\n        let range_end = range.end;\n        let buffer_id = buffer.remote_id().into();\n        let lsp_request = InlayHints { range };\n\n        if let Some((client, project_id)) = self.upstream_client() {\n            let request = proto::InlayHints {\n                project_id,\n                buffer_id,\n                start: Some(serialize_anchor(&range_start)),\n                end: Some(serialize_anchor(&range_end)),\n                version: serialize_version(&buffer_handle.read(cx).version()),\n            };\n            cx.spawn(async move |project, cx| {\n                let response = client\n                    .request(request)\n                    .await\n                    .context(": "",
    ")?;\n                LspCommand::response_from_proto(\n                    lsp_request,\n                    response,\n                    project.upgrade().context(": "",
    ")?,\n                    buffer_handle.clone(),\n                    cx.clone(),\n                )\n                .await\n                .context(": "",
    ")\n            })\n        } else {\n            let lsp_request_task = self.request_lsp(\n                buffer_handle.clone(),\n                LanguageServerToQuery::FirstCapable,\n                lsp_request,\n                cx,\n            );\n            cx.spawn(async move |_, cx| {\n                buffer_handle\n                    .update(cx, |buffer, _| {\n                        buffer.wait_for_edits(vec![range_start.timestamp, range_end.timestamp])\n                    })?\n                    .await\n                    .context(": "",
    ")?;\n                lsp_request_task.await.context(": "",
    ")\n            })\n        }\n    }\n\n    pub fn signature_help<T: ToPointUtf16>(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: T,\n        cx: &mut Context<Self>,\n    ) -> Task<Vec<SignatureHelp>> {\n        let position = position.to_point_utf16(buffer.read(cx));\n\n        if let Some((client, upstream_project_id)) = self.upstream_client() {\n            let request_task = client.request(proto::MultiLspQuery {\n                buffer_id: buffer.read(cx).remote_id().into(),\n                version: serialize_version(&buffer.read(cx).version()),\n                project_id: upstream_project_id,\n                strategy: Some(proto::multi_lsp_query::Strategy::All(\n                    proto::AllLanguageServers {},\n                )),\n                request: Some(proto::multi_lsp_query::Request::GetSignatureHelp(\n                    GetSignatureHelp { position }.to_proto(upstream_project_id, buffer.read(cx)),\n                )),\n            });\n            let buffer = buffer.clone();\n            cx.spawn(async move |weak_project, cx| {\n                let Some(project) = weak_project.upgrade() else {\n                    return Vec::new();\n                };\n                join_all(\n                    request_task\n                        .await\n                        .log_err()\n                        .map(|response| response.responses)\n                        .unwrap_or_default()\n                        .into_iter()\n                        .filter_map(|lsp_response| match lsp_response.response? {\n                            proto::lsp_response::Response::GetSignatureHelpResponse(response) => {\n                                Some(response)\n                            }\n                            unexpected => {\n                                debug_panic!(": "",
    ");\n                                None\n                            }\n                        })\n                        .map(|signature_response| {\n                            let response = GetSignatureHelp { position }.response_from_proto(\n                                signature_response,\n                                project.clone(),\n                                buffer.clone(),\n                                cx.clone(),\n                            );\n                            async move { response.await.log_err().flatten() }\n                        }),\n                )\n                .await\n                .into_iter()\n                .flatten()\n                .collect()\n            })\n        } else {\n            let all_actions_task = self.request_multiple_lsp_locally(\n                buffer,\n                Some(position),\n                GetSignatureHelp { position },\n                cx,\n            );\n            cx.spawn(async move |_, _| {\n                all_actions_task\n                    .await\n                    .into_iter()\n                    .flatten()\n                    .filter(|help| !help.label.is_empty())\n                    .collect::<Vec<_>>()\n            })\n        }\n    }\n\n    pub fn hover(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: PointUtf16,\n        cx: &mut Context<Self>,\n    ) -> Task<Vec<Hover>> {\n        if let Some((client, upstream_project_id)) = self.upstream_client() {\n            let request_task = client.request(proto::MultiLspQuery {\n                buffer_id: buffer.read(cx).remote_id().into(),\n                version: serialize_version(&buffer.read(cx).version()),\n                project_id: upstream_project_id,\n                strategy: Some(proto::multi_lsp_query::Strategy::All(\n                    proto::AllLanguageServers {},\n                )),\n                request: Some(proto::multi_lsp_query::Request::GetHover(\n                    GetHover { position }.to_proto(upstream_project_id, buffer.read(cx)),\n                )),\n            });\n            let buffer = buffer.clone();\n            cx.spawn(async move |weak_project, cx| {\n                let Some(project) = weak_project.upgrade() else {\n                    return Vec::new();\n                };\n                join_all(\n                    request_task\n                        .await\n                        .log_err()\n                        .map(|response| response.responses)\n                        .unwrap_or_default()\n                        .into_iter()\n                        .filter_map(|lsp_response| match lsp_response.response? {\n                            proto::lsp_response::Response::GetHoverResponse(response) => {\n                                Some(response)\n                            }\n                            unexpected => {\n                                debug_panic!(": "",
    ");\n                                None\n                            }\n                        })\n                        .map(|hover_response| {\n                            let response = GetHover { position }.response_from_proto(\n                                hover_response,\n                                project.clone(),\n                                buffer.clone(),\n                                cx.clone(),\n                            );\n                            async move {\n                                response\n                                    .await\n                                    .log_err()\n                                    .flatten()\n                                    .and_then(remove_empty_hover_blocks)\n                            }\n                        }),\n                )\n                .await\n                .into_iter()\n                .flatten()\n                .collect()\n            })\n        } else {\n            let all_actions_task = self.request_multiple_lsp_locally(\n                buffer,\n                Some(position),\n                GetHover { position },\n                cx,\n            );\n            cx.spawn(async move |_, _| {\n                all_actions_task\n                    .await\n                    .into_iter()\n                    .filter_map(|hover| remove_empty_hover_blocks(hover?))\n                    .collect::<Vec<Hover>>()\n            })\n        }\n    }\n\n    pub fn symbols(&self, query: &str, cx: &mut Context<Self>) -> Task<Result<Vec<Symbol>>> {\n        let language_registry = self.languages.clone();\n\n        if let Some((upstream_client, project_id)) = self.upstream_client().as_ref() {\n            let request = upstream_client.request(proto::GetProjectSymbols {\n                project_id: *project_id,\n                query: query.to_string(),\n            });\n            cx.foreground_executor().spawn(async move {\n                let response = request.await?;\n                let mut symbols = Vec::new();\n                let core_symbols = response\n                    .symbols\n                    .into_iter()\n                    .filter_map(|symbol| Self::deserialize_symbol(symbol).log_err())\n                    .collect::<Vec<_>>();\n                populate_labels_for_symbols(core_symbols, &language_registry, None, &mut symbols)\n                    .await;\n                Ok(symbols)\n            })\n        } else if let Some(local) = self.as_local() {\n            struct WorkspaceSymbolsResult {\n                server_id: LanguageServerId,\n                lsp_adapter: Arc<CachedLspAdapter>,\n                worktree: WeakEntity<Worktree>,\n                worktree_abs_path: Arc<Path>,\n                lsp_symbols: Vec<(String, SymbolKind, lsp::Location)>,\n            }\n\n            let mut requests = Vec::new();\n            let mut requested_servers = BTreeSet::new();\n            'next_server: for ((worktree_id, _), server_ids) in local.language_server_ids.iter() {\n                let Some(worktree_handle) = self\n                    .worktree_store\n                    .read(cx)\n                    .worktree_for_id(*worktree_id, cx)\n                else {\n                    continue;\n                };\n                let worktree = worktree_handle.read(cx);\n                if !worktree.is_visible() {\n                    continue;\n                }\n\n                let mut servers_to_query = server_ids\n                    .difference(&requested_servers)\n                    .cloned()\n                    .collect::<BTreeSet<_>>();\n                for server_id in &servers_to_query {\n                    let (lsp_adapter, server) = match local.language_servers.get(server_id) {\n                        Some(LanguageServerState::Running {\n                            adapter, server, ..\n                        }) => (adapter.clone(), server),\n\n                        _ => continue 'next_server,\n                    };\n                    let supports_workspace_symbol_request =\n                        match server.capabilities().workspace_symbol_provider {\n                            Some(OneOf::Left(supported)) => supported,\n                            Some(OneOf::Right(_)) => true,\n                            None => false,\n                        };\n                    if !supports_workspace_symbol_request {\n                        continue 'next_server;\n                    }\n                    let worktree_abs_path = worktree.abs_path().clone();\n                    let worktree_handle = worktree_handle.clone();\n                    let server_id = server.server_id();\n                    requests.push(\n                        server\n                            .request::<lsp::request::WorkspaceSymbolRequest>(\n                                lsp::WorkspaceSymbolParams {\n                                    query: query.to_string(),\n                                    ..Default::default()\n                                },\n                            )\n                            .map(move |response| {\n                                let lsp_symbols = response.into_response()\n                                    .context(": "",
    ")\n                                    .log_err()\n                                    .flatten()\n                                    .map(|symbol_response| match symbol_response {\n                                        lsp::WorkspaceSymbolResponse::Flat(flat_responses) => {\n                                            flat_responses.into_iter().map(|lsp_symbol| {\n                                            (lsp_symbol.name, lsp_symbol.kind, lsp_symbol.location)\n                                            }).collect::<Vec<_>>()\n                                        }\n                                        lsp::WorkspaceSymbolResponse::Nested(nested_responses) => {\n                                            nested_responses.into_iter().filter_map(|lsp_symbol| {\n                                                let location = match lsp_symbol.location {\n                                                    OneOf::Left(location) => location,\n                                                    OneOf::Right(_) => {\n                                                        log::error!(": "",
    ");\n                                                        return None\n                                                    }\n                                                };\n                                                Some((lsp_symbol.name, lsp_symbol.kind, location))\n                                            }).collect::<Vec<_>>()\n                                        }\n                                    }).unwrap_or_default();\n\n                                WorkspaceSymbolsResult {\n                                    server_id,\n                                    lsp_adapter,\n                                    worktree: worktree_handle.downgrade(),\n                                    worktree_abs_path,\n                                    lsp_symbols,\n                                }\n                            }),\n                    );\n                }\n                requested_servers.append(&mut servers_to_query);\n            }\n\n            cx.spawn(async move |this, cx| {\n                let responses = futures::future::join_all(requests).await;\n                let this = match this.upgrade() {\n                    Some(this) => this,\n                    None => return Ok(Vec::new()),\n                };\n\n                let mut symbols = Vec::new();\n                for result in responses {\n                    let core_symbols = this.update(cx, |this, cx| {\n                        result\n                            .lsp_symbols\n                            .into_iter()\n                            .filter_map(|(symbol_name, symbol_kind, symbol_location)| {\n                                let abs_path = symbol_location.uri.to_file_path().ok()?;\n                                let source_worktree = result.worktree.upgrade()?;\n                                let source_worktree_id = source_worktree.read(cx).id();\n\n                                let path;\n                                let worktree;\n                                if let Some((tree, rel_path)) =\n                                    this.worktree_store.read(cx).find_worktree(&abs_path, cx)\n                                {\n                                    worktree = tree;\n                                    path = rel_path;\n                                } else {\n                                    worktree = source_worktree.clone();\n                                    path = relativize_path(&result.worktree_abs_path, &abs_path);\n                                }\n\n                                let worktree_id = worktree.read(cx).id();\n                                let project_path = ProjectPath {\n                                    worktree_id,\n                                    path: path.into(),\n                                };\n                                let signature = this.symbol_signature(&project_path);\n                                Some(CoreSymbol {\n                                    source_language_server_id: result.server_id,\n                                    language_server_name: result.lsp_adapter.name.clone(),\n                                    source_worktree_id,\n                                    path: project_path,\n                                    kind: symbol_kind,\n                                    name: symbol_name,\n                                    range: range_from_lsp(symbol_location.range),\n                                    signature,\n                                })\n                            })\n                            .collect()\n                    })?;\n\n                    populate_labels_for_symbols(\n                        core_symbols,\n                        &language_registry,\n                        Some(result.lsp_adapter),\n                        &mut symbols,\n                    )\n                    .await;\n                }\n\n                Ok(symbols)\n            })\n        } else {\n            Task::ready(Err(anyhow!(": "",
    ")))\n        }\n    }\n\n    pub fn diagnostic_summary(&self, include_ignored: bool, cx: &App) -> DiagnosticSummary {\n        let mut summary = DiagnosticSummary::default();\n        for (_, _, path_summary) in self.diagnostic_summaries(include_ignored, cx) {\n            summary.error_count += path_summary.error_count;\n            summary.warning_count += path_summary.warning_count;\n        }\n        summary\n    }\n\n    pub fn diagnostic_summaries<'a>(\n        &'a self,\n        include_ignored: bool,\n        cx: &'a App,\n    ) -> impl Iterator<Item = (ProjectPath, LanguageServerId, DiagnosticSummary)> + 'a {\n        self.worktree_store\n            .read(cx)\n            .visible_worktrees(cx)\n            .filter_map(|worktree| {\n                let worktree = worktree.read(cx);\n                Some((worktree, self.diagnostic_summaries.get(&worktree.id())?))\n            })\n            .flat_map(move |(worktree, summaries)| {\n                let worktree_id = worktree.id();\n                summaries\n                    .iter()\n                    .filter(move |(path, _)| {\n                        include_ignored\n                            || worktree\n                                .entry_for_path(path.as_ref())\n                                .map_or(false, |entry| !entry.is_ignored)\n                    })\n                    .flat_map(move |(path, summaries)| {\n                        summaries.iter().map(move |(server_id, summary)| {\n                            (\n                                ProjectPath {\n                                    worktree_id,\n                                    path: path.clone(),\n                                },\n                                *server_id,\n                                *summary,\n                            )\n                        })\n                    })\n            })\n    }\n\n    pub fn on_buffer_edited(\n        &mut self,\n        buffer: Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        let language_servers: Vec<_> = buffer.update(cx, |buffer, cx| {\n            Some(\n                self.as_local()?\n                    .language_servers_for_buffer(buffer, cx)\n                    .map(|i| i.1.clone())\n                    .collect(),\n            )\n        })?;\n\n        let buffer = buffer.read(cx);\n        let file = File::from_dyn(buffer.file())?;\n        let abs_path = file.as_local()?.abs_path(cx);\n        let uri = lsp::Url::from_file_path(abs_path).unwrap();\n        let next_snapshot = buffer.text_snapshot();\n        for language_server in language_servers {\n            let language_server = language_server.clone();\n\n            let buffer_snapshots = self\n                .as_local_mut()\n                .unwrap()\n                .buffer_snapshots\n                .get_mut(&buffer.remote_id())\n                .and_then(|m| m.get_mut(&language_server.server_id()))?;\n            let previous_snapshot = buffer_snapshots.last()?;\n\n            let build_incremental_change = || {\n                buffer\n                    .edits_since::<(PointUtf16, usize)>(previous_snapshot.snapshot.version())\n                    .map(|edit| {\n                        let edit_start = edit.new.start.0;\n                        let edit_end = edit_start + (edit.old.end.0 - edit.old.start.0);\n                        let new_text = next_snapshot\n                            .text_for_range(edit.new.start.1..edit.new.end.1)\n                            .collect();\n                        lsp::TextDocumentContentChangeEvent {\n                            range: Some(lsp::Range::new(\n                                point_to_lsp(edit_start),\n                                point_to_lsp(edit_end),\n                            )),\n                            range_length: None,\n                            text: new_text,\n                        }\n                    })\n                    .collect()\n            };\n\n            let document_sync_kind = language_server\n                .capabilities()\n                .text_document_sync\n                .as_ref()\n                .and_then(|sync| match sync {\n                    lsp::TextDocumentSyncCapability::Kind(kind) => Some(*kind),\n                    lsp::TextDocumentSyncCapability::Options(options) => options.change,\n                });\n\n            let content_changes: Vec<_> = match document_sync_kind {\n                Some(lsp::TextDocumentSyncKind::FULL) => {\n                    vec![lsp::TextDocumentContentChangeEvent {\n                        range: None,\n                        range_length: None,\n                        text: next_snapshot.text(),\n                    }]\n                }\n                Some(lsp::TextDocumentSyncKind::INCREMENTAL) => build_incremental_change(),\n                _ => {\n                    #[cfg(any(test, feature = ": "",
    "))]\n                    {\n                        build_incremental_change()\n                    }\n\n                    #[cfg(not(any(test, feature = ": "",
    ")))]\n                    {\n                        continue;\n                    }\n                }\n            };\n\n            let next_version = previous_snapshot.version + 1;\n            buffer_snapshots.push(LspBufferSnapshot {\n                version: next_version,\n                snapshot: next_snapshot.clone(),\n            });\n\n            language_server\n                .notify::<lsp::notification::DidChangeTextDocument>(\n                    &lsp::DidChangeTextDocumentParams {\n                        text_document: lsp::VersionedTextDocumentIdentifier::new(\n                            uri.clone(),\n                            next_version,\n                        ),\n                        content_changes,\n                    },\n                )\n                .ok();\n            self.pull_workspace_diagnostics(language_server.server_id());\n        }\n\n        None\n    }\n\n    pub fn on_buffer_saved(\n        &mut self,\n        buffer: Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        let file = File::from_dyn(buffer.read(cx).file())?;\n        let worktree_id = file.worktree_id(cx);\n        let abs_path = file.as_local()?.abs_path(cx);\n        let text_document = lsp::TextDocumentIdentifier {\n            uri: file_path_to_lsp_url(&abs_path).log_err()?,\n        };\n        let local = self.as_local()?;\n\n        for server in local.language_servers_for_worktree(worktree_id) {\n            if let Some(include_text) = include_text(server.as_ref()) {\n                let text = if include_text {\n                    Some(buffer.read(cx).text())\n                } else {\n                    None\n                };\n                server\n                    .notify::<lsp::notification::DidSaveTextDocument>(\n                        &lsp::DidSaveTextDocumentParams {\n                            text_document: text_document.clone(),\n                            text,\n                        },\n                    )\n                    .ok();\n            }\n        }\n\n        let language_servers = buffer.update(cx, |buffer, cx| {\n            local.language_server_ids_for_buffer(buffer, cx)\n        });\n        for language_server_id in language_servers {\n            self.simulate_disk_based_diagnostics_events_if_needed(language_server_id, cx);\n        }\n\n        None\n    }\n\n    pub(crate) async fn refresh_workspace_configurations(\n        this: &WeakEntity<Self>,\n        fs: Arc<dyn Fs>,\n        cx: &mut AsyncApp,\n    ) {\n        maybe!(async move {\n            let servers = this\n                .update(cx, |this, cx| {\n                    let Some(local) = this.as_local() else {\n                        return Vec::default();\n                    };\n                    local\n                        .language_server_ids\n                        .iter()\n                        .flat_map(|((worktree_id, _), server_ids)| {\n                            let worktree = this\n                                .worktree_store\n                                .read(cx)\n                                .worktree_for_id(*worktree_id, cx);\n                            let delegate = worktree.map(|worktree| {\n                                LocalLspAdapterDelegate::new(\n                                    local.languages.clone(),\n                                    &local.environment,\n                                    cx.weak_entity(),\n                                    &worktree,\n                                    local.http_client.clone(),\n                                    local.fs.clone(),\n                                    cx,\n                                )\n                            });\n\n                            server_ids.iter().filter_map(move |server_id| {\n                                let states = local.language_servers.get(server_id)?;\n\n                                match states {\n                                    LanguageServerState::Starting { .. } => None,\n                                    LanguageServerState::Running {\n                                        adapter, server, ..\n                                    } => Some((\n                                        adapter.adapter.clone(),\n                                        server.clone(),\n                                        delegate.clone()? as Arc<dyn LspAdapterDelegate>,\n                                    )),\n                                }\n                            })\n                        })\n                        .collect::<Vec<_>>()\n                })\n                .ok()?;\n\n            let toolchain_store = this.update(cx, |this, cx| this.toolchain_store(cx)).ok()?;\n            for (adapter, server, delegate) in servers {\n                let settings = LocalLspStore::workspace_configuration_for_adapter(\n                    adapter,\n                    fs.as_ref(),\n                    &delegate,\n                    toolchain_store.clone(),\n                    cx,\n                )\n                .await\n                .ok()?;\n\n                server\n                    .notify::<lsp::notification::DidChangeConfiguration>(\n                        &lsp::DidChangeConfigurationParams { settings },\n                    )\n                    .ok();\n            }\n            Some(())\n        })\n        .await;\n    }\n\n    fn toolchain_store(&self, cx: &App) -> Arc<dyn LanguageToolchainStore> {\n        if let Some(toolchain_store) = self.toolchain_store.as_ref() {\n            toolchain_store.read(cx).as_language_toolchain_store()\n        } else {\n            Arc::new(EmptyToolchainStore)\n        }\n    }\n    fn maintain_workspace_config(\n        fs: Arc<dyn Fs>,\n        external_refresh_requests: watch::Receiver<()>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        let (mut settings_changed_tx, mut settings_changed_rx) = watch::channel();\n        let _ = postage::stream::Stream::try_recv(&mut settings_changed_rx);\n\n        let settings_observation = cx.observe_global::<SettingsStore>(move |_, _| {\n            *settings_changed_tx.borrow_mut() = ();\n        });\n\n        let mut joint_future =\n            futures::stream::select(settings_changed_rx, external_refresh_requests);\n        cx.spawn(async move |this, cx| {\n            while let Some(()) = joint_future.next().await {\n                Self::refresh_workspace_configurations(&this, fs.clone(), cx).await;\n            }\n\n            drop(settings_observation);\n            anyhow::Ok(())\n        })\n    }\n\n    pub fn language_servers_for_local_buffer<'a>(\n        &'a self,\n        buffer: &Buffer,\n        cx: &mut App,\n    ) -> impl Iterator<Item = (&'a Arc<CachedLspAdapter>, &'a Arc<LanguageServer>)> {\n        let local = self.as_local();\n        let language_server_ids = local\n            .map(|local| local.language_server_ids_for_buffer(buffer, cx))\n            .unwrap_or_default();\n\n        language_server_ids\n            .into_iter()\n            .filter_map(\n                move |server_id| match local?.language_servers.get(&server_id)? {\n                    LanguageServerState::Running {\n                        adapter, server, ..\n                    } => Some((adapter, server)),\n                    _ => None,\n                },\n            )\n    }\n\n    pub fn language_server_for_local_buffer<'a>(\n        &'a self,\n        buffer: &'a Buffer,\n        server_id: LanguageServerId,\n        cx: &'a mut App,\n    ) -> Option<(&'a Arc<CachedLspAdapter>, &'a Arc<LanguageServer>)> {\n        self.as_local()?\n            .language_servers_for_buffer(buffer, cx)\n            .find(|(_, s)| s.server_id() == server_id)\n    }\n\n    fn remove_worktree(&mut self, id_to_remove: WorktreeId, cx: &mut Context<Self>) {\n        self.diagnostic_summaries.remove(&id_to_remove);\n        if let Some(local) = self.as_local_mut() {\n            let to_remove = local.remove_worktree(id_to_remove, cx);\n            for server in to_remove {\n                self.language_server_statuses.remove(&server);\n            }\n        }\n    }\n\n    pub fn shared(\n        &mut self,\n        project_id: u64,\n        downstream_client: AnyProtoClient,\n        _: &mut Context<Self>,\n    ) {\n        self.downstream_client = Some((downstream_client.clone(), project_id));\n\n        for (server_id, status) in &self.language_server_statuses {\n            downstream_client\n                .send(proto::StartLanguageServer {\n                    project_id,\n                    server: Some(proto::LanguageServer {\n                        id: server_id.0 as u64,\n                        name: status.name.clone(),\n                        worktree_id: None,\n                    }),\n                })\n                .log_err();\n        }\n    }\n\n    pub fn disconnected_from_host(&mut self) {\n        self.downstream_client.take();\n    }\n\n    pub fn disconnected_from_ssh_remote(&mut self) {\n        if let LspStoreMode::Remote(RemoteLspStore {\n            upstream_client, ..\n        }) = &mut self.mode\n        {\n            upstream_client.take();\n        }\n    }\n\n    pub(crate) fn set_language_server_statuses_from_proto(\n        &mut self,\n        language_servers: Vec<proto::LanguageServer>,\n    ) {\n        self.language_server_statuses = language_servers\n            .into_iter()\n            .map(|server| {\n                (\n                    LanguageServerId(server.id as usize),\n                    LanguageServerStatus {\n                        name: server.name,\n                        pending_work: Default::default(),\n                        has_pending_diagnostic_updates: false,\n                        progress_tokens: Default::default(),\n                    },\n                )\n            })\n            .collect();\n    }\n\n    fn register_local_language_server(\n        &mut self,\n        worktree: Entity<Worktree>,\n        language_server_name: LanguageServerName,\n        language_server_id: LanguageServerId,\n        cx: &mut App,\n    ) {\n        let Some(local) = self.as_local_mut() else {\n            return;\n        };\n\n        let worktree_id = worktree.read(cx).id();\n        if worktree.read(cx).is_visible() {\n            let path = ProjectPath {\n                worktree_id,\n                path: Arc::from(": "",
    ".as_ref()),\n            };\n            let delegate = Arc::new(ManifestQueryDelegate::new(worktree.read(cx).snapshot()));\n            local.lsp_tree.update(cx, |language_server_tree, cx| {\n                for node in language_server_tree.get(\n                    path,\n                    AdapterQuery::Adapter(&language_server_name),\n                    delegate,\n                    cx,\n                ) {\n                    node.server_id_or_init(|disposition| {\n                        assert_eq!(disposition.server_name, &language_server_name);\n\n                        language_server_id\n                    });\n                }\n            });\n        }\n\n        local\n            .language_server_ids\n            .entry((worktree_id, language_server_name))\n            .or_default()\n            .insert(language_server_id);\n    }\n\n    #[cfg(test)]\n    pub fn update_diagnostic_entries(\n        &mut self,\n        server_id: LanguageServerId,\n        abs_path: PathBuf,\n        result_id: Option<String>,\n        version: Option<i32>,\n        diagnostics: Vec<DiagnosticEntry<Unclipped<PointUtf16>>>,\n        cx: &mut Context<Self>,\n    ) -> anyhow::Result<()> {\n        self.merge_diagnostic_entries(\n            server_id,\n            abs_path,\n            result_id,\n            version,\n            diagnostics,\n            |_, _| false,\n            cx,\n        )\n    }\n\n    pub fn merge_diagnostic_entries<F: Fn(&Diagnostic, &App) -> bool + Clone>(\n        &mut self,\n        server_id: LanguageServerId,\n        abs_path: PathBuf,\n        result_id: Option<String>,\n        version: Option<i32>,\n        mut diagnostics: Vec<DiagnosticEntry<Unclipped<PointUtf16>>>,\n        filter: F,\n        cx: &mut Context<Self>,\n    ) -> anyhow::Result<()> {\n        let Some((worktree, relative_path)) =\n            self.worktree_store.read(cx).find_worktree(&abs_path, cx)\n        else {\n            log::warn!(": "",
    ");\n            return Ok(());\n        };\n\n        let project_path = ProjectPath {\n            worktree_id: worktree.read(cx).id(),\n            path: relative_path.into(),\n        };\n\n        if let Some(buffer_handle) = self.buffer_store.read(cx).get_by_path(&project_path, cx) {\n            let snapshot = self\n                .as_local_mut()\n                .unwrap()\n                .buffer_snapshot_for_lsp_version(&buffer_handle, server_id, version, cx)?;\n\n            let buffer = buffer_handle.read(cx);\n            let reused_diagnostics = buffer\n                .get_diagnostics(server_id)\n                .into_iter()\n                .flat_map(|diag| {\n                    diag.iter().filter(|v| filter(&v.diagnostic, cx)).map(|v| {\n                        let start = Unclipped(v.range.start.to_point_utf16(&snapshot));\n                        let end = Unclipped(v.range.end.to_point_utf16(&snapshot));\n                        DiagnosticEntry {\n                            range: start..end,\n                            diagnostic: v.diagnostic.clone(),\n                        }\n                    })\n                })\n                .collect::<Vec<_>>();\n\n            self.as_local_mut().unwrap().update_buffer_diagnostics(\n                &buffer_handle,\n                server_id,\n                result_id,\n                version,\n                diagnostics.clone(),\n                reused_diagnostics.clone(),\n                cx,\n            )?;\n\n            diagnostics.extend(reused_diagnostics);\n        }\n\n        let updated = worktree.update(cx, |worktree, cx| {\n            self.update_worktree_diagnostics(\n                worktree.id(),\n                server_id,\n                project_path.path.clone(),\n                diagnostics,\n                cx,\n            )\n        })?;\n        if updated {\n            cx.emit(LspStoreEvent::DiagnosticsUpdated {\n                language_server_id: server_id,\n                path: project_path,\n            })\n        }\n        Ok(())\n    }\n\n    fn update_worktree_diagnostics(\n        &mut self,\n        worktree_id: WorktreeId,\n        server_id: LanguageServerId,\n        worktree_path: Arc<Path>,\n        diagnostics: Vec<DiagnosticEntry<Unclipped<PointUtf16>>>,\n        _: &mut Context<Worktree>,\n    ) -> Result<bool> {\n        let local = match &mut self.mode {\n            LspStoreMode::Local(local_lsp_store) => local_lsp_store,\n            _ => anyhow::bail!(": "",
    "),\n        };\n\n        let summaries_for_tree = self.diagnostic_summaries.entry(worktree_id).or_default();\n        let diagnostics_for_tree = local.diagnostics.entry(worktree_id).or_default();\n        let summaries_by_server_id = summaries_for_tree.entry(worktree_path.clone()).or_default();\n\n        let old_summary = summaries_by_server_id\n            .remove(&server_id)\n            .unwrap_or_default();\n\n        let new_summary = DiagnosticSummary::new(&diagnostics);\n        if new_summary.is_empty() {\n            if let Some(diagnostics_by_server_id) = diagnostics_for_tree.get_mut(&worktree_path) {\n                if let Ok(ix) = diagnostics_by_server_id.binary_search_by_key(&server_id, |e| e.0) {\n                    diagnostics_by_server_id.remove(ix);\n                }\n                if diagnostics_by_server_id.is_empty() {\n                    diagnostics_for_tree.remove(&worktree_path);\n                }\n            }\n        } else {\n            summaries_by_server_id.insert(server_id, new_summary);\n            let diagnostics_by_server_id = diagnostics_for_tree\n                .entry(worktree_path.clone())\n                .or_default();\n            match diagnostics_by_server_id.binary_search_by_key(&server_id, |e| e.0) {\n                Ok(ix) => {\n                    diagnostics_by_server_id[ix] = (server_id, diagnostics);\n                }\n                Err(ix) => {\n                    diagnostics_by_server_id.insert(ix, (server_id, diagnostics));\n                }\n            }\n        }\n\n        if !old_summary.is_empty() || !new_summary.is_empty() {\n            if let Some((downstream_client, project_id)) = &self.downstream_client {\n                downstream_client\n                    .send(proto::UpdateDiagnosticSummary {\n                        project_id: *project_id,\n                        worktree_id: worktree_id.to_proto(),\n                        summary: Some(proto::DiagnosticSummary {\n                            path: worktree_path.to_proto(),\n                            language_server_id: server_id.0 as u64,\n                            error_count: new_summary.error_count as u32,\n                            warning_count: new_summary.warning_count as u32,\n                        }),\n                    })\n                    .log_err();\n            }\n        }\n\n        Ok(!old_summary.is_empty() || !new_summary.is_empty())\n    }\n\n    pub fn open_buffer_for_symbol(\n        &mut self,\n        symbol: &Symbol,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<Buffer>>> {\n        if let Some((client, project_id)) = self.upstream_client() {\n            let request = client.request(proto::OpenBufferForSymbol {\n                project_id,\n                symbol: Some(Self::serialize_symbol(symbol)),\n            });\n            cx.spawn(async move |this, cx| {\n                let response = request.await?;\n                let buffer_id = BufferId::new(response.buffer_id)?;\n                this.update(cx, |this, cx| this.wait_for_remote_buffer(buffer_id, cx))?\n                    .await\n            })\n        } else if let Some(local) = self.as_local() {\n            let Some(language_server_id) = local\n                .language_server_ids\n                .get(&(\n                    symbol.source_worktree_id,\n                    symbol.language_server_name.clone(),\n                ))\n                .and_then(|ids| {\n                    ids.contains(&symbol.source_language_server_id)\n                        .then_some(symbol.source_language_server_id)\n                })\n            else {\n                return Task::ready(Err(anyhow!(\n                    ": "",
    "\n                )));\n            };\n\n            let worktree_abs_path = if let Some(worktree_abs_path) = self\n                .worktree_store\n                .read(cx)\n                .worktree_for_id(symbol.path.worktree_id, cx)\n                .map(|worktree| worktree.read(cx).abs_path())\n            {\n                worktree_abs_path\n            } else {\n                return Task::ready(Err(anyhow!(": "",
    ")));\n            };\n\n            let symbol_abs_path = resolve_path(&worktree_abs_path, &symbol.path.path);\n            let symbol_uri = if let Ok(uri) = lsp::Url::from_file_path(symbol_abs_path) {\n                uri\n            } else {\n                return Task::ready(Err(anyhow!(": "",
    ")));\n            };\n\n            self.open_local_buffer_via_lsp(\n                symbol_uri,\n                language_server_id,\n                symbol.language_server_name.clone(),\n                cx,\n            )\n        } else {\n            Task::ready(Err(anyhow!(": "",
    ")))\n        }\n    }\n\n    pub fn open_local_buffer_via_lsp(\n        &mut self,\n        mut abs_path: lsp::Url,\n        language_server_id: LanguageServerId,\n        language_server_name: LanguageServerName,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<Buffer>>> {\n        cx.spawn(async move |lsp_store, cx| {\n            // Escape percent-encoded string.\n            let current_scheme = abs_path.scheme().to_owned();\n            let _ = abs_path.set_scheme(": "",
    ");\n\n            let abs_path = abs_path\n                .to_file_path()\n                .map_err(|()| anyhow!(": "",
    "))?;\n            let p = abs_path.clone();\n            let yarn_worktree = lsp_store\n                .update(cx, move |lsp_store, cx| match lsp_store.as_local() {\n                    Some(local_lsp_store) => local_lsp_store.yarn.update(cx, |_, cx| {\n                        cx.spawn(async move |this, cx| {\n                            let t = this\n                                .update(cx, |this, cx| this.process_path(&p, &current_scheme, cx))\n                                .ok()?;\n                            t.await\n                        })\n                    }),\n                    None => Task::ready(None),\n                })?\n                .await;\n            let (worktree_root_target, known_relative_path) =\n                if let Some((zip_root, relative_path)) = yarn_worktree {\n                    (zip_root, Some(relative_path))\n                } else {\n                    (Arc::<Path>::from(abs_path.as_path()), None)\n                };\n            let (worktree, relative_path) = if let Some(result) =\n                lsp_store.update(cx, |lsp_store, cx| {\n                    lsp_store.worktree_store.update(cx, |worktree_store, cx| {\n                        worktree_store.find_worktree(&worktree_root_target, cx)\n                    })\n                })? {\n                let relative_path =\n                    known_relative_path.unwrap_or_else(|| Arc::<Path>::from(result.1));\n                (result.0, relative_path)\n            } else {\n                let worktree = lsp_store\n                    .update(cx, |lsp_store, cx| {\n                        lsp_store.worktree_store.update(cx, |worktree_store, cx| {\n                            worktree_store.create_worktree(&worktree_root_target, false, cx)\n                        })\n                    })?\n                    .await?;\n                if worktree.read_with(cx, |worktree, _| worktree.is_local())? {\n                    lsp_store\n                        .update(cx, |lsp_store, cx| {\n                            lsp_store.register_local_language_server(\n                                worktree.clone(),\n                                language_server_name,\n                                language_server_id,\n                                cx,\n                            )\n                        })\n                        .ok();\n                }\n                let worktree_root = worktree.read_with(cx, |worktree, _| worktree.abs_path())?;\n                let relative_path = if let Some(known_path) = known_relative_path {\n                    known_path\n                } else {\n                    abs_path.strip_prefix(worktree_root)?.into()\n                };\n                (worktree, relative_path)\n            };\n            let project_path = ProjectPath {\n                worktree_id: worktree.read_with(cx, |worktree, _| worktree.id())?,\n                path: relative_path,\n            };\n            lsp_store\n                .update(cx, |lsp_store, cx| {\n                    lsp_store.buffer_store().update(cx, |buffer_store, cx| {\n                        buffer_store.open_buffer(project_path, cx)\n                    })\n                })?\n                .await\n        })\n    }\n\n    fn request_multiple_lsp_locally<P, R>(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: Option<P>,\n        request: R,\n        cx: &mut Context<Self>,\n    ) -> Task<Vec<R::Response>>\n    where\n        P: ToOffset,\n        R: LspCommand + Clone,\n        <R::LspRequest as lsp::request::Request>::Result: Send,\n        <R::LspRequest as lsp::request::Request>::Params: Send,\n    {\n        let Some(local) = self.as_local() else {\n            return Task::ready(Vec::new());\n        };\n\n        let snapshot = buffer.read(cx).snapshot();\n        let scope = position.and_then(|position| snapshot.language_scope_at(position));\n\n        let server_ids = buffer.update(cx, |buffer, cx| {\n            local\n                .language_servers_for_buffer(buffer, cx)\n                .filter(|(adapter, _)| {\n                    scope\n                        .as_ref()\n                        .map(|scope| scope.language_allowed(&adapter.name))\n                        .unwrap_or(true)\n                })\n                .map(|(_, server)| server.server_id())\n                .collect::<Vec<_>>()\n        });\n\n        let mut response_results = server_ids\n            .into_iter()\n            .map(|server_id| {\n                self.request_lsp(\n                    buffer.clone(),\n                    LanguageServerToQuery::Other(server_id),\n                    request.clone(),\n                    cx,\n                )\n            })\n            .collect::<FuturesUnordered<_>>();\n\n        cx.spawn(async move |_, _| {\n            let mut responses = Vec::with_capacity(response_results.len());\n            while let Some(response_result) = response_results.next().await {\n                if let Some(response) = response_result.log_err() {\n                    responses.push(response);\n                }\n            }\n            responses\n        })\n    }\n\n    async fn handle_lsp_command<T: LspCommand>(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<T::ProtoRequest>,\n        mut cx: AsyncApp,\n    ) -> Result<<T::ProtoRequest as proto::RequestMessage>::Response>\n    where\n        <T::LspRequest as lsp::request::Request>::Params: Send,\n        <T::LspRequest as lsp::request::Request>::Result: Send,\n    {\n        let sender_id = envelope.original_sender_id().unwrap_or_default();\n        let buffer_id = T::buffer_id_from_proto(&envelope.payload)?;\n        let buffer_handle = this.update(&mut cx, |this, cx| {\n            this.buffer_store.read(cx).get_existing(buffer_id)\n        })??;\n        let request = T::from_proto(\n            envelope.payload,\n            this.clone(),\n            buffer_handle.clone(),\n            cx.clone(),\n        )\n        .await?;\n        let response = this\n            .update(&mut cx, |this, cx| {\n                this.request_lsp(\n                    buffer_handle.clone(),\n                    LanguageServerToQuery::FirstCapable,\n                    request,\n                    cx,\n                )\n            })?\n            .await?;\n        this.update(&mut cx, |this, cx| {\n            Ok(T::response_to_proto(\n                response,\n                this,\n                sender_id,\n                &buffer_handle.read(cx).version(),\n                cx,\n            ))\n        })?\n    }\n\n    async fn handle_multi_lsp_query(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::MultiLspQuery>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::MultiLspQueryResponse> {\n        let response_from_ssh = lsp_store.read_with(&mut cx, |this, _| {\n            let (upstream_client, project_id) = this.upstream_client()?;\n            let mut payload = envelope.payload.clone();\n            payload.project_id = project_id;\n\n            Some(upstream_client.request(payload))\n        })?;\n        if let Some(response_from_ssh) = response_from_ssh {\n            return response_from_ssh.await;\n        }\n\n        let sender_id = envelope.original_sender_id().unwrap_or_default();\n        let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n        let version = deserialize_version(&envelope.payload.version);\n        let buffer = lsp_store.update(&mut cx, |this, cx| {\n            this.buffer_store.read(cx).get_existing(buffer_id)\n        })??;\n        buffer\n            .update(&mut cx, |buffer, _| {\n                buffer.wait_for_version(version.clone())\n            })?\n            .await?;\n        let buffer_version = buffer.read_with(&mut cx, |buffer, _| buffer.version())?;\n        match envelope\n            .payload\n            .strategy\n            .context(": "",
    ")?\n        {\n            proto::multi_lsp_query::Strategy::All(_) => {\n                // currently, there's only one multiple language servers query strategy,\n                // so just ensure it's specified correctly\n            }\n        }\n        match envelope.payload.request {\n            Some(proto::multi_lsp_query::Request::GetHover(get_hover)) => {\n                let get_hover =\n                    GetHover::from_proto(get_hover, lsp_store.clone(), buffer.clone(), cx.clone())\n                        .await?;\n                let all_hovers = lsp_store\n                    .update(&mut cx, |this, cx| {\n                        this.request_multiple_lsp_locally(\n                            &buffer,\n                            Some(get_hover.position),\n                            get_hover,\n                            cx,\n                        )\n                    })?\n                    .await\n                    .into_iter()\n                    .filter_map(|hover| remove_empty_hover_blocks(hover?));\n                lsp_store.update(&mut cx, |project, cx| proto::MultiLspQueryResponse {\n                    responses: all_hovers\n                        .map(|hover| proto::LspResponse {\n                            response: Some(proto::lsp_response::Response::GetHoverResponse(\n                                GetHover::response_to_proto(\n                                    Some(hover),\n                                    project,\n                                    sender_id,\n                                    &buffer_version,\n                                    cx,\n                                ),\n                            )),\n                        })\n                        .collect(),\n                })\n            }\n            Some(proto::multi_lsp_query::Request::GetCodeActions(get_code_actions)) => {\n                let get_code_actions = GetCodeActions::from_proto(\n                    get_code_actions,\n                    lsp_store.clone(),\n                    buffer.clone(),\n                    cx.clone(),\n                )\n                .await?;\n\n                let all_actions = lsp_store\n                    .update(&mut cx, |project, cx| {\n                        project.request_multiple_lsp_locally(\n                            &buffer,\n                            Some(get_code_actions.range.start),\n                            get_code_actions,\n                            cx,\n                        )\n                    })?\n                    .await\n                    .into_iter();\n\n                lsp_store.update(&mut cx, |project, cx| proto::MultiLspQueryResponse {\n                    responses: all_actions\n                        .map(|code_actions| proto::LspResponse {\n                            response: Some(proto::lsp_response::Response::GetCodeActionsResponse(\n                                GetCodeActions::response_to_proto(\n                                    code_actions,\n                                    project,\n                                    sender_id,\n                                    &buffer_version,\n                                    cx,\n                                ),\n                            )),\n                        })\n                        .collect(),\n                })\n            }\n            Some(proto::multi_lsp_query::Request::GetSignatureHelp(get_signature_help)) => {\n                let get_signature_help = GetSignatureHelp::from_proto(\n                    get_signature_help,\n                    lsp_store.clone(),\n                    buffer.clone(),\n                    cx.clone(),\n                )\n                .await?;\n\n                let all_signatures = lsp_store\n                    .update(&mut cx, |project, cx| {\n                        project.request_multiple_lsp_locally(\n                            &buffer,\n                            Some(get_signature_help.position),\n                            get_signature_help,\n                            cx,\n                        )\n                    })?\n                    .await\n                    .into_iter();\n\n                lsp_store.update(&mut cx, |project, cx| proto::MultiLspQueryResponse {\n                    responses: all_signatures\n                        .map(|signature_help| proto::LspResponse {\n                            response: Some(\n                                proto::lsp_response::Response::GetSignatureHelpResponse(\n                                    GetSignatureHelp::response_to_proto(\n                                        signature_help,\n                                        project,\n                                        sender_id,\n                                        &buffer_version,\n                                        cx,\n                                    ),\n                                ),\n                            ),\n                        })\n                        .collect(),\n                })\n            }\n            Some(proto::multi_lsp_query::Request::GetCodeLens(get_code_lens)) => {\n                let get_code_lens = GetCodeLens::from_proto(\n                    get_code_lens,\n                    lsp_store.clone(),\n                    buffer.clone(),\n                    cx.clone(),\n                )\n                .await?;\n\n                let code_lens_actions = lsp_store\n                    .update(&mut cx, |project, cx| {\n                        project.request_multiple_lsp_locally(\n                            &buffer,\n                            None::<usize>,\n                            get_code_lens,\n                            cx,\n                        )\n                    })?\n                    .await\n                    .into_iter();\n\n                lsp_store.update(&mut cx, |project, cx| proto::MultiLspQueryResponse {\n                    responses: code_lens_actions\n                        .map(|actions| proto::LspResponse {\n                            response: Some(proto::lsp_response::Response::GetCodeLensResponse(\n                                GetCodeLens::response_to_proto(\n                                    actions,\n                                    project,\n                                    sender_id,\n                                    &buffer_version,\n                                    cx,\n                                ),\n                            )),\n                        })\n                        .collect(),\n                })\n            }\n            Some(proto::multi_lsp_query::Request::GetDocumentDiagnostics(message)) => {\n                buffer\n                    .update(&mut cx, |buffer, _| {\n                        buffer.wait_for_version(deserialize_version(&message.version))\n                    })?\n                    .await?;\n                let pull_diagnostics = lsp_store.update(&mut cx, |lsp_store, cx| {\n                    let server_ids = buffer.update(cx, |buffer, cx| {\n                        lsp_store\n                            .language_servers_for_local_buffer(buffer, cx)\n                            .map(|(_, server)| server.server_id())\n                            .collect::<Vec<_>>()\n                    });\n\n                    server_ids\n                        .into_iter()\n                        .map(|server_id| {\n                            let result_id = lsp_store.result_id(server_id, buffer_id, cx);\n                            lsp_store.request_lsp(\n                                buffer.clone(),\n                                LanguageServerToQuery::Other(server_id),\n                                GetDocumentDiagnostics {\n                                    previous_result_id: result_id,\n                                },\n                                cx,\n                            )\n                        })\n                        .collect::<Vec<_>>()\n                })?;\n\n                let all_diagnostics_responses = join_all(pull_diagnostics).await;\n                let mut all_diagnostics = Vec::new();\n                for response in all_diagnostics_responses {\n                    let response = response?;\n                    all_diagnostics.push(response);\n                }\n\n                lsp_store.update(&mut cx, |project, cx| proto::MultiLspQueryResponse {\n                    responses: all_diagnostics\n                        .into_iter()\n                        .map(|lsp_diagnostic| proto::LspResponse {\n                            response: Some(\n                                proto::lsp_response::Response::GetDocumentDiagnosticsResponse(\n                                    GetDocumentDiagnostics::response_to_proto(\n                                        lsp_diagnostic,\n                                        project,\n                                        sender_id,\n                                        &buffer_version,\n                                        cx,\n                                    ),\n                                ),\n                            ),\n                        })\n                        .collect(),\n                })\n            }\n            None => anyhow::bail!(": "",
    "),\n        }\n    }\n\n    async fn handle_apply_code_action(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::ApplyCodeAction>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::ApplyCodeActionResponse> {\n        let sender_id = envelope.original_sender_id().unwrap_or_default();\n        let action =\n            Self::deserialize_code_action(envelope.payload.action.context(": "",
    ")?)?;\n        let apply_code_action = this.update(&mut cx, |this, cx| {\n            let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n            let buffer = this.buffer_store.read(cx).get_existing(buffer_id)?;\n            anyhow::Ok(this.apply_code_action(buffer, action, false, cx))\n        })??;\n\n        let project_transaction = apply_code_action.await?;\n        let project_transaction = this.update(&mut cx, |this, cx| {\n            this.buffer_store.update(cx, |buffer_store, cx| {\n                buffer_store.serialize_project_transaction_for_peer(\n                    project_transaction,\n                    sender_id,\n                    cx,\n                )\n            })\n        })?;\n        Ok(proto::ApplyCodeActionResponse {\n            transaction: Some(project_transaction),\n        })\n    }\n\n    async fn handle_register_buffer_with_language_servers(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::RegisterBufferWithLanguageServers>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n        let peer_id = envelope.original_sender_id.unwrap_or(envelope.sender_id);\n        this.update(&mut cx, |this, cx| {\n            if let Some((upstream_client, upstream_project_id)) = this.upstream_client() {\n                return upstream_client.send(proto::RegisterBufferWithLanguageServers {\n                    project_id: upstream_project_id,\n                    buffer_id: buffer_id.to_proto(),\n                });\n            }\n\n            let Some(buffer) = this.buffer_store().read(cx).get(buffer_id) else {\n                anyhow::bail!(": "",
    ");\n            };\n\n            let handle = this.register_buffer_with_language_servers(&buffer, false, cx);\n            this.buffer_store().update(cx, |buffer_store, _| {\n                buffer_store.register_shared_lsp_handle(peer_id, buffer_id, handle);\n            });\n\n            Ok(())\n        })??;\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_language_server_id_for_name(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::LanguageServerIdForName>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::LanguageServerIdForNameResponse> {\n        let name = &envelope.payload.name;\n        let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n        lsp_store\n            .update(&mut cx, |lsp_store, cx| {\n                let buffer = lsp_store.buffer_store.read(cx).get_existing(buffer_id)?;\n                let server_id = buffer.update(cx, |buffer, cx| {\n                    lsp_store\n                        .language_servers_for_local_buffer(buffer, cx)\n                        .find_map(|(adapter, server)| {\n                            if adapter.name.0.as_ref() == name {\n                                Some(server.server_id())\n                            } else {\n                                None\n                            }\n                        })\n                });\n                Ok(server_id)\n            })?\n            .map(|server_id| proto::LanguageServerIdForNameResponse {\n                server_id: server_id.map(|id| id.to_proto()),\n            })\n    }\n\n    async fn handle_rename_project_entry(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::RenameProjectEntry>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::ProjectEntryResponse> {\n        let entry_id = ProjectEntryId::from_proto(envelope.payload.entry_id);\n        let (worktree_id, worktree, old_path, is_dir) = this\n            .update(&mut cx, |this, cx| {\n                this.worktree_store\n                    .read(cx)\n                    .worktree_and_entry_for_id(entry_id, cx)\n                    .map(|(worktree, entry)| {\n                        (\n                            worktree.read(cx).id(),\n                            worktree,\n                            entry.path.clone(),\n                            entry.is_dir(),\n                        )\n                    })\n            })?\n            .context(": "",
    ")?;\n        let (old_abs_path, new_abs_path) = {\n            let root_path = worktree.read_with(&mut cx, |this, _| this.abs_path())?;\n            let new_path = PathBuf::from_proto(envelope.payload.new_path.clone());\n            (root_path.join(&old_path), root_path.join(&new_path))\n        };\n\n        Self::will_rename_entry(\n            this.downgrade(),\n            worktree_id,\n            &old_abs_path,\n            &new_abs_path,\n            is_dir,\n            cx.clone(),\n        )\n        .await;\n        let response = Worktree::handle_rename_entry(worktree, envelope.payload, cx.clone()).await;\n        this.read_with(&mut cx, |this, _| {\n            this.did_rename_entry(worktree_id, &old_abs_path, &new_abs_path, is_dir);\n        })\n        .ok();\n        response\n    }\n\n    async fn handle_update_diagnostic_summary(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::UpdateDiagnosticSummary>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        this.update(&mut cx, |this, cx| {\n            let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n            if let Some(message) = envelope.payload.summary {\n                let project_path = ProjectPath {\n                    worktree_id,\n                    path: Arc::<Path>::from_proto(message.path),\n                };\n                let path = project_path.path.clone();\n                let server_id = LanguageServerId(message.language_server_id as usize);\n                let summary = DiagnosticSummary {\n                    error_count: message.error_count as usize,\n                    warning_count: message.warning_count as usize,\n                };\n\n                if summary.is_empty() {\n                    if let Some(worktree_summaries) =\n                        this.diagnostic_summaries.get_mut(&worktree_id)\n                    {\n                        if let Some(summaries) = worktree_summaries.get_mut(&path) {\n                            summaries.remove(&server_id);\n                            if summaries.is_empty() {\n                                worktree_summaries.remove(&path);\n                            }\n                        }\n                    }\n                } else {\n                    this.diagnostic_summaries\n                        .entry(worktree_id)\n                        .or_default()\n                        .entry(path)\n                        .or_default()\n                        .insert(server_id, summary);\n                }\n                if let Some((downstream_client, project_id)) = &this.downstream_client {\n                    downstream_client\n                        .send(proto::UpdateDiagnosticSummary {\n                            project_id: *project_id,\n                            worktree_id: worktree_id.to_proto(),\n                            summary: Some(proto::DiagnosticSummary {\n                                path: project_path.path.as_ref().to_proto(),\n                                language_server_id: server_id.0 as u64,\n                                error_count: summary.error_count as u32,\n                                warning_count: summary.warning_count as u32,\n                            }),\n                        })\n                        .log_err();\n                }\n                cx.emit(LspStoreEvent::DiagnosticsUpdated {\n                    language_server_id: LanguageServerId(message.language_server_id as usize),\n                    path: project_path,\n                });\n            }\n            Ok(())\n        })?\n    }\n\n    async fn handle_start_language_server(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::StartLanguageServer>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        let server = envelope.payload.server.context(": "",
    ")?;\n\n        this.update(&mut cx, |this, cx| {\n            let server_id = LanguageServerId(server.id as usize);\n            this.language_server_statuses.insert(\n                server_id,\n                LanguageServerStatus {\n                    name: server.name.clone(),\n                    pending_work: Default::default(),\n                    has_pending_diagnostic_updates: false,\n                    progress_tokens: Default::default(),\n                },\n            );\n            cx.emit(LspStoreEvent::LanguageServerAdded(\n                server_id,\n                LanguageServerName(server.name.into()),\n                server.worktree_id.map(WorktreeId::from_proto),\n            ));\n            cx.notify();\n        })?;\n        Ok(())\n    }\n\n    async fn handle_update_language_server(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::UpdateLanguageServer>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        this.update(&mut cx, |this, cx| {\n            let language_server_id = LanguageServerId(envelope.payload.language_server_id as usize);\n\n            match envelope.payload.variant.context(": "",
    ")? {\n                proto::update_language_server::Variant::WorkStart(payload) => {\n                    this.on_lsp_work_start(\n                        language_server_id,\n                        payload.token,\n                        LanguageServerProgress {\n                            title: payload.title,\n                            is_disk_based_diagnostics_progress: false,\n                            is_cancellable: payload.is_cancellable.unwrap_or(false),\n                            message: payload.message,\n                            percentage: payload.percentage.map(|p| p as usize),\n                            last_update_at: cx.background_executor().now(),\n                        },\n                        cx,\n                    );\n                }\n\n                proto::update_language_server::Variant::WorkProgress(payload) => {\n                    this.on_lsp_work_progress(\n                        language_server_id,\n                        payload.token,\n                        LanguageServerProgress {\n                            title: None,\n                            is_disk_based_diagnostics_progress: false,\n                            is_cancellable: payload.is_cancellable.unwrap_or(false),\n                            message: payload.message,\n                            percentage: payload.percentage.map(|p| p as usize),\n                            last_update_at: cx.background_executor().now(),\n                        },\n                        cx,\n                    );\n                }\n\n                proto::update_language_server::Variant::WorkEnd(payload) => {\n                    this.on_lsp_work_end(language_server_id, payload.token, cx);\n                }\n\n                proto::update_language_server::Variant::DiskBasedDiagnosticsUpdating(_) => {\n                    this.disk_based_diagnostics_started(language_server_id, cx);\n                }\n\n                proto::update_language_server::Variant::DiskBasedDiagnosticsUpdated(_) => {\n                    this.disk_based_diagnostics_finished(language_server_id, cx)\n                }\n            }\n\n            Ok(())\n        })?\n    }\n\n    async fn handle_language_server_log(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::LanguageServerLog>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        let language_server_id = LanguageServerId(envelope.payload.language_server_id as usize);\n        let log_type = envelope\n            .payload\n            .log_type\n            .map(LanguageServerLogType::from_proto)\n            .context(": "",
    ")?;\n\n        let message = envelope.payload.message;\n\n        this.update(&mut cx, |_, cx| {\n            cx.emit(LspStoreEvent::LanguageServerLog(\n                language_server_id,\n                log_type,\n                message,\n            ));\n        })\n    }\n\n    async fn handle_lsp_ext_cancel_flycheck(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::LspExtCancelFlycheck>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let server_id = LanguageServerId(envelope.payload.language_server_id as usize);\n        lsp_store.read_with(&mut cx, |lsp_store, _| {\n            if let Some(server) = lsp_store.language_server_for_id(server_id) {\n                server\n                    .notify::<lsp_store::lsp_ext_command::LspExtCancelFlycheck>(&())\n                    .context(": "",
    ")\n            } else {\n                anyhow::Ok(())\n            }\n        })??;\n\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_lsp_ext_run_flycheck(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::LspExtRunFlycheck>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let server_id = LanguageServerId(envelope.payload.language_server_id as usize);\n        lsp_store.update(&mut cx, |lsp_store, cx| {\n            if let Some(server) = lsp_store.language_server_for_id(server_id) {\n                let text_document = if envelope.payload.current_file_only {\n                    let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n                    lsp_store\n                        .buffer_store()\n                        .read(cx)\n                        .get(buffer_id)\n                        .and_then(|buffer| Some(buffer.read(cx).file()?.as_local()?.abs_path(cx)))\n                        .map(|path| make_text_document_identifier(&path))\n                        .transpose()?\n                } else {\n                    None\n                };\n                server\n                    .notify::<lsp_store::lsp_ext_command::LspExtRunFlycheck>(\n                        &lsp_store::lsp_ext_command::RunFlycheckParams { text_document },\n                    )\n                    .context(": "",
    ")\n            } else {\n                anyhow::Ok(())\n            }\n        })??;\n\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_lsp_ext_clear_flycheck(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::LspExtClearFlycheck>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let server_id = LanguageServerId(envelope.payload.language_server_id as usize);\n        lsp_store.read_with(&mut cx, |lsp_store, _| {\n            if let Some(server) = lsp_store.language_server_for_id(server_id) {\n                server\n                    .notify::<lsp_store::lsp_ext_command::LspExtClearFlycheck>(&())\n                    .context(": "",
    ")\n            } else {\n                anyhow::Ok(())\n            }\n        })??;\n\n        Ok(proto::Ack {})\n    }\n\n    pub fn disk_based_diagnostics_started(\n        &mut self,\n        language_server_id: LanguageServerId,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(language_server_status) =\n            self.language_server_statuses.get_mut(&language_server_id)\n        {\n            language_server_status.has_pending_diagnostic_updates = true;\n        }\n\n        cx.emit(LspStoreEvent::DiskBasedDiagnosticsStarted { language_server_id });\n        cx.emit(LspStoreEvent::LanguageServerUpdate {\n            language_server_id,\n            message: proto::update_language_server::Variant::DiskBasedDiagnosticsUpdating(\n                Default::default(),\n            ),\n        })\n    }\n\n    pub fn disk_based_diagnostics_finished(\n        &mut self,\n        language_server_id: LanguageServerId,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(language_server_status) =\n            self.language_server_statuses.get_mut(&language_server_id)\n        {\n            language_server_status.has_pending_diagnostic_updates = false;\n        }\n\n        cx.emit(LspStoreEvent::DiskBasedDiagnosticsFinished { language_server_id });\n        cx.emit(LspStoreEvent::LanguageServerUpdate {\n            language_server_id,\n            message: proto::update_language_server::Variant::DiskBasedDiagnosticsUpdated(\n                Default::default(),\n            ),\n        })\n    }\n\n    // After saving a buffer using a language server that doesn't provide a disk-based progress token,\n    // kick off a timer that will reset every time the buffer is saved. If the timer eventually fires,\n    // simulate disk-based diagnostics being finished so that other pieces of UI (e.g., project\n    // diagnostics view, diagnostic status bar) can update. We don't emit an event right away because\n    // the language server might take some time to publish diagnostics.\n    fn simulate_disk_based_diagnostics_events_if_needed(\n        &mut self,\n        language_server_id: LanguageServerId,\n        cx: &mut Context<Self>,\n    ) {\n        const DISK_BASED_DIAGNOSTICS_DEBOUNCE: Duration = Duration::from_secs(1);\n\n        let Some(LanguageServerState::Running {\n            simulate_disk_based_diagnostics_completion,\n            adapter,\n            ..\n        }) = self\n            .as_local_mut()\n            .and_then(|local_store| local_store.language_servers.get_mut(&language_server_id))\n        else {\n            return;\n        };\n\n        if adapter.disk_based_diagnostics_progress_token.is_some() {\n            return;\n        }\n\n        let prev_task =\n            simulate_disk_based_diagnostics_completion.replace(cx.spawn(async move |this, cx| {\n                cx.background_executor()\n                    .timer(DISK_BASED_DIAGNOSTICS_DEBOUNCE)\n                    .await;\n\n                this.update(cx, |this, cx| {\n                    this.disk_based_diagnostics_finished(language_server_id, cx);\n\n                    if let Some(LanguageServerState::Running {\n                        simulate_disk_based_diagnostics_completion,\n                        ..\n                    }) = this.as_local_mut().and_then(|local_store| {\n                        local_store.language_servers.get_mut(&language_server_id)\n                    }) {\n                        *simulate_disk_based_diagnostics_completion = None;\n                    }\n                })\n                .ok();\n            }));\n\n        if prev_task.is_none() {\n            self.disk_based_diagnostics_started(language_server_id, cx);\n        }\n    }\n\n    pub fn language_server_statuses(\n        &self,\n    ) -> impl DoubleEndedIterator<Item = (LanguageServerId, &LanguageServerStatus)> {\n        self.language_server_statuses\n            .iter()\n            .map(|(key, value)| (*key, value))\n    }\n\n    pub(super) fn did_rename_entry(\n        &self,\n        worktree_id: WorktreeId,\n        old_path: &Path,\n        new_path: &Path,\n        is_dir: bool,\n    ) {\n        maybe!({\n            let local_store = self.as_local()?;\n\n            let old_uri = lsp::Url::from_file_path(old_path).ok().map(String::from)?;\n            let new_uri = lsp::Url::from_file_path(new_path).ok().map(String::from)?;\n\n            for language_server in local_store.language_servers_for_worktree(worktree_id) {\n                let Some(filter) = local_store\n                    .language_server_paths_watched_for_rename\n                    .get(&language_server.server_id())\n                else {\n                    continue;\n                };\n\n                if filter.should_send_did_rename(&old_uri, is_dir) {\n                    language_server\n                        .notify::<DidRenameFiles>(&RenameFilesParams {\n                            files: vec![FileRename {\n                                old_uri: old_uri.clone(),\n                                new_uri: new_uri.clone(),\n                            }],\n                        })\n                        .ok();\n                }\n            }\n            Some(())\n        });\n    }\n\n    pub(super) fn will_rename_entry(\n        this: WeakEntity<Self>,\n        worktree_id: WorktreeId,\n        old_path: &Path,\n        new_path: &Path,\n        is_dir: bool,\n        cx: AsyncApp,\n    ) -> Task<()> {\n        let old_uri = lsp::Url::from_file_path(old_path).ok().map(String::from);\n        let new_uri = lsp::Url::from_file_path(new_path).ok().map(String::from);\n        cx.spawn(async move |cx| {\n            let mut tasks = vec![];\n            this.update(cx, |this, cx| {\n                let local_store = this.as_local()?;\n                let old_uri = old_uri?;\n                let new_uri = new_uri?;\n                for language_server in local_store.language_servers_for_worktree(worktree_id) {\n                    let Some(filter) = local_store\n                        .language_server_paths_watched_for_rename\n                        .get(&language_server.server_id())\n                    else {\n                        continue;\n                    };\n                    let Some(adapter) =\n                        this.language_server_adapter_for_id(language_server.server_id())\n                    else {\n                        continue;\n                    };\n                    if filter.should_send_will_rename(&old_uri, is_dir) {\n                        let apply_edit = cx.spawn({\n                            let old_uri = old_uri.clone();\n                            let new_uri = new_uri.clone();\n                            let language_server = language_server.clone();\n                            async move |this, cx| {\n                                let edit = language_server\n                                    .request::<WillRenameFiles>(RenameFilesParams {\n                                        files: vec![FileRename { old_uri, new_uri }],\n                                    })\n                                    .await\n                                    .into_response()\n                                    .context(": "",
    ")\n                                    .log_err()\n                                    .flatten()?;\n\n                                LocalLspStore::deserialize_workspace_edit(\n                                    this.upgrade()?,\n                                    edit,\n                                    false,\n                                    adapter.clone(),\n                                    language_server.clone(),\n                                    cx,\n                                )\n                                .await\n                                .ok();\n                                Some(())\n                            }\n                        });\n                        tasks.push(apply_edit);\n                    }\n                }\n                Some(())\n            })\n            .ok()\n            .flatten();\n            for task in tasks {\n                // Await on tasks sequentially so that the order of application of edits is deterministic\n                // (at least with regards to the order of registration of language servers)\n                task.await;\n            }\n        })\n    }\n\n    fn lsp_notify_abs_paths_changed(\n        &mut self,\n        server_id: LanguageServerId,\n        changes: Vec<PathEvent>,\n    ) {\n        maybe!({\n            let server = self.language_server_for_id(server_id)?;\n            let changes = changes\n                .into_iter()\n                .filter_map(|event| {\n                    let typ = match event.kind? {\n                        PathEventKind::Created => lsp::FileChangeType::CREATED,\n                        PathEventKind::Removed => lsp::FileChangeType::DELETED,\n                        PathEventKind::Changed => lsp::FileChangeType::CHANGED,\n                    };\n                    Some(lsp::FileEvent {\n                        uri: file_path_to_lsp_url(&event.path).log_err()?,\n                        typ,\n                    })\n                })\n                .collect::<Vec<_>>();\n            if !changes.is_empty() {\n                server\n                    .notify::<lsp::notification::DidChangeWatchedFiles>(\n                        &lsp::DidChangeWatchedFilesParams { changes },\n                    )\n                    .ok();\n            }\n            Some(())\n        });\n    }\n\n    pub fn language_server_for_id(&self, id: LanguageServerId) -> Option<Arc<LanguageServer>> {\n        let local_lsp_store = self.as_local()?;\n        if let Some(LanguageServerState::Running { server, .. }) =\n            local_lsp_store.language_servers.get(&id)\n        {\n            Some(server.clone())\n        } else if let Some((_, server)) = local_lsp_store.supplementary_language_servers.get(&id) {\n            Some(Arc::clone(server))\n        } else {\n            None\n        }\n    }\n\n    fn on_lsp_progress(\n        &mut self,\n        progress: lsp::ProgressParams,\n        language_server_id: LanguageServerId,\n        disk_based_diagnostics_progress_token: Option<String>,\n        cx: &mut Context<Self>,\n    ) {\n        let token = match progress.token {\n            lsp::NumberOrString::String(token) => token,\n            lsp::NumberOrString::Number(token) => {\n                log::info!(": "",
    ", token);\n                return;\n            }\n        };\n\n        let lsp::ProgressParamsValue::WorkDone(progress) = progress.value;\n        let language_server_status =\n            if let Some(status) = self.language_server_statuses.get_mut(&language_server_id) {\n                status\n            } else {\n                return;\n            };\n\n        if !language_server_status.progress_tokens.contains(&token) {\n            return;\n        }\n\n        let is_disk_based_diagnostics_progress = disk_based_diagnostics_progress_token\n            .as_ref()\n            .map_or(false, |disk_based_token| {\n                token.starts_with(disk_based_token)\n            });\n\n        match progress {\n            lsp::WorkDoneProgress::Begin(report) => {\n                if is_disk_based_diagnostics_progress {\n                    self.disk_based_diagnostics_started(language_server_id, cx);\n                }\n                self.on_lsp_work_start(\n                    language_server_id,\n                    token.clone(),\n                    LanguageServerProgress {\n                        title: Some(report.title),\n                        is_disk_based_diagnostics_progress,\n                        is_cancellable: report.cancellable.unwrap_or(false),\n                        message: report.message.clone(),\n                        percentage: report.percentage.map(|p| p as usize),\n                        last_update_at: cx.background_executor().now(),\n                    },\n                    cx,\n                );\n            }\n            lsp::WorkDoneProgress::Report(report) => self.on_lsp_work_progress(\n                language_server_id,\n                token,\n                LanguageServerProgress {\n                    title: None,\n                    is_disk_based_diagnostics_progress,\n                    is_cancellable: report.cancellable.unwrap_or(false),\n                    message: report.message,\n                    percentage: report.percentage.map(|p| p as usize),\n                    last_update_at: cx.background_executor().now(),\n                },\n                cx,\n            ),\n            lsp::WorkDoneProgress::End(_) => {\n                language_server_status.progress_tokens.remove(&token);\n                self.on_lsp_work_end(language_server_id, token.clone(), cx);\n                if is_disk_based_diagnostics_progress {\n                    self.disk_based_diagnostics_finished(language_server_id, cx);\n                }\n            }\n        }\n    }\n\n    fn on_lsp_work_start(\n        &mut self,\n        language_server_id: LanguageServerId,\n        token: String,\n        progress: LanguageServerProgress,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(status) = self.language_server_statuses.get_mut(&language_server_id) {\n            status.pending_work.insert(token.clone(), progress.clone());\n            cx.notify();\n        }\n        cx.emit(LspStoreEvent::LanguageServerUpdate {\n            language_server_id,\n            message: proto::update_language_server::Variant::WorkStart(proto::LspWorkStart {\n                token,\n                title: progress.title,\n                message: progress.message,\n                percentage: progress.percentage.map(|p| p as u32),\n                is_cancellable: Some(progress.is_cancellable),\n            }),\n        })\n    }\n\n    fn on_lsp_work_progress(\n        &mut self,\n        language_server_id: LanguageServerId,\n        token: String,\n        progress: LanguageServerProgress,\n        cx: &mut Context<Self>,\n    ) {\n        let mut did_update = false;\n        if let Some(status) = self.language_server_statuses.get_mut(&language_server_id) {\n            match status.pending_work.entry(token.clone()) {\n                btree_map::Entry::Vacant(entry) => {\n                    entry.insert(progress.clone());\n                    did_update = true;\n                }\n                btree_map::Entry::Occupied(mut entry) => {\n                    let entry = entry.get_mut();\n                    if (progress.last_update_at - entry.last_update_at)\n                        >= SERVER_PROGRESS_THROTTLE_TIMEOUT\n                    {\n                        entry.last_update_at = progress.last_update_at;\n                        if progress.message.is_some() {\n                            entry.message = progress.message.clone();\n                        }\n                        if progress.percentage.is_some() {\n                            entry.percentage = progress.percentage;\n                        }\n                        if progress.is_cancellable != entry.is_cancellable {\n                            entry.is_cancellable = progress.is_cancellable;\n                        }\n                        did_update = true;\n                    }\n                }\n            }\n        }\n\n        if did_update {\n            cx.emit(LspStoreEvent::LanguageServerUpdate {\n                language_server_id,\n                message: proto::update_language_server::Variant::WorkProgress(\n                    proto::LspWorkProgress {\n                        token,\n                        message: progress.message,\n                        percentage: progress.percentage.map(|p| p as u32),\n                        is_cancellable: Some(progress.is_cancellable),\n                    },\n                ),\n            })\n        }\n    }\n\n    fn on_lsp_work_end(\n        &mut self,\n        language_server_id: LanguageServerId,\n        token: String,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(status) = self.language_server_statuses.get_mut(&language_server_id) {\n            if let Some(work) = status.pending_work.remove(&token) {\n                if !work.is_disk_based_diagnostics_progress {\n                    cx.emit(LspStoreEvent::RefreshInlayHints);\n                }\n            }\n            cx.notify();\n        }\n\n        cx.emit(LspStoreEvent::LanguageServerUpdate {\n            language_server_id,\n            message: proto::update_language_server::Variant::WorkEnd(proto::LspWorkEnd { token }),\n        })\n    }\n\n    pub async fn handle_resolve_completion_documentation(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::ResolveCompletionDocumentation>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::ResolveCompletionDocumentationResponse> {\n        let lsp_completion = serde_json::from_slice(&envelope.payload.lsp_completion)?;\n\n        let completion = this\n            .read_with(&cx, |this, cx| {\n                let id = LanguageServerId(envelope.payload.language_server_id as usize);\n                let server = this\n                    .language_server_for_id(id)\n                    .with_context(|| format!(": "",
    "))?;\n\n                anyhow::Ok(cx.background_spawn(async move {\n                    let can_resolve = server\n                        .capabilities()\n                        .completion_provider\n                        .as_ref()\n                        .and_then(|options| options.resolve_provider)\n                        .unwrap_or(false);\n                    if can_resolve {\n                        server\n                            .request::<lsp::request::ResolveCompletionItem>(lsp_completion)\n                            .await\n                            .into_response()\n                            .context(": "",
    ")\n                    } else {\n                        anyhow::Ok(lsp_completion)\n                    }\n                }))\n            })??\n            .await?;\n\n        let mut documentation_is_markdown = false;\n        let lsp_completion = serde_json::to_string(&completion)?.into_bytes();\n        let documentation = match completion.documentation {\n            Some(lsp::Documentation::String(text)) => text,\n\n            Some(lsp::Documentation::MarkupContent(lsp::MarkupContent { kind, value })) => {\n                documentation_is_markdown = kind == lsp::MarkupKind::Markdown;\n                value\n            }\n\n            _ => String::new(),\n        };\n\n        // If we have a new buffer_id, that means we're talking to a new client\n        // and want to check for new text_edits in the completion too.\n        let mut old_replace_start = None;\n        let mut old_replace_end = None;\n        let mut old_insert_start = None;\n        let mut old_insert_end = None;\n        let mut new_text = String::default();\n        if let Ok(buffer_id) = BufferId::new(envelope.payload.buffer_id) {\n            let buffer_snapshot = this.update(&mut cx, |this, cx| {\n                let buffer = this.buffer_store.read(cx).get_existing(buffer_id)?;\n                anyhow::Ok(buffer.read(cx).snapshot())\n            })??;\n\n            if let Some(text_edit) = completion.text_edit.as_ref() {\n                let edit = parse_completion_text_edit(text_edit, &buffer_snapshot);\n\n                if let Some(mut edit) = edit {\n                    LineEnding::normalize(&mut edit.new_text);\n\n                    new_text = edit.new_text;\n                    old_replace_start = Some(serialize_anchor(&edit.replace_range.start));\n                    old_replace_end = Some(serialize_anchor(&edit.replace_range.end));\n                    if let Some(insert_range) = edit.insert_range {\n                        old_insert_start = Some(serialize_anchor(&insert_range.start));\n                        old_insert_end = Some(serialize_anchor(&insert_range.end));\n                    }\n                }\n            }\n        }\n\n        Ok(proto::ResolveCompletionDocumentationResponse {\n            documentation,\n            documentation_is_markdown,\n            old_replace_start,\n            old_replace_end,\n            new_text,\n            lsp_completion,\n            old_insert_start,\n            old_insert_end,\n        })\n    }\n\n    async fn handle_on_type_formatting(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::OnTypeFormatting>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::OnTypeFormattingResponse> {\n        let on_type_formatting = this.update(&mut cx, |this, cx| {\n            let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n            let buffer = this.buffer_store.read(cx).get_existing(buffer_id)?;\n            let position = envelope\n                .payload\n                .position\n                .and_then(deserialize_anchor)\n                .context(": "",
    ")?;\n            anyhow::Ok(this.apply_on_type_formatting(\n                buffer,\n                position,\n                envelope.payload.trigger.clone(),\n                cx,\n            ))\n        })??;\n\n        let transaction = on_type_formatting\n            .await?\n            .as_ref()\n            .map(language::proto::serialize_transaction);\n        Ok(proto::OnTypeFormattingResponse { transaction })\n    }\n\n    async fn handle_refresh_inlay_hints(\n        this: Entity<Self>,\n        _: TypedEnvelope<proto::RefreshInlayHints>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        this.update(&mut cx, |_, cx| {\n            cx.emit(LspStoreEvent::RefreshInlayHints);\n        })?;\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_pull_workspace_diagnostics(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::PullWorkspaceDiagnostics>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let server_id = LanguageServerId::from_proto(envelope.payload.server_id);\n        lsp_store.update(&mut cx, |lsp_store, _| {\n            lsp_store.pull_workspace_diagnostics(server_id);\n        })?;\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_inlay_hints(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::InlayHints>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::InlayHintsResponse> {\n        let sender_id = envelope.original_sender_id().unwrap_or_default();\n        let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n        let buffer = this.update(&mut cx, |this, cx| {\n            this.buffer_store.read(cx).get_existing(buffer_id)\n        })??;\n        buffer\n            .update(&mut cx, |buffer, _| {\n                buffer.wait_for_version(deserialize_version(&envelope.payload.version))\n            })?\n            .await\n            .with_context(|| format!(": "",
    ", buffer.entity_id()))?;\n\n        let start = envelope\n            .payload\n            .start\n            .and_then(deserialize_anchor)\n            .context(": "",
    ")?;\n        let end = envelope\n            .payload\n            .end\n            .and_then(deserialize_anchor)\n            .context(": "",
    ")?;\n        let buffer_hints = this\n            .update(&mut cx, |lsp_store, cx| {\n                lsp_store.inlay_hints(buffer.clone(), start..end, cx)\n            })?\n            .await\n            .context(": "",
    ")?;\n\n        this.update(&mut cx, |project, cx| {\n            InlayHints::response_to_proto(\n                buffer_hints,\n                project,\n                sender_id,\n                &buffer.read(cx).version(),\n                cx,\n            )\n        })\n    }\n\n    async fn handle_resolve_inlay_hint(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::ResolveInlayHint>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::ResolveInlayHintResponse> {\n        let proto_hint = envelope\n            .payload\n            .hint\n            .expect(": "",
    ");\n        let hint = InlayHints::proto_to_project_hint(proto_hint)\n            .context(": "",
    ")?;\n        let buffer = this.update(&mut cx, |this, cx| {\n            let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n            this.buffer_store.read(cx).get_existing(buffer_id)\n        })??;\n        let response_hint = this\n            .update(&mut cx, |this, cx| {\n                this.resolve_inlay_hint(\n                    hint,\n                    buffer,\n                    LanguageServerId(envelope.payload.language_server_id as usize),\n                    cx,\n                )\n            })?\n            .await\n            .context(": "",
    ")?;\n        Ok(proto::ResolveInlayHintResponse {\n            hint: Some(InlayHints::project_to_proto_hint(response_hint)),\n        })\n    }\n\n    async fn handle_refresh_code_lens(\n        this: Entity<Self>,\n        _: TypedEnvelope<proto::RefreshCodeLens>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        this.update(&mut cx, |_, cx| {\n            cx.emit(LspStoreEvent::RefreshCodeLens);\n        })?;\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_open_buffer_for_symbol(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::OpenBufferForSymbol>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::OpenBufferForSymbolResponse> {\n        let peer_id = envelope.original_sender_id().unwrap_or_default();\n        let symbol = envelope.payload.symbol.context(": "",
    ")?;\n        let symbol = Self::deserialize_symbol(symbol)?;\n        let symbol = this.read_with(&mut cx, |this, _| {\n            let signature = this.symbol_signature(&symbol.path);\n            anyhow::ensure!(signature == symbol.signature, ": "",
    ");\n            Ok(symbol)\n        })??;\n        let buffer = this\n            .update(&mut cx, |this, cx| {\n                this.open_buffer_for_symbol(\n                    &Symbol {\n                        language_server_name: symbol.language_server_name,\n                        source_worktree_id: symbol.source_worktree_id,\n                        source_language_server_id: symbol.source_language_server_id,\n                        path: symbol.path,\n                        name: symbol.name,\n                        kind: symbol.kind,\n                        range: symbol.range,\n                        signature: symbol.signature,\n                        label: CodeLabel {\n                            text: Default::default(),\n                            runs: Default::default(),\n                            filter_range: Default::default(),\n                        },\n                    },\n                    cx,\n                )\n            })?\n            .await?;\n\n        this.update(&mut cx, |this, cx| {\n            let is_private = buffer\n                .read(cx)\n                .file()\n                .map(|f| f.is_private())\n                .unwrap_or_default();\n            if is_private {\n                Err(anyhow!(rpc::ErrorCode::UnsharedItem))\n            } else {\n                this.buffer_store\n                    .update(cx, |buffer_store, cx| {\n                        buffer_store.create_buffer_for_peer(&buffer, peer_id, cx)\n                    })\n                    .detach_and_log_err(cx);\n                let buffer_id = buffer.read(cx).remote_id().to_proto();\n                Ok(proto::OpenBufferForSymbolResponse { buffer_id })\n            }\n        })?\n    }\n\n    fn symbol_signature(&self, project_path: &ProjectPath) -> [u8; 32] {\n        let mut hasher = Sha256::new();\n        hasher.update(project_path.worktree_id.to_proto().to_be_bytes());\n        hasher.update(project_path.path.to_string_lossy().as_bytes());\n        hasher.update(self.nonce.to_be_bytes());\n        hasher.finalize().as_slice().try_into().unwrap()\n    }\n\n    pub async fn handle_get_project_symbols(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::GetProjectSymbols>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::GetProjectSymbolsResponse> {\n        let symbols = this\n            .update(&mut cx, |this, cx| {\n                this.symbols(&envelope.payload.query, cx)\n            })?\n            .await?;\n\n        Ok(proto::GetProjectSymbolsResponse {\n            symbols: symbols.iter().map(Self::serialize_symbol).collect(),\n        })\n    }\n\n    pub async fn handle_restart_language_servers(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::RestartLanguageServers>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        this.update(&mut cx, |this, cx| {\n            let buffers = this.buffer_ids_to_buffers(envelope.payload.buffer_ids.into_iter(), cx);\n            this.restart_language_servers_for_buffers(buffers, cx);\n        })?;\n\n        Ok(proto::Ack {})\n    }\n\n    pub async fn handle_stop_language_servers(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::StopLanguageServers>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        this.update(&mut cx, |this, cx| {\n            let buffers = this.buffer_ids_to_buffers(envelope.payload.buffer_ids.into_iter(), cx);\n            this.stop_language_servers_for_buffers(buffers, cx);\n        })?;\n\n        Ok(proto::Ack {})\n    }\n\n    pub async fn handle_cancel_language_server_work(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::CancelLanguageServerWork>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        this.update(&mut cx, |this, cx| {\n            if let Some(work) = envelope.payload.work {\n                match work {\n                    proto::cancel_language_server_work::Work::Buffers(buffers) => {\n                        let buffers =\n                            this.buffer_ids_to_buffers(buffers.buffer_ids.into_iter(), cx);\n                        this.cancel_language_server_work_for_buffers(buffers, cx);\n                    }\n                    proto::cancel_language_server_work::Work::LanguageServerWork(work) => {\n                        let server_id = LanguageServerId::from_proto(work.language_server_id);\n                        this.cancel_language_server_work(server_id, work.token, cx);\n                    }\n                }\n            }\n        })?;\n\n        Ok(proto::Ack {})\n    }\n\n    fn buffer_ids_to_buffers(\n        &mut self,\n        buffer_ids: impl Iterator<Item = u64>,\n        cx: &mut Context<Self>,\n    ) -> Vec<Entity<Buffer>> {\n        buffer_ids\n            .into_iter()\n            .flat_map(|buffer_id| {\n                self.buffer_store\n                    .read(cx)\n                    .get(BufferId::new(buffer_id).log_err()?)\n            })\n            .collect::<Vec<_>>()\n    }\n\n    async fn handle_apply_additional_edits_for_completion(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::ApplyCompletionAdditionalEdits>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::ApplyCompletionAdditionalEditsResponse> {\n        let (buffer, completion) = this.update(&mut cx, |this, cx| {\n            let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n            let buffer = this.buffer_store.read(cx).get_existing(buffer_id)?;\n            let completion = Self::deserialize_completion(\n                envelope.payload.completion.context(": "",
    ")?,\n            )?;\n            anyhow::Ok((buffer, completion))\n        })??;\n\n        let apply_additional_edits = this.update(&mut cx, |this, cx| {\n            this.apply_additional_edits_for_completion(\n                buffer,\n                Rc::new(RefCell::new(Box::new([Completion {\n                    replace_range: completion.replace_range,\n                    new_text: completion.new_text,\n                    source: completion.source,\n                    documentation: None,\n                    label: CodeLabel {\n                        text: Default::default(),\n                        runs: Default::default(),\n                        filter_range: Default::default(),\n                    },\n                    insert_text_mode: None,\n                    icon_path: None,\n                    confirm: None,\n                }]))),\n                0,\n                false,\n                cx,\n            )\n        })?;\n\n        Ok(proto::ApplyCompletionAdditionalEditsResponse {\n            transaction: apply_additional_edits\n                .await?\n                .as_ref()\n                .map(language::proto::serialize_transaction),\n        })\n    }\n\n    pub fn last_formatting_failure(&self) -> Option<&str> {\n        self.last_formatting_failure.as_deref()\n    }\n\n    pub fn reset_last_formatting_failure(&mut self) {\n        self.last_formatting_failure = None;\n    }\n\n    pub fn environment_for_buffer(\n        &self,\n        buffer: &Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Shared<Task<Option<HashMap<String, String>>>> {\n        if let Some(environment) = &self.as_local().map(|local| local.environment.clone()) {\n            environment.update(cx, |env, cx| {\n                env.get_buffer_environment(&buffer, &self.worktree_store, cx)\n            })\n        } else {\n            Task::ready(None).shared()\n        }\n    }\n\n    pub fn format(\n        &mut self,\n        buffers: HashSet<Entity<Buffer>>,\n        target: LspFormatTarget,\n        push_to_history: bool,\n        trigger: FormatTrigger,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<ProjectTransaction>> {\n        let logger = zlog::scoped!(": "",
    ");\n        if let Some(_) = self.as_local() {\n            zlog::trace!(logger => ": "",
    ");\n            let logger = zlog::scoped!(logger => ": "",
    ");\n            let buffers = buffers\n                .into_iter()\n                .map(|buffer_handle| {\n                    let buffer = buffer_handle.read(cx);\n                    let buffer_abs_path = File::from_dyn(buffer.file())\n                        .and_then(|file| file.as_local().map(|f| f.abs_path(cx)));\n\n                    (buffer_handle, buffer_abs_path, buffer.remote_id())\n                })\n                .collect::<Vec<_>>();\n\n            cx.spawn(async move |lsp_store, cx| {\n                let mut formattable_buffers = Vec::with_capacity(buffers.len());\n\n                for (handle, abs_path, id) in buffers {\n                    let env = lsp_store\n                        .update(cx, |lsp_store, cx| {\n                            lsp_store.environment_for_buffer(&handle, cx)\n                        })?\n                        .await;\n\n                    let ranges = match &target {\n                        LspFormatTarget::Buffers => None,\n                        LspFormatTarget::Ranges(ranges) => {\n                            Some(ranges.get(&id).context(": "",
    ")?.clone())\n                        }\n                    };\n\n                    formattable_buffers.push(FormattableBuffer {\n                        handle,\n                        abs_path,\n                        env,\n                        ranges,\n                    });\n                }\n                zlog::trace!(logger => ": "",
    ", formattable_buffers.len());\n\n                let format_timer = zlog::time!(logger => ": "",
    ");\n                let result = LocalLspStore::format_locally(\n                    lsp_store.clone(),\n                    formattable_buffers,\n                    push_to_history,\n                    trigger,\n                    logger,\n                    cx,\n                )\n                .await;\n                format_timer.end();\n\n                zlog::trace!(logger => ": "",
    ", result.as_ref().map(|_| ": "",
    "));\n\n                lsp_store.update(cx, |lsp_store, _| {\n                    lsp_store.update_last_formatting_failure(&result);\n                })?;\n\n                result\n            })\n        } else if let Some((client, project_id)) = self.upstream_client() {\n            zlog::trace!(logger => ": "",
    ");\n            // Don't support formatting ranges via remote\n            match target {\n                LspFormatTarget::Buffers => {}\n                LspFormatTarget::Ranges(_) => {\n                    zlog::trace!(logger => ": "",
    ");\n                    return Task::ready(Ok(ProjectTransaction::default()));\n                }\n            }\n\n            let buffer_store = self.buffer_store();\n            cx.spawn(async move |lsp_store, cx| {\n                zlog::trace!(logger => ": "",
    ");\n                let request_timer = zlog::time!(logger => ": "",
    ");\n                let result = client\n                    .request(proto::FormatBuffers {\n                        project_id,\n                        trigger: trigger as i32,\n                        buffer_ids: buffers\n                            .iter()\n                            .map(|buffer| buffer.read_with(cx, |buffer, _| buffer.remote_id().into()))\n                            .collect::<Result<_>>()?,\n                    })\n                    .await\n                    .and_then(|result| result.transaction.context(": "",
    "));\n                request_timer.end();\n\n                zlog::trace!(logger => ": "",
    "));\n\n                lsp_store.update(cx, |lsp_store, _| {\n                    lsp_store.update_last_formatting_failure(&result);\n                })?;\n\n                let transaction_response = result?;\n                let _timer = zlog::time!(logger => ": "",
    ");\n                buffer_store\n                    .update(cx, |buffer_store, cx| {\n                        buffer_store.deserialize_project_transaction(\n                            transaction_response,\n                            push_to_history,\n                            cx,\n                        )\n                    })?\n                    .await\n            })\n        } else {\n            zlog::trace!(logger => ": "",
    ");\n            Task::ready(Ok(ProjectTransaction::default()))\n        }\n    }\n\n    async fn handle_format_buffers(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::FormatBuffers>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::FormatBuffersResponse> {\n        let sender_id = envelope.original_sender_id().unwrap_or_default();\n        let format = this.update(&mut cx, |this, cx| {\n            let mut buffers = HashSet::default();\n            for buffer_id in &envelope.payload.buffer_ids {\n                let buffer_id = BufferId::new(*buffer_id)?;\n                buffers.insert(this.buffer_store.read(cx).get_existing(buffer_id)?);\n            }\n            let trigger = FormatTrigger::from_proto(envelope.payload.trigger);\n            anyhow::Ok(this.format(buffers, LspFormatTarget::Buffers, false, trigger, cx))\n        })??;\n\n        let project_transaction = format.await?;\n        let project_transaction = this.update(&mut cx, |this, cx| {\n            this.buffer_store.update(cx, |buffer_store, cx| {\n                buffer_store.serialize_project_transaction_for_peer(\n                    project_transaction,\n                    sender_id,\n                    cx,\n                )\n            })\n        })?;\n        Ok(proto::FormatBuffersResponse {\n            transaction: Some(project_transaction),\n        })\n    }\n\n    async fn handle_apply_code_action_kind(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::ApplyCodeActionKind>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::ApplyCodeActionKindResponse> {\n        let sender_id = envelope.original_sender_id().unwrap_or_default();\n        let format = this.update(&mut cx, |this, cx| {\n            let mut buffers = HashSet::default();\n            for buffer_id in &envelope.payload.buffer_ids {\n                let buffer_id = BufferId::new(*buffer_id)?;\n                buffers.insert(this.buffer_store.read(cx).get_existing(buffer_id)?);\n            }\n            let kind = match envelope.payload.kind.as_str() {\n                ": "",
    " => CodeActionKind::EMPTY,\n                ": "",
    " => CodeActionKind::QUICKFIX,\n                ": "",
    " => CodeActionKind::REFACTOR,\n                ": "",
    " => CodeActionKind::REFACTOR_EXTRACT,\n                ": "",
    " => CodeActionKind::REFACTOR_INLINE,\n                ": "",
    " => CodeActionKind::REFACTOR_REWRITE,\n                ": "",
    " => CodeActionKind::SOURCE,\n                ": "",
    " => CodeActionKind::SOURCE_ORGANIZE_IMPORTS,\n                ": "",
    " => CodeActionKind::SOURCE_FIX_ALL,\n                _ => anyhow::bail!(\n                    ": "",
    ",\n                    envelope.payload.kind.as_str()\n                ),\n            };\n            anyhow::Ok(this.apply_code_action_kind(buffers, kind, false, cx))\n        })??;\n\n        let project_transaction = format.await?;\n        let project_transaction = this.update(&mut cx, |this, cx| {\n            this.buffer_store.update(cx, |buffer_store, cx| {\n                buffer_store.serialize_project_transaction_for_peer(\n                    project_transaction,\n                    sender_id,\n                    cx,\n                )\n            })\n        })?;\n        Ok(proto::ApplyCodeActionKindResponse {\n            transaction: Some(project_transaction),\n        })\n    }\n\n    async fn shutdown_language_server(\n        server_state: Option<LanguageServerState>,\n        name: LanguageServerName,\n        cx: &mut AsyncApp,\n    ) {\n        let server = match server_state {\n            Some(LanguageServerState::Starting { startup, .. }) => {\n                let mut timer = cx\n                    .background_executor()\n                    .timer(SERVER_LAUNCHING_BEFORE_SHUTDOWN_TIMEOUT)\n                    .fuse();\n\n                select! {\n                    server = startup.fuse() => server,\n                    _ = timer => {\n                        log::info!(\n                            ": "",
    ",\n                            name\n                        );\n                        None\n                    },\n                }\n            }\n\n            Some(LanguageServerState::Running { server, .. }) => Some(server),\n\n            None => None,\n        };\n\n        if let Some(server) = server {\n            if let Some(shutdown) = server.shutdown() {\n                shutdown.await;\n            }\n        }\n    }\n\n    // Returns a list of all of the worktrees which no longer have a language server and the root path\n    // for the stopped server\n    fn stop_local_language_server(\n        &mut self,\n        server_id: LanguageServerId,\n        name: LanguageServerName,\n        cx: &mut Context<Self>,\n    ) -> Task<Vec<WorktreeId>> {\n        let local = match &mut self.mode {\n            LspStoreMode::Local(local) => local,\n            _ => {\n                return Task::ready(Vec::new());\n            }\n        };\n\n        let mut orphaned_worktrees = vec![];\n        // Remove this server ID from all entries in the given worktree.\n        local.language_server_ids.retain(|(worktree, _), ids| {\n            if !ids.remove(&server_id) {\n                return true;\n            }\n\n            if ids.is_empty() {\n                orphaned_worktrees.push(*worktree);\n                false\n            } else {\n                true\n            }\n        });\n        let _ = self.language_server_statuses.remove(&server_id);\n        log::info!(": "",
    ");\n        self.buffer_store.update(cx, |buffer_store, cx| {\n            for buffer in buffer_store.buffers() {\n                buffer.update(cx, |buffer, cx| {\n                    buffer.update_diagnostics(server_id, DiagnosticSet::new([], buffer), cx);\n                    buffer.set_completion_triggers(server_id, Default::default(), cx);\n                });\n            }\n        });\n\n        for (worktree_id, summaries) in self.diagnostic_summaries.iter_mut() {\n            summaries.retain(|path, summaries_by_server_id| {\n                if summaries_by_server_id.remove(&server_id).is_some() {\n                    if let Some((client, project_id)) = self.downstream_client.clone() {\n                        client\n                            .send(proto::UpdateDiagnosticSummary {\n                                project_id,\n                                worktree_id: worktree_id.to_proto(),\n                                summary: Some(proto::DiagnosticSummary {\n                                    path: path.as_ref().to_proto(),\n                                    language_server_id: server_id.0 as u64,\n                                    error_count: 0,\n                                    warning_count: 0,\n                                }),\n                            })\n                            .log_err();\n                    }\n                    !summaries_by_server_id.is_empty()\n                } else {\n                    true\n                }\n            });\n        }\n\n        let local = self.as_local_mut().unwrap();\n        for diagnostics in local.diagnostics.values_mut() {\n            diagnostics.retain(|_, diagnostics_by_server_id| {\n                if let Ok(ix) = diagnostics_by_server_id.binary_search_by_key(&server_id, |e| e.0) {\n                    diagnostics_by_server_id.remove(ix);\n                    !diagnostics_by_server_id.is_empty()\n                } else {\n                    true\n                }\n            });\n        }\n        local.language_server_watched_paths.remove(&server_id);\n        let server_state = local.language_servers.remove(&server_id);\n        cx.notify();\n        self.remove_result_ids(server_id);\n        cx.emit(LspStoreEvent::LanguageServerRemoved(server_id));\n        cx.spawn(async move |_, cx| {\n            Self::shutdown_language_server(server_state, name, cx).await;\n            orphaned_worktrees\n        })\n    }\n\n    pub fn restart_language_servers_for_buffers(\n        &mut self,\n        buffers: Vec<Entity<Buffer>>,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some((client, project_id)) = self.upstream_client() {\n            let request = client.request(proto::RestartLanguageServers {\n                project_id,\n                buffer_ids: buffers\n                    .into_iter()\n                    .map(|b| b.read(cx).remote_id().to_proto())\n                    .collect(),\n            });\n            cx.background_spawn(request).detach_and_log_err(cx);\n        } else {\n            let stop_task = self.stop_local_language_servers_for_buffers(&buffers, cx);\n            cx.spawn(async move |this, cx| {\n                stop_task.await;\n                this.update(cx, |this, cx| {\n                    for buffer in buffers {\n                        this.register_buffer_with_language_servers(&buffer, true, cx);\n                    }\n                })\n                .ok()\n            })\n            .detach();\n        }\n    }\n\n    pub fn stop_language_servers_for_buffers(\n        &mut self,\n        buffers: Vec<Entity<Buffer>>,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some((client, project_id)) = self.upstream_client() {\n            let request = client.request(proto::StopLanguageServers {\n                project_id,\n                buffer_ids: buffers\n                    .into_iter()\n                    .map(|b| b.read(cx).remote_id().to_proto())\n                    .collect(),\n            });\n            cx.background_spawn(request).detach_and_log_err(cx);\n        } else {\n            self.stop_local_language_servers_for_buffers(&buffers, cx)\n                .detach();\n        }\n    }\n\n    fn stop_local_language_servers_for_buffers(\n        &mut self,\n        buffers: &[Entity<Buffer>],\n        cx: &mut Context<Self>,\n    ) -> Task<()> {\n        let Some(local) = self.as_local_mut() else {\n            return Task::ready(());\n        };\n        let language_servers_to_stop = buffers\n            .iter()\n            .flat_map(|buffer| {\n                buffer.update(cx, |buffer, cx| {\n                    local.language_server_ids_for_buffer(buffer, cx)\n                })\n            })\n            .collect::<BTreeSet<_>>();\n        local.lsp_tree.update(cx, |this, _| {\n            this.remove_nodes(&language_servers_to_stop);\n        });\n        let tasks = language_servers_to_stop\n            .into_iter()\n            .map(|server| {\n                let name = self\n                    .language_server_statuses\n                    .get(&server)\n                    .map(|state| state.name.as_str().into())\n                    .unwrap_or_else(|| LanguageServerName::from(": "",
    "));\n                self.stop_local_language_server(server, name, cx)\n            })\n            .collect::<Vec<_>>();\n\n        cx.background_spawn(futures::future::join_all(tasks).map(|_| ()))\n    }\n\n    fn get_buffer<'a>(&self, abs_path: &Path, cx: &'a App) -> Option<&'a Buffer> {\n        let (worktree, relative_path) =\n            self.worktree_store.read(cx).find_worktree(&abs_path, cx)?;\n\n        let project_path = ProjectPath {\n            worktree_id: worktree.read(cx).id(),\n            path: relative_path.into(),\n        };\n\n        Some(\n            self.buffer_store()\n                .read(cx)\n                .get_by_path(&project_path, cx)?\n                .read(cx),\n        )\n    }\n\n    pub fn update_diagnostics(\n        &mut self,\n        language_server_id: LanguageServerId,\n        params: lsp::PublishDiagnosticsParams,\n        result_id: Option<String>,\n        source_kind: DiagnosticSourceKind,\n        disk_based_sources: &[String],\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        self.merge_diagnostics(\n            language_server_id,\n            params,\n            result_id,\n            source_kind,\n            disk_based_sources,\n            |_, _| false,\n            cx,\n        )\n    }\n\n    pub fn merge_diagnostics<F: Fn(&Diagnostic, &App) -> bool + Clone>(\n        &mut self,\n        language_server_id: LanguageServerId,\n        mut params: lsp::PublishDiagnosticsParams,\n        result_id: Option<String>,\n        source_kind: DiagnosticSourceKind,\n        disk_based_sources: &[String],\n        filter: F,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        if !self.mode.is_local() {\n            anyhow::bail!(": "",
    ");\n        }\n        let abs_path = params\n            .uri\n            .to_file_path()\n            .map_err(|()| anyhow!(": "",
    "))?;\n        let mut diagnostics = Vec::default();\n        let mut primary_diagnostic_group_ids = HashMap::default();\n        let mut sources_by_group_id = HashMap::default();\n        let mut supporting_diagnostics = HashMap::default();\n\n        let adapter = self.language_server_adapter_for_id(language_server_id);\n\n        // Ensure that primary diagnostics are always the most severe\n        params.diagnostics.sort_by_key(|item| item.severity);\n\n        for diagnostic in &params.diagnostics {\n            let source = diagnostic.source.as_ref();\n            let range = range_from_lsp(diagnostic.range);\n            let is_supporting = diagnostic\n                .related_information\n                .as_ref()\n                .map_or(false, |infos| {\n                    infos.iter().any(|info| {\n                        primary_diagnostic_group_ids.contains_key(&(\n                            source,\n                            diagnostic.code.clone(),\n                            range_from_lsp(info.location.range),\n                        ))\n                    })\n                });\n\n            let is_unnecessary = diagnostic\n                .tags\n                .as_ref()\n                .map_or(false, |tags| tags.contains(&DiagnosticTag::UNNECESSARY));\n\n            let underline = self\n                .language_server_adapter_for_id(language_server_id)\n                .map_or(true, |adapter| adapter.underline_diagnostic(diagnostic));\n\n            if is_supporting {\n                supporting_diagnostics.insert(\n                    (source, diagnostic.code.clone(), range),\n                    (diagnostic.severity, is_unnecessary),\n                );\n            } else {\n                let group_id = post_inc(&mut self.as_local_mut().unwrap().next_diagnostic_group_id);\n                let is_disk_based =\n                    source.map_or(false, |source| disk_based_sources.contains(source));\n\n                sources_by_group_id.insert(group_id, source);\n                primary_diagnostic_group_ids\n                    .insert((source, diagnostic.code.clone(), range.clone()), group_id);\n\n                diagnostics.push(DiagnosticEntry {\n                    range,\n                    diagnostic: Diagnostic {\n                        source: diagnostic.source.clone(),\n                        source_kind,\n                        code: diagnostic.code.clone(),\n                        code_description: diagnostic\n                            .code_description\n                            .as_ref()\n                            .map(|d| d.href.clone()),\n                        severity: diagnostic.severity.unwrap_or(DiagnosticSeverity::ERROR),\n                        markdown: adapter.as_ref().and_then(|adapter| {\n                            adapter.diagnostic_message_to_markdown(&diagnostic.message)\n                        }),\n                        message: diagnostic.message.trim().to_string(),\n                        group_id,\n                        is_primary: true,\n                        is_disk_based,\n                        is_unnecessary,\n                        underline,\n                        data: diagnostic.data.clone(),\n                    },\n                });\n                if let Some(infos) = &diagnostic.related_information {\n                    for info in infos {\n                        if info.location.uri == params.uri && !info.message.is_empty() {\n                            let range = range_from_lsp(info.location.range);\n                            diagnostics.push(DiagnosticEntry {\n                                range,\n                                diagnostic: Diagnostic {\n                                    source: diagnostic.source.clone(),\n                                    source_kind,\n                                    code: diagnostic.code.clone(),\n                                    code_description: diagnostic\n                                        .code_description\n                                        .as_ref()\n                                        .map(|c| c.href.clone()),\n                                    severity: DiagnosticSeverity::INFORMATION,\n                                    markdown: adapter.as_ref().and_then(|adapter| {\n                                        adapter.diagnostic_message_to_markdown(&info.message)\n                                    }),\n                                    message: info.message.trim().to_string(),\n                                    group_id,\n                                    is_primary: false,\n                                    is_disk_based,\n                                    is_unnecessary: false,\n                                    underline,\n                                    data: diagnostic.data.clone(),\n                                },\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        for entry in &mut diagnostics {\n            let diagnostic = &mut entry.diagnostic;\n            if !diagnostic.is_primary {\n                let source = *sources_by_group_id.get(&diagnostic.group_id).unwrap();\n                if let Some(&(severity, is_unnecessary)) = supporting_diagnostics.get(&(\n                    source,\n                    diagnostic.code.clone(),\n                    entry.range.clone(),\n                )) {\n                    if let Some(severity) = severity {\n                        diagnostic.severity = severity;\n                    }\n                    diagnostic.is_unnecessary = is_unnecessary;\n                }\n            }\n        }\n\n        self.merge_diagnostic_entries(\n            language_server_id,\n            abs_path,\n            result_id,\n            params.version,\n            diagnostics,\n            filter,\n            cx,\n        )?;\n        Ok(())\n    }\n\n    fn insert_newly_running_language_server(\n        &mut self,\n        adapter: Arc<CachedLspAdapter>,\n        language_server: Arc<LanguageServer>,\n        server_id: LanguageServerId,\n        key: (WorktreeId, LanguageServerName),\n        workspace_folders: Arc<Mutex<BTreeSet<Url>>>,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(local) = self.as_local_mut() else {\n            return;\n        };\n        // If the language server for this key doesn't match the server id, don't store the\n        // server. Which will cause it to be dropped, killing the process\n        if local\n            .language_server_ids\n            .get(&key)\n            .map(|ids| !ids.contains(&server_id))\n            .unwrap_or(false)\n        {\n            return;\n        }\n\n        // Update language_servers collection with Running variant of LanguageServerState\n        // indicating that the server is up and running and ready\n        let workspace_folders = workspace_folders.lock().clone();\n        language_server.set_workspace_folders(workspace_folders);\n\n        local.language_servers.insert(\n            server_id,\n            LanguageServerState::Running {\n                workspace_refresh_task: lsp_workspace_diagnostics_refresh(\n                    language_server.clone(),\n                    cx,\n                ),\n                adapter: adapter.clone(),\n                server: language_server.clone(),\n                simulate_disk_based_diagnostics_completion: None,\n            },\n        );\n        if let Some(file_ops_caps) = language_server\n            .capabilities()\n            .workspace\n            .as_ref()\n            .and_then(|ws| ws.file_operations.as_ref())\n        {\n            let did_rename_caps = file_ops_caps.did_rename.as_ref();\n            let will_rename_caps = file_ops_caps.will_rename.as_ref();\n            if did_rename_caps.or(will_rename_caps).is_some() {\n                let watcher = RenamePathsWatchedForServer::default()\n                    .with_did_rename_patterns(did_rename_caps)\n                    .with_will_rename_patterns(will_rename_caps);\n                local\n                    .language_server_paths_watched_for_rename\n                    .insert(server_id, watcher);\n            }\n        }\n\n        self.language_server_statuses.insert(\n            server_id,\n            LanguageServerStatus {\n                name: language_server.name().to_string(),\n                pending_work: Default::default(),\n                has_pending_diagnostic_updates: false,\n                progress_tokens: Default::default(),\n            },\n        );\n\n        cx.emit(LspStoreEvent::LanguageServerAdded(\n            server_id,\n            language_server.name(),\n            Some(key.0),\n        ));\n        cx.emit(LspStoreEvent::RefreshInlayHints);\n\n        if let Some((downstream_client, project_id)) = self.downstream_client.as_ref() {\n            downstream_client\n                .send(proto::StartLanguageServer {\n                    project_id: *project_id,\n                    server: Some(proto::LanguageServer {\n                        id: server_id.0 as u64,\n                        name: language_server.name().to_string(),\n                        worktree_id: Some(key.0.to_proto()),\n                    }),\n                })\n                .log_err();\n        }\n\n        // Tell the language server about every open buffer in the worktree that matches the language.\n        self.buffer_store.clone().update(cx, |buffer_store, cx| {\n            for buffer_handle in buffer_store.buffers() {\n                let buffer = buffer_handle.read(cx);\n                let file = match File::from_dyn(buffer.file()) {\n                    Some(file) => file,\n                    None => continue,\n                };\n                let language = match buffer.language() {\n                    Some(language) => language,\n                    None => continue,\n                };\n\n                if file.worktree.read(cx).id() != key.0\n                    || !self\n                        .languages\n                        .lsp_adapters(&language.name())\n                        .iter()\n                        .any(|a| a.name == key.1)\n                {\n                    continue;\n                }\n                // didOpen\n                let file = match file.as_local() {\n                    Some(file) => file,\n                    None => continue,\n                };\n\n                let local = self.as_local_mut().unwrap();\n\n                if local.registered_buffers.contains_key(&buffer.remote_id()) {\n                    let versions = local\n                        .buffer_snapshots\n                        .entry(buffer.remote_id())\n                        .or_default()\n                        .entry(server_id)\n                        .and_modify(|_| {\n                            assert!(\n                            false,\n                            ": "",
    "\n                        )\n                        })\n                        .or_insert_with(|| {\n                            vec![LspBufferSnapshot {\n                                version: 0,\n                                snapshot: buffer.text_snapshot(),\n                            }]\n                        });\n\n                    let snapshot = versions.last().unwrap();\n                    let version = snapshot.version;\n                    let initial_snapshot = &snapshot.snapshot;\n                    let uri = lsp::Url::from_file_path(file.abs_path(cx)).unwrap();\n                    language_server.register_buffer(\n                        uri,\n                        adapter.language_id(&language.name()),\n                        version,\n                        initial_snapshot.text(),\n                    );\n                }\n                buffer_handle.update(cx, |buffer, cx| {\n                    buffer.set_completion_triggers(\n                        server_id,\n                        language_server\n                            .capabilities()\n                            .completion_provider\n                            .as_ref()\n                            .and_then(|provider| {\n                                provider\n                                    .trigger_characters\n                                    .as_ref()\n                                    .map(|characters| characters.iter().cloned().collect())\n                            })\n                            .unwrap_or_default(),\n                        cx,\n                    )\n                });\n            }\n        });\n\n        cx.notify();\n    }\n\n    pub fn language_servers_running_disk_based_diagnostics(\n        &self,\n    ) -> impl Iterator<Item = LanguageServerId> + '_ {\n        self.language_server_statuses\n            .iter()\n            .filter_map(|(id, status)| {\n                if status.has_pending_diagnostic_updates {\n                    Some(*id)\n                } else {\n                    None\n                }\n            })\n    }\n\n    pub(crate) fn cancel_language_server_work_for_buffers(\n        &mut self,\n        buffers: impl IntoIterator<Item = Entity<Buffer>>,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some((client, project_id)) = self.upstream_client() {\n            let request = client.request(proto::CancelLanguageServerWork {\n                project_id,\n                work: Some(proto::cancel_language_server_work::Work::Buffers(\n                    proto::cancel_language_server_work::Buffers {\n                        buffer_ids: buffers\n                            .into_iter()\n                            .map(|b| b.read(cx).remote_id().to_proto())\n                            .collect(),\n                    },\n                )),\n            });\n            cx.background_spawn(request).detach_and_log_err(cx);\n        } else if let Some(local) = self.as_local() {\n            let servers = buffers\n                .into_iter()\n                .flat_map(|buffer| {\n                    buffer.update(cx, |buffer, cx| {\n                        local.language_server_ids_for_buffer(buffer, cx).into_iter()\n                    })\n                })\n                .collect::<HashSet<_>>();\n            for server_id in servers {\n                self.cancel_language_server_work(server_id, None, cx);\n            }\n        }\n    }\n\n    pub(crate) fn cancel_language_server_work(\n        &mut self,\n        server_id: LanguageServerId,\n        token_to_cancel: Option<String>,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(local) = self.as_local() {\n            let status = self.language_server_statuses.get(&server_id);\n            let server = local.language_servers.get(&server_id);\n            if let Some((LanguageServerState::Running { server, .. }, status)) = server.zip(status)\n            {\n                for (token, progress) in &status.pending_work {\n                    if let Some(token_to_cancel) = token_to_cancel.as_ref() {\n                        if token != token_to_cancel {\n                            continue;\n                        }\n                    }\n                    if progress.is_cancellable {\n                        server\n                            .notify::<lsp::notification::WorkDoneProgressCancel>(\n                                &WorkDoneProgressCancelParams {\n                                    token: lsp::NumberOrString::String(token.clone()),\n                                },\n                            )\n                            .ok();\n                    }\n                }\n            }\n        } else if let Some((client, project_id)) = self.upstream_client() {\n            let request = client.request(proto::CancelLanguageServerWork {\n                project_id,\n                work: Some(\n                    proto::cancel_language_server_work::Work::LanguageServerWork(\n                        proto::cancel_language_server_work::LanguageServerWork {\n                            language_server_id: server_id.to_proto(),\n                            token: token_to_cancel,\n                        },\n                    ),\n                ),\n            });\n            cx.background_spawn(request).detach_and_log_err(cx);\n        }\n    }\n\n    fn register_supplementary_language_server(\n        &mut self,\n        id: LanguageServerId,\n        name: LanguageServerName,\n        server: Arc<LanguageServer>,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(local) = self.as_local_mut() {\n            local\n                .supplementary_language_servers\n                .insert(id, (name.clone(), server));\n            cx.emit(LspStoreEvent::LanguageServerAdded(id, name, None));\n        }\n    }\n\n    fn unregister_supplementary_language_server(\n        &mut self,\n        id: LanguageServerId,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(local) = self.as_local_mut() {\n            local.supplementary_language_servers.remove(&id);\n            cx.emit(LspStoreEvent::LanguageServerRemoved(id));\n        }\n    }\n\n    pub(crate) fn supplementary_language_servers(\n        &self,\n    ) -> impl '_ + Iterator<Item = (LanguageServerId, LanguageServerName)> {\n        self.as_local().into_iter().flat_map(|local| {\n            local\n                .supplementary_language_servers\n                .iter()\n                .map(|(id, (name, _))| (*id, name.clone()))\n        })\n    }\n\n    pub fn language_server_adapter_for_id(\n        &self,\n        id: LanguageServerId,\n    ) -> Option<Arc<CachedLspAdapter>> {\n        self.as_local()\n            .and_then(|local| local.language_servers.get(&id))\n            .and_then(|language_server_state| match language_server_state {\n                LanguageServerState::Running { adapter, .. } => Some(adapter.clone()),\n                _ => None,\n            })\n    }\n\n    pub(super) fn update_local_worktree_language_servers(\n        &mut self,\n        worktree_handle: &Entity<Worktree>,\n        changes: &[(Arc<Path>, ProjectEntryId, PathChange)],\n        cx: &mut Context<Self>,\n    ) {\n        if changes.is_empty() {\n            return;\n        }\n\n        let Some(local) = self.as_local() else { return };\n\n        local.prettier_store.update(cx, |prettier_store, cx| {\n            prettier_store.update_prettier_settings(&worktree_handle, changes, cx)\n        });\n\n        let worktree_id = worktree_handle.read(cx).id();\n        let mut language_server_ids = local\n            .language_server_ids\n            .iter()\n            .flat_map(|((server_worktree, _), server_ids)| {\n                server_ids\n                    .iter()\n                    .filter_map(|server_id| server_worktree.eq(&worktree_id).then(|| *server_id))\n            })\n            .collect::<Vec<_>>();\n        language_server_ids.sort();\n        language_server_ids.dedup();\n\n        let abs_path = worktree_handle.read(cx).abs_path();\n        for server_id in &language_server_ids {\n            if let Some(LanguageServerState::Running { server, .. }) =\n                local.language_servers.get(server_id)\n            {\n                if let Some(watched_paths) = local\n                    .language_server_watched_paths\n                    .get(server_id)\n                    .and_then(|paths| paths.worktree_paths.get(&worktree_id))\n                {\n                    let params = lsp::DidChangeWatchedFilesParams {\n                        changes: changes\n                            .iter()\n                            .filter_map(|(path, _, change)| {\n                                if !watched_paths.is_match(path) {\n                                    return None;\n                                }\n                                let typ = match change {\n                                    PathChange::Loaded => return None,\n                                    PathChange::Added => lsp::FileChangeType::CREATED,\n                                    PathChange::Removed => lsp::FileChangeType::DELETED,\n                                    PathChange::Updated => lsp::FileChangeType::CHANGED,\n                                    PathChange::AddedOrUpdated => lsp::FileChangeType::CHANGED,\n                                };\n                                Some(lsp::FileEvent {\n                                    uri: lsp::Url::from_file_path(abs_path.join(path)).unwrap(),\n                                    typ,\n                                })\n                            })\n                            .collect(),\n                    };\n                    if !params.changes.is_empty() {\n                        server\n                            .notify::<lsp::notification::DidChangeWatchedFiles>(&params)\n                            .ok();\n                    }\n                }\n            }\n        }\n    }\n\n    pub fn wait_for_remote_buffer(\n        &mut self,\n        id: BufferId,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<Buffer>>> {\n        self.buffer_store.update(cx, |buffer_store, cx| {\n            buffer_store.wait_for_remote_buffer(id, cx)\n        })\n    }\n\n    fn serialize_symbol(symbol: &Symbol) -> proto::Symbol {\n        proto::Symbol {\n            language_server_name: symbol.language_server_name.0.to_string(),\n            source_worktree_id: symbol.source_worktree_id.to_proto(),\n            language_server_id: symbol.source_language_server_id.to_proto(),\n            worktree_id: symbol.path.worktree_id.to_proto(),\n            path: symbol.path.path.as_ref().to_proto(),\n            name: symbol.name.clone(),\n            kind: unsafe { mem::transmute::<lsp::SymbolKind, i32>(symbol.kind) },\n            start: Some(proto::PointUtf16 {\n                row: symbol.range.start.0.row,\n                column: symbol.range.start.0.column,\n            }),\n            end: Some(proto::PointUtf16 {\n                row: symbol.range.end.0.row,\n                column: symbol.range.end.0.column,\n            }),\n            signature: symbol.signature.to_vec(),\n        }\n    }\n\n    fn deserialize_symbol(serialized_symbol: proto::Symbol) -> Result<CoreSymbol> {\n        let source_worktree_id = WorktreeId::from_proto(serialized_symbol.source_worktree_id);\n        let worktree_id = WorktreeId::from_proto(serialized_symbol.worktree_id);\n        let kind = unsafe { mem::transmute::<i32, lsp::SymbolKind>(serialized_symbol.kind) };\n        let path = ProjectPath {\n            worktree_id,\n            path: Arc::<Path>::from_proto(serialized_symbol.path),\n        };\n\n        let start = serialized_symbol.start.context(": "",
    ")?;\n        let end = serialized_symbol.end.context(": "",
    ")?;\n        Ok(CoreSymbol {\n            language_server_name: LanguageServerName(serialized_symbol.language_server_name.into()),\n            source_worktree_id,\n            source_language_server_id: LanguageServerId::from_proto(\n                serialized_symbol.language_server_id,\n            ),\n            path,\n            name: serialized_symbol.name,\n            range: Unclipped(PointUtf16::new(start.row, start.column))\n                ..Unclipped(PointUtf16::new(end.row, end.column)),\n            kind,\n            signature: serialized_symbol\n                .signature\n                .try_into()\n                .map_err(|_| anyhow!(": "",
    "))?,\n        })\n    }\n\n    pub(crate) fn serialize_completion(completion: &CoreCompletion) -> proto::Completion {\n        let mut serialized_completion = proto::Completion {\n            old_replace_start: Some(serialize_anchor(&completion.replace_range.start)),\n            old_replace_end: Some(serialize_anchor(&completion.replace_range.end)),\n            new_text: completion.new_text.clone(),\n            ..proto::Completion::default()\n        };\n        match &completion.source {\n            CompletionSource::Lsp {\n                insert_range,\n                server_id,\n                lsp_completion,\n                lsp_defaults,\n                resolved,\n            } => {\n                let (old_insert_start, old_insert_end) = insert_range\n                    .as_ref()\n                    .map(|range| (serialize_anchor(&range.start), serialize_anchor(&range.end)))\n                    .unzip();\n\n                serialized_completion.old_insert_start = old_insert_start;\n                serialized_completion.old_insert_end = old_insert_end;\n                serialized_completion.source = proto::completion::Source::Lsp as i32;\n                serialized_completion.server_id = server_id.0 as u64;\n                serialized_completion.lsp_completion = serde_json::to_vec(lsp_completion).unwrap();\n                serialized_completion.lsp_defaults = lsp_defaults\n                    .as_deref()\n                    .map(|lsp_defaults| serde_json::to_vec(lsp_defaults).unwrap());\n                serialized_completion.resolved = *resolved;\n            }\n            CompletionSource::BufferWord {\n                word_range,\n                resolved,\n            } => {\n                serialized_completion.source = proto::completion::Source::BufferWord as i32;\n                serialized_completion.buffer_word_start = Some(serialize_anchor(&word_range.start));\n                serialized_completion.buffer_word_end = Some(serialize_anchor(&word_range.end));\n                serialized_completion.resolved = *resolved;\n            }\n            CompletionSource::Custom => {\n                serialized_completion.source = proto::completion::Source::Custom as i32;\n                serialized_completion.resolved = true;\n            }\n        }\n\n        serialized_completion\n    }\n\n    pub(crate) fn deserialize_completion(completion: proto::Completion) -> Result<CoreCompletion> {\n        let old_replace_start = completion\n            .old_replace_start\n            .and_then(deserialize_anchor)\n            .context(": "",
    ")?;\n        let old_replace_end = completion\n            .old_replace_end\n            .and_then(deserialize_anchor)\n            .context(": "",
    ")?;\n        let insert_range = {\n            match completion.old_insert_start.zip(completion.old_insert_end) {\n                Some((start, end)) => {\n                    let start = deserialize_anchor(start).context(": "",
    ")?;\n                    let end = deserialize_anchor(end).context(": "",
    ")?;\n                    Some(start..end)\n                }\n                None => None,\n            }\n        };\n        Ok(CoreCompletion {\n            replace_range: old_replace_start..old_replace_end,\n            new_text: completion.new_text,\n            source: match proto::completion::Source::from_i32(completion.source) {\n                Some(proto::completion::Source::Custom) => CompletionSource::Custom,\n                Some(proto::completion::Source::Lsp) => CompletionSource::Lsp {\n                    insert_range,\n                    server_id: LanguageServerId::from_proto(completion.server_id),\n                    lsp_completion: serde_json::from_slice(&completion.lsp_completion)?,\n                    lsp_defaults: completion\n                        .lsp_defaults\n                        .as_deref()\n                        .map(serde_json::from_slice)\n                        .transpose()?,\n                    resolved: completion.resolved,\n                },\n                Some(proto::completion::Source::BufferWord) => {\n                    let word_range = completion\n                        .buffer_word_start\n                        .and_then(deserialize_anchor)\n                        .context(": "",
    ")?\n                        ..completion\n                            .buffer_word_end\n                            .and_then(deserialize_anchor)\n                            .context(": "",
    ")?;\n                    CompletionSource::BufferWord {\n                        word_range,\n                        resolved: completion.resolved,\n                    }\n                }\n                _ => anyhow::bail!(": "",
    ", completion.source),\n            },\n        })\n    }\n\n    pub(crate) fn serialize_code_action(action: &CodeAction) -> proto::CodeAction {\n        let (kind, lsp_action) = match &action.lsp_action {\n            LspAction::Action(code_action) => (\n                proto::code_action::Kind::Action as i32,\n                serde_json::to_vec(code_action).unwrap(),\n            ),\n            LspAction::Command(command) => (\n                proto::code_action::Kind::Command as i32,\n                serde_json::to_vec(command).unwrap(),\n            ),\n            LspAction::CodeLens(code_lens) => (\n                proto::code_action::Kind::CodeLens as i32,\n                serde_json::to_vec(code_lens).unwrap(),\n            ),\n        };\n\n        proto::CodeAction {\n            server_id: action.server_id.0 as u64,\n            start: Some(serialize_anchor(&action.range.start)),\n            end: Some(serialize_anchor(&action.range.end)),\n            lsp_action,\n            kind,\n            resolved: action.resolved,\n        }\n    }\n\n    pub(crate) fn deserialize_code_action(action: proto::CodeAction) -> Result<CodeAction> {\n        let start = action\n            .start\n            .and_then(deserialize_anchor)\n            .context(": "",
    ")?;\n        let end = action\n            .end\n            .and_then(deserialize_anchor)\n            .context(": "",
    ")?;\n        let lsp_action = match proto::code_action::Kind::from_i32(action.kind) {\n            Some(proto::code_action::Kind::Action) => {\n                LspAction::Action(serde_json::from_slice(&action.lsp_action)?)\n            }\n            Some(proto::code_action::Kind::Command) => {\n                LspAction::Command(serde_json::from_slice(&action.lsp_action)?)\n            }\n            Some(proto::code_action::Kind::CodeLens) => {\n                LspAction::CodeLens(serde_json::from_slice(&action.lsp_action)?)\n            }\n            None => anyhow::bail!(": "",
    ", action.kind),\n        };\n        Ok(CodeAction {\n            server_id: LanguageServerId(action.server_id as usize),\n            range: start..end,\n            resolved: action.resolved,\n            lsp_action,\n        })\n    }\n\n    fn update_last_formatting_failure<T>(&mut self, formatting_result: &anyhow::Result<T>) {\n        match &formatting_result {\n            Ok(_) => self.last_formatting_failure = None,\n            Err(error) => {\n                let error_string = format!(": "",
    ");\n                log::error!(": "",
    ");\n                self.last_formatting_failure\n                    .replace(error_string.lines().join(": "",
    "));\n            }\n        }\n    }\n\n    fn remove_result_ids(&mut self, for_server: LanguageServerId) {\n        if let Some(local) = self.as_local_mut() {\n            for values_per_server in local.buffer_pull_diagnostics_result_ids.values_mut() {\n                values_per_server.remove(&for_server);\n            }\n        }\n    }\n\n    pub fn result_id(\n        &self,\n        server_id: LanguageServerId,\n        buffer_id: BufferId,\n        cx: &App,\n    ) -> Option<String> {\n        let abs_path = self\n            .buffer_store\n            .read(cx)\n            .get(buffer_id)\n            .and_then(|b| File::from_dyn(b.read(cx).file()))\n            .map(|f| f.abs_path(cx))?;\n        self.as_local()?\n            .buffer_pull_diagnostics_result_ids\n            .get(&abs_path)?\n            .get(&server_id)?\n            .clone()\n    }\n\n    pub fn all_result_ids(&self, server_id: LanguageServerId) -> HashMap<PathBuf, String> {\n        let Some(local) = self.as_local() else {\n            return HashMap::default();\n        };\n        local\n            .buffer_pull_diagnostics_result_ids\n            .iter()\n            .filter_map(|(file_path, result_ids)| {\n                Some((file_path.clone(), result_ids.get(&server_id)?.clone()?))\n            })\n            .collect()\n    }\n\n    pub fn pull_workspace_diagnostics(&mut self, server_id: LanguageServerId) {\n        if let Some(LanguageServerState::Running {\n            workspace_refresh_task: Some((tx, _)),\n            ..\n        }) = self\n            .as_local_mut()\n            .and_then(|local| local.language_servers.get_mut(&server_id))\n        {\n            tx.try_send(()).ok();\n        }\n    }\n\n    pub fn pull_workspace_diagnostics_for_buffer(&mut self, buffer_id: BufferId, cx: &mut App) {\n        let Some(buffer) = self.buffer_store().read(cx).get_existing(buffer_id).ok() else {\n            return;\n        };\n        let Some(local) = self.as_local_mut() else {\n            return;\n        };\n\n        for server_id in buffer.update(cx, |buffer, cx| {\n            local.language_server_ids_for_buffer(buffer, cx)\n        }) {\n            if let Some(LanguageServerState::Running {\n                workspace_refresh_task: Some((tx, _)),\n                ..\n            }) = local.language_servers.get_mut(&server_id)\n            {\n                tx.try_send(()).ok();\n            }\n        }\n    }\n}\n\nfn lsp_workspace_diagnostics_refresh(\n    server: Arc<LanguageServer>,\n    cx: &mut Context<'_, LspStore>,\n) -> Option<(mpsc::Sender<()>, Task<()>)> {\n    let identifier = match server.capabilities().diagnostic_provider? {\n        lsp::DiagnosticServerCapabilities::Options(diagnostic_options) => {\n            if !diagnostic_options.workspace_diagnostics {\n                return None;\n            }\n            diagnostic_options.identifier\n        }\n        lsp::DiagnosticServerCapabilities::RegistrationOptions(registration_options) => {\n            let diagnostic_options = registration_options.diagnostic_options;\n            if !diagnostic_options.workspace_diagnostics {\n                return None;\n            }\n            diagnostic_options.identifier\n        }\n    };\n\n    let (mut tx, mut rx) = mpsc::channel(1);\n    tx.try_send(()).ok();\n\n    let workspace_query_language_server = cx.spawn(async move |lsp_store, cx| {\n        let mut attempts = 0;\n        let max_attempts = 50;\n\n        loop {\n            let Some(()) = rx.recv().await else {\n                return;\n            };\n\n            'request: loop {\n                if attempts > max_attempts {\n                    log::error!(\n                        ": "",
    "\n                    );\n                    return;\n                }\n                let backoff_millis = (50 * (1 << attempts)).clamp(30, 1000);\n                cx.background_executor()\n                    .timer(Duration::from_millis(backoff_millis))\n                    .await;\n                attempts += 1;\n\n                let Ok(previous_result_ids) = lsp_store.update(cx, |lsp_store, _| {\n                    lsp_store\n                        .all_result_ids(server.server_id())\n                        .into_iter()\n                        .filter_map(|(abs_path, result_id)| {\n                            let uri = file_path_to_lsp_url(&abs_path).ok()?;\n                            Some(lsp::PreviousResultId {\n                                uri,\n                                value: result_id,\n                            })\n                        })\n                        .collect()\n                }) else {\n                    return;\n                };\n\n                let response_result = server\n                    .request::<lsp::WorkspaceDiagnosticRequest>(lsp::WorkspaceDiagnosticParams {\n                        previous_result_ids,\n                        identifier: identifier.clone(),\n                        work_done_progress_params: Default::default(),\n                        partial_result_params: Default::default(),\n                    })\n                    .await;\n                // https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#diagnostic_refresh\n                // >  If a server closes a workspace diagnostic pull request the client should re-trigger the request.\n                match response_result {\n                    ConnectionResult::Timeout => {\n                        log::error!(": "",
    ");\n                        continue 'request;\n                    }\n                    ConnectionResult::ConnectionReset => {\n                        log::error!(": "",
    ");\n                        continue 'request;\n                    }\n                    ConnectionResult::Result(Err(e)) => {\n                        log::error!(": "",
    ");\n                        break 'request;\n                    }\n                    ConnectionResult::Result(Ok(pulled_diagnostics)) => {\n                        attempts = 0;\n                        if lsp_store\n                            .update(cx, |lsp_store, cx| {\n                                let workspace_diagnostics =\n                                    GetDocumentDiagnostics::deserialize_workspace_diagnostics_report(pulled_diagnostics, server.server_id());\n                                for workspace_diagnostics in workspace_diagnostics {\n                                    let LspPullDiagnostics::Response {\n                                        server_id,\n                                        uri,\n                                        diagnostics,\n                                    } = workspace_diagnostics.diagnostics\n                                    else {\n                                        continue;\n                                    };\n\n                                    let adapter = lsp_store.language_server_adapter_for_id(server_id);\n                                    let disk_based_sources = adapter\n                                        .as_ref()\n                                        .map(|adapter| adapter.disk_based_diagnostic_sources.as_slice())\n                                        .unwrap_or(&[]);\n\n                                    match diagnostics {\n                                        PulledDiagnostics::Unchanged { result_id } => {\n                                            lsp_store\n                                                .merge_diagnostics(\n                                                    server_id,\n                                                    lsp::PublishDiagnosticsParams {\n                                                        uri: uri.clone(),\n                                                        diagnostics: Vec::new(),\n                                                        version: None,\n                                                    },\n                                                    Some(result_id),\n                                                    DiagnosticSourceKind::Pulled,\n                                                    disk_based_sources,\n                                                    |_, _| true,\n                                                    cx,\n                                                )\n                                                .log_err();\n                                        }\n                                        PulledDiagnostics::Changed {\n                                            diagnostics,\n                                            result_id,\n                                        } => {\n                                            lsp_store\n                                                .merge_diagnostics(\n                                                    server_id,\n                                                    lsp::PublishDiagnosticsParams {\n                                                        uri: uri.clone(),\n                                                        diagnostics,\n                                                        version: workspace_diagnostics.version,\n                                                    },\n                                                    result_id,\n                                                    DiagnosticSourceKind::Pulled,\n                                                    disk_based_sources,\n                                                    |old_diagnostic, _| match old_diagnostic.source_kind {\n                                                        DiagnosticSourceKind::Pulled => false,\n                                                        DiagnosticSourceKind::Other\n                                                        | DiagnosticSourceKind::Pushed => true,\n                                                    },\n                                                    cx,\n                                                )\n                                                .log_err();\n                                        }\n                                    }\n                                }\n                            })\n                            .is_err()\n                        {\n                            return;\n                        }\n                        break 'request;\n                    }\n                }\n            }\n        }\n    });\n\n    Some((tx, workspace_query_language_server))\n}\n\nfn resolve_word_completion(snapshot: &BufferSnapshot, completion: &mut Completion) {\n    let CompletionSource::BufferWord {\n        word_range,\n        resolved,\n    } = &mut completion.source\n    else {\n        return;\n    };\n    if *resolved {\n        return;\n    }\n\n    if completion.new_text\n        != snapshot\n            .text_for_range(word_range.clone())\n            .collect::<String>()\n    {\n        return;\n    }\n\n    let mut offset = 0;\n    for chunk in snapshot.chunks(word_range.clone(), true) {\n        let end_offset = offset + chunk.text.len();\n        if let Some(highlight_id) = chunk.syntax_highlight_id {\n            completion\n                .label\n                .runs\n                .push((offset..end_offset, highlight_id));\n        }\n        offset = end_offset;\n    }\n    *resolved = true;\n}\n\nimpl EventEmitter<LspStoreEvent> for LspStore {}\n\nfn remove_empty_hover_blocks(mut hover: Hover) -> Option<Hover> {\n    hover\n        .contents\n        .retain(|hover_block| !hover_block.text.trim().is_empty());\n    if hover.contents.is_empty() {\n        None\n    } else {\n        Some(hover)\n    }\n}\n\nasync fn populate_labels_for_completions(\n    new_completions: Vec<CoreCompletion>,\n    language: Option<Arc<Language>>,\n    lsp_adapter: Option<Arc<CachedLspAdapter>>,\n) -> Vec<Completion> {\n    let lsp_completions = new_completions\n        .iter()\n        .filter_map(|new_completion| {\n            if let Some(lsp_completion) = new_completion.source.lsp_completion(true) {\n                Some(lsp_completion.into_owned())\n            } else {\n                None\n            }\n        })\n        .collect::<Vec<_>>();\n\n    let mut labels = if let Some((language, lsp_adapter)) = language.as_ref().zip(lsp_adapter) {\n        lsp_adapter\n            .labels_for_completions(&lsp_completions, language)\n            .await\n            .log_err()\n            .unwrap_or_default()\n    } else {\n        Vec::new()\n    }\n    .into_iter()\n    .fuse();\n\n    let mut completions = Vec::new();\n    for completion in new_completions {\n        match completion.source.lsp_completion(true) {\n            Some(lsp_completion) => {\n                let documentation = if let Some(docs) = lsp_completion.documentation.clone() {\n                    Some(docs.into())\n                } else {\n                    None\n                };\n\n                let mut label = labels.next().flatten().unwrap_or_else(|| {\n                    CodeLabel::fallback_for_completion(&lsp_completion, language.as_deref())\n                });\n                ensure_uniform_list_compatible_label(&mut label);\n                completions.push(Completion {\n                    label,\n                    documentation,\n                    replace_range: completion.replace_range,\n                    new_text: completion.new_text,\n                    insert_text_mode: lsp_completion.insert_text_mode,\n                    source: completion.source,\n                    icon_path: None,\n                    confirm: None,\n                });\n            }\n            None => {\n                let mut label = CodeLabel::plain(completion.new_text.clone(), None);\n                ensure_uniform_list_compatible_label(&mut label);\n                completions.push(Completion {\n                    label,\n                    documentation: None,\n                    replace_range: completion.replace_range,\n                    new_text: completion.new_text,\n                    source: completion.source,\n                    insert_text_mode: None,\n                    icon_path: None,\n                    confirm: None,\n                });\n            }\n        }\n    }\n    completions\n}\n\n#[derive(Debug)]\npub enum LanguageServerToQuery {\n    /// Query language servers in order of users preference, up until one capable of handling the request is found.\n    FirstCapable,\n    /// Query a specific language server.\n    Other(LanguageServerId),\n}\n\n#[derive(Default)]\nstruct RenamePathsWatchedForServer {\n    did_rename: Vec<RenameActionPredicate>,\n    will_rename: Vec<RenameActionPredicate>,\n}\n\nimpl RenamePathsWatchedForServer {\n    fn with_did_rename_patterns(\n        mut self,\n        did_rename: Option<&FileOperationRegistrationOptions>,\n    ) -> Self {\n        if let Some(did_rename) = did_rename {\n            self.did_rename = did_rename\n                .filters\n                .iter()\n                .filter_map(|filter| filter.try_into().log_err())\n                .collect();\n        }\n        self\n    }\n    fn with_will_rename_patterns(\n        mut self,\n        will_rename: Option<&FileOperationRegistrationOptions>,\n    ) -> Self {\n        if let Some(will_rename) = will_rename {\n            self.will_rename = will_rename\n                .filters\n                .iter()\n                .filter_map(|filter| filter.try_into().log_err())\n                .collect();\n        }\n        self\n    }\n\n    fn should_send_did_rename(&self, path: &str, is_dir: bool) -> bool {\n        self.did_rename.iter().any(|pred| pred.eval(path, is_dir))\n    }\n    fn should_send_will_rename(&self, path: &str, is_dir: bool) -> bool {\n        self.will_rename.iter().any(|pred| pred.eval(path, is_dir))\n    }\n}\n\nimpl TryFrom<&FileOperationFilter> for RenameActionPredicate {\n    type Error = globset::Error;\n    fn try_from(ops: &FileOperationFilter) -> Result<Self, globset::Error> {\n        Ok(Self {\n            kind: ops.pattern.matches.clone(),\n            glob: GlobBuilder::new(&ops.pattern.glob)\n                .case_insensitive(\n                    ops.pattern\n                        .options\n                        .as_ref()\n                        .map_or(false, |ops| ops.ignore_case.unwrap_or(false)),\n                )\n                .build()?\n                .compile_matcher(),\n        })\n    }\n}\nstruct RenameActionPredicate {\n    glob: GlobMatcher,\n    kind: Option<FileOperationPatternKind>,\n}\n\nimpl RenameActionPredicate {\n    // Returns true if language server should be notified\n    fn eval(&self, path: &str, is_dir: bool) -> bool {\n        self.kind.as_ref().map_or(true, |kind| {\n            let expected_kind = if is_dir {\n                FileOperationPatternKind::Folder\n            } else {\n                FileOperationPatternKind::File\n            };\n            kind == &expected_kind\n        }) && self.glob.is_match(path)\n    }\n}\n\n#[derive(Default)]\nstruct LanguageServerWatchedPaths {\n    worktree_paths: HashMap<WorktreeId, GlobSet>,\n    abs_paths: HashMap<Arc<Path>, (GlobSet, Task<()>)>,\n}\n\n#[derive(Default)]\nstruct LanguageServerWatchedPathsBuilder {\n    worktree_paths: HashMap<WorktreeId, GlobSet>,\n    abs_paths: HashMap<Arc<Path>, GlobSet>,\n}\n\nimpl LanguageServerWatchedPathsBuilder {\n    fn watch_worktree(&mut self, worktree_id: WorktreeId, glob_set: GlobSet) {\n        self.worktree_paths.insert(worktree_id, glob_set);\n    }\n    fn watch_abs_path(&mut self, path: Arc<Path>, glob_set: GlobSet) {\n        self.abs_paths.insert(path, glob_set);\n    }\n    fn build(\n        self,\n        fs: Arc<dyn Fs>,\n        language_server_id: LanguageServerId,\n        cx: &mut Context<LspStore>,\n    ) -> LanguageServerWatchedPaths {\n        let project = cx.weak_entity();\n\n        const LSP_ABS_PATH_OBSERVE: Duration = Duration::from_millis(100);\n        let abs_paths = self\n            .abs_paths\n            .into_iter()\n            .map(|(abs_path, globset)| {\n                let task = cx.spawn({\n                    let abs_path = abs_path.clone();\n                    let fs = fs.clone();\n\n                    let lsp_store = project.clone();\n                    async move |_, cx| {\n                        maybe!(async move {\n                            let mut push_updates = fs.watch(&abs_path, LSP_ABS_PATH_OBSERVE).await;\n                            while let Some(update) = push_updates.0.next().await {\n                                let action = lsp_store\n                                    .update(cx, |this, _| {\n                                        let Some(local) = this.as_local() else {\n                                            return ControlFlow::Break(());\n                                        };\n                                        let Some(watcher) = local\n                                            .language_server_watched_paths\n                                            .get(&language_server_id)\n                                        else {\n                                            return ControlFlow::Break(());\n                                        };\n                                        let (globs, _) = watcher.abs_paths.get(&abs_path).expect(\n                                            ": "",
    ",\n                                        );\n                                        let matching_entries = update\n                                            .into_iter()\n                                            .filter(|event| globs.is_match(&event.path))\n                                            .collect::<Vec<_>>();\n                                        this.lsp_notify_abs_paths_changed(\n                                            language_server_id,\n                                            matching_entries,\n                                        );\n                                        ControlFlow::Continue(())\n                                    })\n                                    .ok()?;\n\n                                if action.is_break() {\n                                    break;\n                                }\n                            }\n                            Some(())\n                        })\n                        .await;\n                    }\n                });\n                (abs_path, (globset, task))\n            })\n            .collect();\n        LanguageServerWatchedPaths {\n            worktree_paths: self.worktree_paths,\n            abs_paths,\n        }\n    }\n}\n\nstruct LspBufferSnapshot {\n    version: i32,\n    snapshot: TextBufferSnapshot,\n}\n\n/// A prompt requested by LSP server.\n#[derive(Clone, Debug)]\npub struct LanguageServerPromptRequest {\n    pub level: PromptLevel,\n    pub message: String,\n    pub actions: Vec<MessageActionItem>,\n    pub lsp_name: String,\n    pub(crate) response_channel: Sender<MessageActionItem>,\n}\n\nimpl LanguageServerPromptRequest {\n    pub async fn respond(self, index: usize) -> Option<()> {\n        if let Some(response) = self.actions.into_iter().nth(index) {\n            self.response_channel.send(response).await.ok()\n        } else {\n            None\n        }\n    }\n}\nimpl PartialEq for LanguageServerPromptRequest {\n    fn eq(&self, other: &Self) -> bool {\n        self.message == other.message && self.actions == other.actions\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum LanguageServerLogType {\n    Log(MessageType),\n    Trace(Option<String>),\n}\n\nimpl LanguageServerLogType {\n    pub fn to_proto(&self) -> proto::language_server_log::LogType {\n        match self {\n            Self::Log(log_type) => {\n                let message_type = match *log_type {\n                    MessageType::ERROR => 1,\n                    MessageType::WARNING => 2,\n                    MessageType::INFO => 3,\n                    MessageType::LOG => 4,\n                    other => {\n                        log::warn!(": "",
    ", other);\n                        4\n                    }\n                };\n                proto::language_server_log::LogType::LogMessageType(message_type)\n            }\n            Self::Trace(message) => {\n                proto::language_server_log::LogType::LogTrace(proto::LspLogTrace {\n                    message: message.clone(),\n                })\n            }\n        }\n    }\n\n    pub fn from_proto(log_type: proto::language_server_log::LogType) -> Self {\n        match log_type {\n            proto::language_server_log::LogType::LogMessageType(message_type) => {\n                Self::Log(match message_type {\n                    1 => MessageType::ERROR,\n                    2 => MessageType::WARNING,\n                    3 => MessageType::INFO,\n                    4 => MessageType::LOG,\n                    _ => MessageType::LOG,\n                })\n            }\n            proto::language_server_log::LogType::LogTrace(trace) => Self::Trace(trace.message),\n        }\n    }\n}\n\npub enum LanguageServerState {\n    Starting {\n        startup: Task<Option<Arc<LanguageServer>>>,\n        /// List of language servers that will be added to the workspace once it's initialization completes.\n        pending_workspace_folders: Arc<Mutex<BTreeSet<Url>>>,\n    },\n\n    Running {\n        adapter: Arc<CachedLspAdapter>,\n        server: Arc<LanguageServer>,\n        simulate_disk_based_diagnostics_completion: Option<Task<()>>,\n        workspace_refresh_task: Option<(mpsc::Sender<()>, Task<()>)>,\n    },\n}\n\nimpl LanguageServerState {\n    fn add_workspace_folder(&self, uri: Url) {\n        match self {\n            LanguageServerState::Starting {\n                pending_workspace_folders,\n                ..\n            } => {\n                pending_workspace_folders.lock().insert(uri);\n            }\n            LanguageServerState::Running { server, .. } => {\n                server.add_workspace_folder(uri);\n            }\n        }\n    }\n    fn _remove_workspace_folder(&self, uri: Url) {\n        match self {\n            LanguageServerState::Starting {\n                pending_workspace_folders,\n                ..\n            } => {\n                pending_workspace_folders.lock().remove(&uri);\n            }\n            LanguageServerState::Running { server, .. } => server.remove_workspace_folder(uri),\n        }\n    }\n}\n\nimpl std::fmt::Debug for LanguageServerState {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            LanguageServerState::Starting { .. } => {\n                f.debug_struct(": "",
    ").finish()\n            }\n            LanguageServerState::Running { .. } => {\n                f.debug_struct(": "",
    ").finish()\n            }\n        }\n    }\n}\n\n#[derive(Clone, Debug, Serialize)]\npub struct LanguageServerProgress {\n    pub is_disk_based_diagnostics_progress: bool,\n    pub is_cancellable: bool,\n    pub title: Option<String>,\n    pub message: Option<String>,\n    pub percentage: Option<usize>,\n    #[serde(skip_serializing)]\n    pub last_update_at: Instant,\n}\n\n#[derive(Copy, Clone, Debug, Default, PartialEq, Serialize)]\npub struct DiagnosticSummary {\n    pub error_count: usize,\n    pub warning_count: usize,\n}\n\nimpl DiagnosticSummary {\n    pub fn new<'a, T: 'a>(diagnostics: impl IntoIterator<Item = &'a DiagnosticEntry<T>>) -> Self {\n        let mut this = Self {\n            error_count: 0,\n            warning_count: 0,\n        };\n\n        for entry in diagnostics {\n            if entry.diagnostic.is_primary {\n                match entry.diagnostic.severity {\n                    DiagnosticSeverity::ERROR => this.error_count += 1,\n                    DiagnosticSeverity::WARNING => this.warning_count += 1,\n                    _ => {}\n                }\n            }\n        }\n\n        this\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.error_count == 0 && self.warning_count == 0\n    }\n\n    pub fn to_proto(\n        &self,\n        language_server_id: LanguageServerId,\n        path: &Path,\n    ) -> proto::DiagnosticSummary {\n        proto::DiagnosticSummary {\n            path: path.to_proto(),\n            language_server_id: language_server_id.0 as u64,\n            error_count: self.error_count as u32,\n            warning_count: self.warning_count as u32,\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\npub enum CompletionDocumentation {\n    /// There is no documentation for this completion.\n    Undocumented,\n    /// A single line of documentation.\n    SingleLine(SharedString),\n    /// Multiple lines of plain text documentation.\n    MultiLinePlainText(SharedString),\n    /// Markdown documentation.\n    MultiLineMarkdown(SharedString),\n    /// Both single line and multiple lines of plain text documentation.\n    SingleLineAndMultiLinePlainText {\n        single_line: SharedString,\n        plain_text: Option<SharedString>,\n    },\n}\n\nimpl From<lsp::Documentation> for CompletionDocumentation {\n    fn from(docs: lsp::Documentation) -> Self {\n        match docs {\n            lsp::Documentation::String(text) => {\n                if text.lines().count() <= 1 {\n                    CompletionDocumentation::SingleLine(text.into())\n                } else {\n                    CompletionDocumentation::MultiLinePlainText(text.into())\n                }\n            }\n\n            lsp::Documentation::MarkupContent(lsp::MarkupContent { kind, value }) => match kind {\n                lsp::MarkupKind::PlainText => {\n                    if value.lines().count() <= 1 {\n                        CompletionDocumentation::SingleLine(value.into())\n                    } else {\n                        CompletionDocumentation::MultiLinePlainText(value.into())\n                    }\n                }\n\n                lsp::MarkupKind::Markdown => {\n                    CompletionDocumentation::MultiLineMarkdown(value.into())\n                }\n            },\n        }\n    }\n}\n\nfn glob_literal_prefix(glob: &Path) -> PathBuf {\n    glob.components()\n        .take_while(|component| match component {\n            path::Component::Normal(part) => !part.to_string_lossy().contains(['*', '?', '{', '}']),\n            _ => true,\n        })\n        .collect()\n}\n\npub struct SshLspAdapter {\n    name: LanguageServerName,\n    binary: LanguageServerBinary,\n    initialization_options: Option<String>,\n    code_action_kinds: Option<Vec<CodeActionKind>>,\n}\n\nimpl SshLspAdapter {\n    pub fn new(\n        name: LanguageServerName,\n        binary: LanguageServerBinary,\n        initialization_options: Option<String>,\n        code_action_kinds: Option<String>,\n    ) -> Self {\n        Self {\n            name,\n            binary,\n            initialization_options,\n            code_action_kinds: code_action_kinds\n                .as_ref()\n                .and_then(|c| serde_json::from_str(c).ok()),\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl LspAdapter for SshLspAdapter {\n    fn name(&self) -> LanguageServerName {\n        self.name.clone()\n    }\n\n    async fn initialization_options(\n        self: Arc<Self>,\n        _: &dyn Fs,\n        _: &Arc<dyn LspAdapterDelegate>,\n    ) -> Result<Option<serde_json::Value>> {\n        let Some(options) = &self.initialization_options else {\n            return Ok(None);\n        };\n        let result = serde_json::from_str(options)?;\n        Ok(result)\n    }\n\n    fn code_action_kinds(&self) -> Option<Vec<CodeActionKind>> {\n        self.code_action_kinds.clone()\n    }\n\n    async fn check_if_user_installed(\n        &self,\n        _: &dyn LspAdapterDelegate,\n        _: Arc<dyn LanguageToolchainStore>,\n        _: &AsyncApp,\n    ) -> Option<LanguageServerBinary> {\n        Some(self.binary.clone())\n    }\n\n    async fn cached_server_binary(\n        &self,\n        _: PathBuf,\n        _: &dyn LspAdapterDelegate,\n    ) -> Option<LanguageServerBinary> {\n        None\n    }\n\n    async fn fetch_latest_server_version(\n        &self,\n        _: &dyn LspAdapterDelegate,\n    ) -> Result<Box<dyn 'static + Send + Any>> {\n        anyhow::bail!(": "",
    ")\n    }\n\n    async fn fetch_server_binary(\n        &self,\n        _: Box<dyn 'static + Send + Any>,\n        _: PathBuf,\n        _: &dyn LspAdapterDelegate,\n    ) -> Result<LanguageServerBinary> {\n        anyhow::bail!(": "",
    ")\n    }\n}\n\npub fn language_server_settings<'a>(\n    delegate: &'a dyn LspAdapterDelegate,\n    language: &LanguageServerName,\n    cx: &'a App,\n) -> Option<&'a LspSettings> {\n    language_server_settings_for(\n        SettingsLocation {\n            worktree_id: delegate.worktree_id(),\n            path: delegate.worktree_root_path(),\n        },\n        language,\n        cx,\n    )\n}\n\npub(crate) fn language_server_settings_for<'a>(\n    location: SettingsLocation<'a>,\n    language: &LanguageServerName,\n    cx: &'a App,\n) -> Option<&'a LspSettings> {\n    ProjectSettings::get(Some(location), cx).lsp.get(language)\n}\n\npub struct LocalLspAdapterDelegate {\n    lsp_store: WeakEntity<LspStore>,\n    worktree: worktree::Snapshot,\n    fs: Arc<dyn Fs>,\n    http_client: Arc<dyn HttpClient>,\n    language_registry: Arc<LanguageRegistry>,\n    load_shell_env_task: Shared<Task<Option<HashMap<String, String>>>>,\n}\n\nimpl LocalLspAdapterDelegate {\n    pub fn new(\n        language_registry: Arc<LanguageRegistry>,\n        environment: &Entity<ProjectEnvironment>,\n        lsp_store: WeakEntity<LspStore>,\n        worktree: &Entity<Worktree>,\n        http_client: Arc<dyn HttpClient>,\n        fs: Arc<dyn Fs>,\n        cx: &mut App,\n    ) -> Arc<Self> {\n        let load_shell_env_task = environment.update(cx, |env, cx| {\n            env.get_worktree_environment(worktree.clone(), cx)\n        });\n\n        Arc::new(Self {\n            lsp_store,\n            worktree: worktree.read(cx).snapshot(),\n            fs,\n            http_client,\n            language_registry,\n            load_shell_env_task,\n        })\n    }\n\n    fn from_local_lsp(\n        local: &LocalLspStore,\n        worktree: &Entity<Worktree>,\n        cx: &mut App,\n    ) -> Arc<Self> {\n        Self::new(\n            local.languages.clone(),\n            &local.environment,\n            local.weak.clone(),\n            worktree,\n            local.http_client.clone(),\n            local.fs.clone(),\n            cx,\n        )\n    }\n}\n\n#[async_trait]\nimpl LspAdapterDelegate for LocalLspAdapterDelegate {\n    fn show_notification(&self, message: &str, cx: &mut App) {\n        self.lsp_store\n            .update(cx, |_, cx| {\n                cx.emit(LspStoreEvent::Notification(message.to_owned()))\n            })\n            .ok();\n    }\n\n    fn http_client(&self) -> Arc<dyn HttpClient> {\n        self.http_client.clone()\n    }\n\n    fn worktree_id(&self) -> WorktreeId {\n        self.worktree.id()\n    }\n\n    fn worktree_root_path(&self) -> &Path {\n        self.worktree.abs_path().as_ref()\n    }\n\n    async fn shell_env(&self) -> HashMap<String, String> {\n        let task = self.load_shell_env_task.clone();\n        task.await.unwrap_or_default()\n    }\n\n    async fn npm_package_installed_version(\n        &self,\n        package_name: &str,\n    ) -> Result<Option<(PathBuf, String)>> {\n        let local_package_directory = self.worktree_root_path();\n        let node_modules_directory = local_package_directory.join(": "",
    ");\n\n        if let Some(version) =\n            read_package_installed_version(node_modules_directory.clone(), package_name).await?\n        {\n            return Ok(Some((node_modules_directory, version)));\n        }\n        let Some(npm) = self.which(": "",
    ".as_ref()).await else {\n            log::warn!(\n                ": "",
    ",\n                local_package_directory\n            );\n            return Ok(None);\n        };\n\n        let env = self.shell_env().await;\n        let output = util::command::new_smol_command(&npm)\n            .args([": "",
    "])\n            .envs(env)\n            .current_dir(local_package_directory)\n            .output()\n            .await?;\n        let global_node_modules =\n            PathBuf::from(String::from_utf8_lossy(&output.stdout).to_string());\n\n        if let Some(version) =\n            read_package_installed_version(global_node_modules.clone(), package_name).await?\n        {\n            return Ok(Some((global_node_modules, version)));\n        }\n        return Ok(None);\n    }\n\n    #[cfg(not(target_os = ": "",
    "))]\n    async fn which(&self, command: &OsStr) -> Option<PathBuf> {\n        let worktree_abs_path = self.worktree.abs_path();\n        let shell_path = self.shell_env().await.get(": "",
    ").cloned();\n        which::which_in(command, shell_path.as_ref(), worktree_abs_path).ok()\n    }\n\n    #[cfg(target_os = ": "",
    ")]\n    async fn which(&self, command: &OsStr) -> Option<PathBuf> {\n        // todo(windows) Getting the shell env variables in a current directory on Windows is more complicated than other platforms\n        //               there isn't a 'default shell' necessarily. The closest would be the default profile on the windows terminal\n        //               SEE: https://learn.microsoft.com/en-us/windows/terminal/customize-settings/startup\n        which::which(command).ok()\n    }\n\n    async fn try_exec(&self, command: LanguageServerBinary) -> Result<()> {\n        let working_dir = self.worktree_root_path();\n        let output = util::command::new_smol_command(&command.path)\n            .args(command.arguments)\n            .envs(command.env.clone().unwrap_or_default())\n            .current_dir(working_dir)\n            .output()\n            .await?;\n\n        anyhow::ensure!(\n            output.status.success(),\n            ": "",
    ",\n            output.status,\n            String::from_utf8_lossy(&output.stdout),\n            String::from_utf8_lossy(&output.stderr)\n        );\n        Ok(())\n    }\n\n    fn update_status(&self, server_name: LanguageServerName, status: language::BinaryStatus) {\n        self.language_registry\n            .update_lsp_status(server_name, status);\n    }\n\n    fn registered_lsp_adapters(&self) -> Vec<Arc<dyn LspAdapter>> {\n        self.language_registry\n            .all_lsp_adapters()\n            .into_iter()\n            .map(|adapter| adapter.adapter.clone() as Arc<dyn LspAdapter>)\n            .collect()\n    }\n\n    async fn language_server_download_dir(&self, name: &LanguageServerName) -> Option<Arc<Path>> {\n        let dir = self.language_registry.language_server_download_dir(name)?;\n\n        if !dir.exists() {\n            smol::fs::create_dir_all(&dir)\n                .await\n                .context(": "",
    ")\n                .log_err()?;\n        }\n\n        Some(dir)\n    }\n\n    async fn read_text_file(&self, path: PathBuf) -> Result<String> {\n        let entry = self\n            .worktree\n            .entry_for_path(&path)\n            .with_context(|| format!(": "",
    "))?;\n        let abs_path = self\n            .worktree\n            .absolutize(&entry.path)\n            .with_context(|| format!(": "",
    "))?;\n\n        self.fs.load(&abs_path).await\n    }\n}\n\nasync fn populate_labels_for_symbols(\n    symbols: Vec<CoreSymbol>,\n    language_registry: &Arc<LanguageRegistry>,\n    lsp_adapter: Option<Arc<CachedLspAdapter>>,\n    output: &mut Vec<Symbol>,\n) {\n    #[allow(clippy::mutable_key_type)]\n    let mut symbols_by_language = HashMap::<Option<Arc<Language>>, Vec<CoreSymbol>>::default();\n\n    let mut unknown_paths = BTreeSet::new();\n    for symbol in symbols {\n        let language = language_registry\n            .language_for_file_path(&symbol.path.path)\n            .await\n            .ok()\n            .or_else(|| {\n                unknown_paths.insert(symbol.path.path.clone());\n                None\n            });\n        symbols_by_language\n            .entry(language)\n            .or_default()\n            .push(symbol);\n    }\n\n    for unknown_path in unknown_paths {\n        log::info!(\n            ": "",
    ",\n            unknown_path.display()\n        );\n    }\n\n    let mut label_params = Vec::new();\n    for (language, mut symbols) in symbols_by_language {\n        label_params.clear();\n        label_params.extend(\n            symbols\n                .iter_mut()\n                .map(|symbol| (mem::take(&mut symbol.name), symbol.kind)),\n        );\n\n        let mut labels = Vec::new();\n        if let Some(language) = language {\n            let lsp_adapter = lsp_adapter.clone().or_else(|| {\n                language_registry\n                    .lsp_adapters(&language.name())\n                    .first()\n                    .cloned()\n            });\n            if let Some(lsp_adapter) = lsp_adapter {\n                labels = lsp_adapter\n                    .labels_for_symbols(&label_params, &language)\n                    .await\n                    .log_err()\n                    .unwrap_or_default();\n            }\n        }\n\n        for ((symbol, (name, _)), label) in symbols\n            .into_iter()\n            .zip(label_params.drain(..))\n            .zip(labels.into_iter().chain(iter::repeat(None)))\n        {\n            output.push(Symbol {\n                language_server_name: symbol.language_server_name,\n                source_worktree_id: symbol.source_worktree_id,\n                source_language_server_id: symbol.source_language_server_id,\n                path: symbol.path,\n                label: label.unwrap_or_else(|| CodeLabel::plain(name.clone(), None)),\n                name,\n                kind: symbol.kind,\n                range: symbol.range,\n                signature: symbol.signature,\n            });\n        }\n    }\n}\n\nfn include_text(server: &lsp::LanguageServer) -> Option<bool> {\n    match server.capabilities().text_document_sync.as_ref()? {\n        lsp::TextDocumentSyncCapability::Kind(kind) => match *kind {\n            lsp::TextDocumentSyncKind::NONE => None,\n            lsp::TextDocumentSyncKind::FULL => Some(true),\n            lsp::TextDocumentSyncKind::INCREMENTAL => Some(false),\n            _ => None,\n        },\n        lsp::TextDocumentSyncCapability::Options(options) => match options.save.as_ref()? {\n            lsp::TextDocumentSyncSaveOptions::Supported(supported) => {\n                if *supported {\n                    Some(true)\n                } else {\n                    None\n                }\n            }\n            lsp::TextDocumentSyncSaveOptions::SaveOptions(save_options) => {\n                Some(save_options.include_text.unwrap_or(false))\n            }\n        },\n    }\n}\n\n/// Completion items are displayed in a `UniformList`.\n/// Usually, those items are single-line strings, but in LSP responses,\n/// completion items `label`, `detail` and `label_details.description` may contain newlines or long spaces.\n/// Many language plugins construct these items by joining these parts together, and we may use `CodeLabel::fallback_for_completion` that uses `label` at least.\n/// All that may lead to a newline being inserted into resulting `CodeLabel.text`, which will force `UniformList` to bloat each entry to occupy more space,\n/// breaking the completions menu presentation.\n///\n/// Sanitize the text to ensure there are no newlines, or, if there are some, remove them and also remove long space sequences if there were newlines.\nfn ensure_uniform_list_compatible_label(label: &mut CodeLabel) {\n    let mut new_text = String::with_capacity(label.text.len());\n    let mut offset_map = vec![0; label.text.len() + 1];\n    let mut last_char_was_space = false;\n    let mut new_idx = 0;\n    let mut chars = label.text.char_indices().fuse();\n    let mut newlines_removed = false;\n\n    while let Some((idx, c)) = chars.next() {\n        offset_map[idx] = new_idx;\n\n        match c {\n            '\\n' if last_char_was_space => {\n                newlines_removed = true;\n            }\n            '\\t' | ' ' if last_char_was_space => {}\n            '\\n' if !last_char_was_space => {\n                new_text.push(' ');\n                new_idx += 1;\n                last_char_was_space = true;\n                newlines_removed = true;\n            }\n            ' ' | '\\t' => {\n                new_text.push(' ');\n                new_idx += 1;\n                last_char_was_space = true;\n            }\n            _ => {\n                new_text.push(c);\n                new_idx += c.len_utf8();\n                last_char_was_space = false;\n            }\n        }\n    }\n    offset_map[label.text.len()] = new_idx;\n\n    // Only modify the label if newlines were removed.\n    if !newlines_removed {\n        return;\n    }\n\n    let last_index = new_idx;\n    let mut run_ranges_errors = Vec::new();\n    label.runs.retain_mut(|(range, _)| {\n        match offset_map.get(range.start) {\n            Some(&start) => range.start = start,\n            None => {\n                run_ranges_errors.push(range.clone());\n                return false;\n            }\n        }\n\n        match offset_map.get(range.end) {\n            Some(&end) => range.end = end,\n            None => {\n                run_ranges_errors.push(range.clone());\n                range.end = last_index;\n            }\n        }\n        true\n    });\n    if !run_ranges_errors.is_empty() {\n        log::error!(\n            ": "",
    ",\n            label.text\n        );\n    }\n\n    let mut wrong_filter_range = None;\n    if label.filter_range == (0..label.text.len()) {\n        label.filter_range = 0..new_text.len();\n    } else {\n        let mut original_filter_range = Some(label.filter_range.clone());\n        match offset_map.get(label.filter_range.start) {\n            Some(&start) => label.filter_range.start = start,\n            None => {\n                wrong_filter_range = original_filter_range.take();\n                label.filter_range.start = last_index;\n            }\n        }\n\n        match offset_map.get(label.filter_range.end) {\n            Some(&end) => label.filter_range.end = end,\n            None => {\n                wrong_filter_range = original_filter_range.take();\n                label.filter_range.end = last_index;\n            }\n        }\n    }\n    if let Some(wrong_filter_range) = wrong_filter_range {\n        log::error!(\n            ": "",
    ",\n            label.text\n        );\n    }\n\n    label.text = new_text;\n}\n\n#[cfg(test)]\nmod tests {\n    use language::HighlightId;\n\n    use super::*;\n\n    #[test]\n    fn test_glob_literal_prefix() {\n        assert_eq!(glob_literal_prefix(Path::new(": "",
    ")), Path::new(": "",
    "));\n        assert_eq!(\n            glob_literal_prefix(Path::new(": "",
    ")),\n            Path::new(": "",
    ")\n        );\n        assert_eq!(\n            glob_literal_prefix(Path::new(": "",
    ")\n        );\n\n        #[cfg(target_os = ": "",
    ")]\n        {\n            assert_eq!(glob_literal_prefix(Path::new(": "",
    "));\n            assert_eq!(\n                glob_literal_prefix(Path::new(": "",
    ")),\n                Path::new(": "",
    ")\n            );\n            assert_eq!(\n                glob_literal_prefix(Path::new(": "",
    ")\n            );\n        }\n    }\n\n    #[test]\n    fn test_multi_len_chars_normalization() {\n        let mut label = CodeLabel {\n            text: ": "",
    ".to_string(),\n            runs: vec![(0..6, HighlightId(1))],\n            filter_range: 0..6,\n        };\n        ensure_uniform_list_compatible_label(&mut label);\n        assert_eq!(\n            label,\n            CodeLabel {\n                text: ": ""
  },
  "zed/crates/project/src/prettier_store.rs": {
    "Found already started prettier in {prettier_dir:?}": "",
    "Found prettier in {prettier_dir:?}, starting.": "",
    "Failed to determine prettier path for buffer: {e:#}": "",
    "Found prettier ignore in {ignore_dir:?}": "",
    "Failed to determine prettier ignore path for buffer: {e:#}": "",
    "Starting prettier at path {prettier_dir:?}": "",
    "default prettier spawn": "",
    "Default prettier is not installed and cannot be started": "",
    "Waiting for default prettier to install": "",
    "Cannot start default prettier due to its installation failure: {e:#}": "",
    "Started default prettier in {prettier_dir:?}": "",
    "Started prettier in {prettier_dir:?}": "",
    "prettier (default)": "",
    "prettier ({name})": "",
    "prettier ({})": "",
    "node_modules": "",
    "Prettier config file {config_path:?} changed, reloading prettier instances for worktree {current_worktree_id}": "",
    "Failed to clear prettier {prettier_path:?} cache for worktree {worktree_id:?} on prettier settings update: {e:#}": "",
    "Failed to clear default prettier cache for worktree {worktree_id:?} on prettier settings update: {e:#}": "",
    "test-support": "",
    "Default prettier installation had failed {installation_attempt} times, not attempting again": "",
    "Initializing default prettier with plugins {new_plugins:?}": "",
    "locate prettier installation": "",
    "Failed to install default prettier: {e:#}": "",
    "prettier & plugins install": "",
    "Initialized prettier with plugins: {installed_plugins:?}": "",
    "prettier at {path:?}": "",
    "default prettier instance": "",
    "{} failed to format buffer": "",
    "{prettier_description} failed to spawn: {error:#}": "",
    "Prettier from path {prettier_dir:?} exceeded launch threshold, not starting": "",
    "Default prettier exceeded launch threshold, not starting": "",
    "prettier": "",
    "fetching latest npm version for package {returned_package_name}": "",
    "fetching latest npm versions": "",
    "fetching FS metadata for default prettier dir {default_prettier_dir:?}": "",
    "default prettier dir {default_prettier_dir:?} is not a directory": "",
    "creating default prettier dir {default_prettier_dir:?}": "",
    "Installing default prettier and plugins: {packages_to_versions:?}": "",
    "fetching formatter packages": "",
    "writing {} file at {prettier_wrapper_path:?}": ""
  },
  "zed/crates/project/src/project_settings.rs": {
    "snake_case": "",
    "default_true": "",
    "default_lsp_diagnostics_pull_debounce_ms": "",
    "default_inline_diagnostics_update_debounce_ms": "",
    "default_inline_diagnostics_padding": "",
    "npm.packageManager": "",
    "npm": "",
    "yarn": "",
    "bun": "",
    "pnpm": "",
    "git.blame.editorDecoration.enabled": "",
    "mcp": "",
    "unknown kind {kind}": "",
    "Cannot absolutize {path:?} received as {change:?} FS change: {e}": "",
    "parsing VSCode tasks, file {abs_path:?}": "",
    "converting VSCode tasks into Zed ones, file {abs_path:?}": "",
    "serializing Zed tasks into JSON, file {abs_path:?}": "",
    "parsing VSCode debug tasks, file {abs_path:?}": "",
    "converting VSCode debug tasks into Zed ones, file {abs_path:?}": "",
    "Failed to set local settings in {path:?}: {message}": "",
    "Failed to set local settings: {e}": "",
    "Failed to set local tasks in {path:?}: {message:?}": "",
    "Failed to set local tasks: {e}": "",
    "Failed to set local debug scenarios in {path:?}: {message:?}": ""
  },
  "zed/crates/project/src/project.rs": {
    "test-support": "",
    "RemotelyCreatedModelGuard dropped too many times": "",
    "": "",
    "Completion": "",
    "replace_range": "",
    "new_text": "",
    "label": "",
    "documentation": "",
    "source": "",
    "Unknown command": "",
    "command": "",
    "code lens": "",
    "DirectoryLister::Project({project:?})": "",
    "DirectoryLister::Local({project:?})": "",
    "windows": "",
    "C:{separator}": "",
    "~{separator}": "",
    "No worktree for path {project_path:?}": "",
    "No worktree for entry {entry_id:?}": "",
    "no task": "",
    "project was already shared": "",
    "attempted to unshare a remote project": "",
    "attempted to unshare an unshared project": "",
    "called create_local_buffer on a remote project": "",
    "no such path": "",
    "buffer {id} does not exist": "",
    "cannot open buffer while disconnected": "",
    "Project dropped": "",
    "dap": "",
    "lsp": "",
    "Failed to set local settings in {path:?}:\\n{message}": "",
    "local-settings-{path:?}": "",
    "Failed to set local tasks in {path:?}:\\n{message}": "",
    "local-tasks-{path:?}": "",
    "not an ssh project": "",
    "Inline value provider not found": "",
    "~": "",
    "cannot list directory in remote project": "",
    "empty collaborator": "",
    "missing old peer id": "",
    "missing new peer id": "",
    "received UpdateProjectCollaborator for unknown peer": "",
    "peer {} became {}": "",
    "invalid peer id": "",
    "unknown peer {peer_id:?}": "",
    "Invalid prompt level": "",
    "missing query field": "",
    "can't synchronize remote buffers on a readonly project": "",
    "can't synchronize remote buffers on a local project": "",
    "{}{}": ""
  },
  "zed/crates/project/src/search_history.rs": {
    "No current selection should be set for the default search history": "",
    "rust": "",
    "Newly added item should be selected": "",
    "Should not add a duplicate": "",
    "rustlang": "",
    "Should replace previous item if it's a substring": "",
    "item{i}": "",
    "Default search history should not have a next item": "",
    "Rust": "",
    "JavaScript": "",
    "TypeScript": "",
    "Should start from the end after reset on previous item query": "",
    "Python": "",
    "Java": "",
    "C++": ""
  },
  "zed/crates/project/src/search.rs": {
    "\\B": "",
    "Failed to create WORD_MATCH_TEST": "",
    "\\\\b": "",
    "\\\\n": "",
    ",": "",
    "\\\\\\\\|\\\\n|\\\\t": "",
    "\\\\": "",
    "\\n": "",
    "\\t": "",
    "Unexpected escape sequence: {}": "",
    "file": "",
    "Cargo.toml": "",
    ".DS_Store": "",
    "~/dir/another_dir/": "",
    "./dir/file": "",
    "dir/[a-z].txt": "",
    "../dir/filé": "",
    "Valid path {valid_path} should be accepted, but got: {e}": "",
    "Path matcher for valid path {valid_path} should match itself": "",
    "dir/[].txt": "",
    "dir/[a-z.txt": "",
    "dir/{file": "",
    "Invalid glob {invalid_glob} should not be accepted": "",
    "dir/?ile": "",
    "dir/*.txt": "",
    "dir/**/file": "",
    "{dir,file}": "",
    "Valid glob should be accepted, but got: {e}": ""
  },
  "zed/crates/project/src/task_inventory.rs": {
    "Inventory": "",
    "last_scheduled_tasks": "",
    "last_scheduled_scenarios": "",
    "templates_from_settings": "",
    "scenarios_from_settings": "",
    "tasks.json": "",
    "tasks": "",
    "debug.json": "",
    "debug scenarios": "",
    "local worktree {} from directory {directory:?}": "",
    "global {}": "",
    "oneshot": "",
    "{id_base}_{}": "",
    "{id_base}_{id}_{}": "",
    "language_{name}": "",
    "lsp_{language_name}_{server}": "",
    "usage": "",
    "[]": "",
    "Failed to parse tasks file content as a JSON array: {e}": "",
    "Failed to find task with name {task_name}": "",
    "Failed to resolve task with name {task_name}": "",
    ".": "",
    "No tasks expected for empty inventory, but got {initial_tasks:?}": "",
    "1_a_task": "",
    "1_task": "",
    "2_task": "",
    "3_task": "",
    "Tasks with equal amount of usages should be sorted alphanumerically": "",
    "Most recently used task should be at the top": "",
    "foo": "",
    "worktree_task_1": "",
    "Most recently used worktree task should be at the top": "",
    "10_hello": "",
    "11_hello": "",
    "After global tasks update, worktree task usage is not erased and it's the first still; global task is back to regular order as its file was updated": "",
    "": "",
    "\n                        [{\n                            ": "",
    ": ": "",
    ",\n                            ": "",
    ",\n                        }]\n                        ": "",
    "Delve": "",
    "common_task_name": "",
    "global tasks.json": "",
    "static_source_1": "",
    "static_source_2": "",
    ".zed": "",
    "local worktree tasks from directory \\\".zed\\\"": "",
    "worktree_1": "",
    "worktree_2": "",
    "Without a worktree, only worktree-independent tasks should be listed": "",
    "label": "",
    "command": "",
    "echo": "",
    "args": ""
  },
  "zed/crates/project/src/task_store.rs": {
    "no location given for task context handling": "",
    "empty task store cannot handle task context requests": "",
    "no buffer store when handling task context request": "",
    "cannot handle task context request for invalid buffer id: {}": "",
    "missing task context location start": "",
    "missing task context location end": "",
    "no local buffer with id {buffer_id}": "",
    "Unknown variable name: {variable_name}": "",
    "building basic default context": "",
    "building provider context": ""
  },
  "zed/crates/project/src/terminals.rs": {
    "-L": "",
    "{}:{}:{}": "",
    "Connecting to a remote server: {ssh_command:?}": "",
    "TERM": "",
    "xterm-256color": "",
    "{} — Terminal": "",
    "VIRTUAL_ENV": "",
    "bin": "",
    "Python": "",
    "windows": "",
    "Scripts": "",
    ".": "",
    "source": "",
    "overlay use": "",
    "activate": "",
    "activate.csh": "",
    "activate.fish": "",
    "activate.nu": "",
    "activate.ps1": "",
    "\\r": "",
    "\\n": "",
    "{} {} ; clear{}": "",
    "${SHELL:-sh}": "",
    " ": "",
    "exec ${SHELL:-sh} -l": "",
    "{}={} ": "",
    "PATH={}:$PATH ": "",
    "~/": "",
    "/": "",
    "~": "",
    "cd \\\"$HOME/{trimmed_path}\\\"; {env_changes} {to_run}": "",
    "cd {path:?}; {env_changes} {to_run}": "",
    "cd; {env_changes} {to_run}": "",
    "sh -c {}": "",
    "ssh": "",
    "-t": "",
    "PATH": "",
    "failed to create PATH env variable": "",
    "/tmp/new": "",
    "/usr/bin;/usr/local/bin": "",
    "/usr/bin:/usr/local/bin": "",
    "OTHER": "",
    "aaa": "",
    "/tmp/new;{}": "",
    "/tmp/new:{}": ""
  },
  "zed/crates/project/src/toolchain_store.rs": {
    "Missing `toolchain` in payload": "",
    "": ""
  },
  "zed/crates/project/src/worktree_store.rs": {
    "cannot create worktrees via collab": "",
    "/~": "",
    "~/": "",
    "Dropped worktree store": "",
    "invalid project": "",
    "Missing worktree for id {source}": "",
    "Missing worktree for id {destination}": "",
    "listing ignored path {abs_path:?}": "",
    "fetching fs metadata for {abs_path:?}": "",
    "obviously binary": "",
    "Invalid UTF-8 sequence in file {abs_path:?} at byte position {starting_position}": "",
    "worktree not found": "",
    "invalid request": ""
  },
  "zed/crates/project_panel/src/project_panel.rs": {
    "ProjectPanel": "",
    "Failed to open file": "",
    "Disconnected from SSH host": "",
    "Disconnected from remote project": "",
    "{} is not shared by the host. This could be because it has been marked as `private`": "",
    "Try Again": "",
    "File is too large to load": "",
    "loading project panel": "",
    "{}-{:?}": "",
    "windows": "",
    "Search Inside": "",
    "New File": "",
    "New Folder": "",
    "macos": "",
    "Reveal in Finder": "",
    "Reveal in File Manager": "",
    "Open in Default App": "",
    "Open in Terminal": "",
    "Find in Folder…": "",
    "Unfold Directory": "",
    "Fold Directory": "",
    "Cut": "",
    "Copy": "",
    "Duplicate": "",
    "Paste": "",
    "Copy Path": "",
    "Copy Relative Path": "",
    "Rename": "",
    "Trash": "",
    "Delete": "",
    "Add Folder to Project…": "",
    "Remove from Project": "",
    "Collapse All": "",
    "File or directory '{}' already exists at location. Please choose a different name.": "",
    "File or directory name cannot be empty.": "",
    "File or directory name contains leading or trailing whitespace.": "",
    "/": "",
    "\\\\": "",
    "excluded-directory": "",
    "Created an excluded directory at {abs_path:?}.\\nAlter `file_scan_exclusions` in the settings to show it in the panel": "",
    "\\n\\nIt has unsaved changes, which will be lost.": "",
    "": "",
    "{operation} {path}?{unsaved_warning}": "",
    ".. 1 file not shown": "",
    ".. {} files not shown": "",
    "\\n\\n1 of these has unsaved changes, which will be lost.": "",
    "\\n\\n{dirty_buffers} of these have unsaved changes, which will be lost.": "",
    "Do you want to {} the following {} files?\\n{}{unsaved_warning}": "",
    "\\n": "",
    "Cancel": "",
    "no such entry": "",
    " copy": "",
    " {}": "",
    ".": "",
    "\\0": "",
    "Non-root entry has no file name: {entry:?}": "",
    "A file or folder with name {filename} already exists in the destination folder. Do you want to replace it?": "",
    "Replace": "",
    "failed to copy external paths": "",
    "Edited sub-entry should be an ancestor of selected leaf entry": "",
    "project_entry": "",
    "symlink_icon": "",
    "Symbolic Link": "",
    "project_panel_path_component_{}_{index}": "",
    "project-panel-vertical-scroll": "",
    "project-panel-horizontal-scroll": "",
    "menu": "",
    "editing": "",
    "not_editing": "",
    "can't reveal a non-existent entry in the project panel": "",
    "can't reveal an ignored entry in the project panel": "",
    "project-panel": "",
    "entries": "",
    "empty-project_panel": "",
    "open_project": "",
    "Open a project": "",
    "{} entries": "",
    "Project Panel": ""
  },
  "zed/crates/recent_projects/src/disconnected_overlay.rs": {
    "Failed to reconnect": "",
    "Your connection to the remote project has been lost.": "",
    "\\nUnsaved changes are stored locally.": "",
    "": "",
    "Your connection to {} has been lost.{}": "",
    "disconnected": "",
    "Disconnected": "",
    "close-window": "",
    "Close Window": "",
    "reconnect": "",
    "Reconnect": ""
  },
  "zed/crates/recent_projects/src/recent_projects.rs": {
    "{reuse_window} reuses this window, {create_window} opens a new one": "",
    "": "",
    "Recently opened projects will show up here": "",
    "No matches": "",
    ", ": "",
    "delete": "",
    "Delete from Recent Projects...": "",
    "remote": "",
    "Open Remote Folder": "",
    "local": "",
    "Open Local Folder": "",
    "/dir": "",
    "main.ts": "",
    "a": "",
    "/dir/main.ts": "",
    "EDIT": "",
    "After inserting more text into the editor without saving, we should have a dirty project": "",
    "fake candidate": "",
    "/test/path/": "",
    "Should have no pending prompt on dirty project before opening the new recent project": "",
    "Should remove the modal after selecting new recent project": "",
    "Dirty workspace should prompt before opening the new recent project": "",
    "Cancel": "",
    "Should have no pending prompt after cancelling": "",
    "Should be in the same dirty project after cancelling": ""
  },
  "zed/crates/recent_projects/src/remote_servers.rs": {
    "Add a nickname for this server": "",
    "SSH Project Created": "",
    "could not parse: {:?}": "",
    "Failed to connect": "",
    "SSH Server Created": "",
    "~": "",
    "/": "",
    "({})": "",
    "ssh-server": "",
    "No projects.": "",
    "new-remote-project-container": "",
    "new-remote-project": "",
    "Open Folder": "",
    "server-options-container": "",
    "server-options": "",
    "View Server Options": "",
    "remote-project-{server_ix}": "",
    "remote-project-container-{element_id_base}": "",
    "Failed to connect: {e:#}": "",
    "Ok": "",
    ", ": "",
    "remove-remote-project": "",
    "Delete Remote Project": "",
    "ssh user@example -p 2222": "",
    "create-remote-server": "",
    "Enter the command you use to SSH into this server.": "",
    "learn-more": "",
    "Learn more…": "",
    "https://zed.dev/docs/remote-development": "",
    "Edit Nickname": "",
    "Add Nickname to Server": "",
    "ssh-options-add-nickname": "",
    "add-nickname": "",
    "Copied server address ({}) to clipboard": "",
    "ssh-options-copy-server-address": "",
    "copy-server-address": "",
    "Copy Server Address": "",
    "Remove server `{}`?": "",
    "Yes, remove it": "",
    "No, keep it": "",
    "remove-server": "",
    "Remove Server": "",
    "go-back": "",
    "Go Back": "",
    "ssh-edit-nickname": "",
    "ssh-connect-new-server-container": "",
    "register-remove-server-button": "",
    "Connect New Server": "",
    "ssh-server-list": "",
    "No remote servers registered yet.": "",
    "{reuse_window} reuses this window, {create_window} opens a new one": "",
    "remote-projects": "",
    "Remote Projects": "",
    "RemoteServerModal": ""
  },
  "zed/crates/recent_projects/src/ssh_connections.rs": {
    "default_true": "",
    "Option::is_none": "",
    "Vec::is_empty": "",
    "yes/no": "",
    "Connecting": "",
    "PasswordPrompt": "",
    "arrow-circle": "",
    "{}…": "",
    "({})": "",
    "SshConnectionModal": "",
    "Downloading remote server binary (version: {}, os: {}, arch: {})": "",
    "{}": "",
    "unknown": "",
    "fetching ssh workspace position from db": "",
    "Failed to open project: {e:?}": "",
    "Failed to connect over SSH": "",
    "Retry": "",
    "Ok": ""
  },
  "zed/crates/refineable/derive_refineable/src/derive_refineable.rs": {
    "refineable": "",
    "Debug": "",
    "Serialize": "",
    "{}Refinement": "",
    "This derive macro only supports structs with named fields": "",
    "::refineable::IsEmpty::is_empty": "",
    "::std::option::Option::is_none": "",
    "Option": "",
    "Expected struct type for a refineable field": ""
  },
  "zed/crates/repl/src/components/kernel_options.rs": {
    "...{}": "",
    "Select a kernel...": "",
    "Jupyter": "",
    "Python Env": "",
    "Remote": "",
    "kernel-docs": "",
    "Kernel Docs": "",
    "kernel-switcher": ""
  },
  "zed/crates/repl/src/kernels/native_kernel.rs": {
    "Empty argv in kernelspec {}": "",
    "Invalid argv in kernelspec {}": "",
    "{connection_file}": "",
    "Missing 'connection_file' in argv in kernelspec {}": "",
    "RunningKernel": "",
    "process": "",
    "hmac-sha256": "",
    "zed-{}": "",
    "Failed to create jupyter runtime dir {runtime_dir:?}": "",
    "kernel-zed-{entity_id}.json": "",
    "failed to start the kernel process": "",
    "": "",
    "kernel: {}": "",
    "kernel process exited successfully": "",
    "kernel process exited with status: {:?}": "",
    "kernel process exited with error: {:?}": "",
    "{}": "",
    "killing the kernel process": "",
    "Invalid kernelspec directory: {path:?}": "",
    "Not a directory: {path:?}": "",
    "kernel.json": "",
    "Error reading kernelspec directory: {err:?}": "",
    "CONDA_PREFIX": "",
    "share": "",
    "jupyter": "",
    "python": "",
    "-c": "",
    "import sys; print(sys.prefix)": "",
    "kernels": "",
    "/jupyter": "",
    ".zed": "",
    "settings.json": "",
    "{ ": "",
    ": 8 }": "",
    "tasks.json": "",
    "[{\n                        ": "",
    ": ": "",
    ",\n                        ": "",
    ": [": "",
    ", ": "",
    "]\n                    },]": "",
    "{\n                            ": "",
    ",\n                            ": "",
    "],\n                            ": "",
    ": {}\n                        }": "",
    "deno": "",
    "/jupyter/kernels": ""
  },
  "zed/crates/repl/src/kernels/remote_kernels.rs": {
    "POST": "",
    "/kernels": "",
    "Authorization": "",
    "token {}": "",
    "Failed to launch kernel: {body}": "",
    "/kernelspecs": "",
    "GET": "",
    "Failed to fetch kernel specs: {}": "",
    "No kernel specs found": "",
    "{}/api/kernels/{}/channels?token={}": "",
    "http": "",
    "ws": "",
    "User-Agent": "",
    "Zed/{} ({}; {})": "",
    "repl": "",
    "Error receiving message: {:?}": "",
    "RemoteRunningKernel": "",
    "remote_server url": "",
    "working_directory": "",
    "request_tx": "",
    "execution_state": "",
    "kernel_info": "",
    "/kernels/{}": "",
    "DELETE": "",
    "Failed to shutdown kernel: {}": ""
  },
  "zed/crates/repl/src/notebook/notebook_ui.rs": {
    "LOCAL_NOTEBOOK_DEV": "",
    "Cells would all run here, if that was implemented!": "",
    "Open notebook triggered": "",
    "Move cell up triggered": "",
    "Move cell down triggered": "",
    "Add markdown block triggered": "",
    "Add code block triggered": "",
    "run-all-cells": "",
    "Execute all cells": "",
    "clear-all-outputs": "",
    "Clear all outputs": "",
    "move-cell-up": "",
    "Move cell up": "",
    "move-cell-down": "",
    "Move cell down": "",
    "new-markdown-cell": "",
    "Add markdown block": "",
    "new-code-cell": "",
    "Add code block": "",
    "more-menu": "",
    "repl": "",
    "notebook": "",
    "notebook-cells": "",
    "ipynb": "",
    "finding the absolute path of {path:?}": "",
    "Failed to parse notebook: {:?}": "",
    "Entry not found": "",
    "notebook controls": "",
    "save() must be implemented if can_save() returns true": "",
    "save_as() must be implemented if can_save() returns true": "",
    "reload() must be implemented if can_save() returns true": ""
  },
  "zed/crates/repl/src/outputs/image.rs": {
    "": "",
    "unsupported image format {format:?}": ""
  },
  "zed/crates/repl/src/outputs.rs": {
    "copy-output": "",
    "Copy Output": "",
    "open-in-buffer": "",
    "Open in Buffer": "",
    "REPL Output": "",
    "Failed to load image: {}": "",
    "Unsupported media type": "",
    "the output": "",
    "\\n": "",
    "Connecting to kernel...": "",
    "arrow-circle": "",
    "Executing...": "",
    "Unknown status": "",
    "Kernel shutting down...": "",
    "Kernel restarting...": "",
    "Kernel shutdown": "",
    "Queued...": "",
    "Kernel error: {}": ""
  },
  "zed/crates/repl/src/repl_editor.rs": {
    "editor is not in a worktree": "",
    "editor was dropped": "",
    "No kernel found for language: {}": "",
    "{comment_prefix}%%": "",
    "Markdown": "",
    "python": "",
    "Python": "",
    "TestLang": "",
    "# ": "",
    "\n                    print(1 + 1)\n                    print(2 + 2)\n\n                    print(4 + 4)\n\n\n                ": "",
    "print(1 + 1)": "",
    "\n                print(1 + 1)\n                print(2 + 2)": "",
    "\n                print(1 + 1)\n                print(2 + 2)\n\n                print(4 + 4)": "",
    "\n                    # Hello!\n                    # %% [markdown]\n                    # This is some arithmetic\n                    print(1 + 1)\n                    print(2 + 2)\n\n                    # %%\n                    print(3 + 3)\n                    print(4 + 4)\n\n                    print(5 + 5)\n\n\n\n                ": "",
    "\n                # %% [markdown]\n                # This is some arithmetic\n                print(1 + 1)\n                print(2 + 2)": "",
    "\n                    # %% [markdown]\n                    # This is some arithmetic\n                    print(1 + 1)\n                    print(2 + 2)": "",
    "\n                    # %%\n                    print(3 + 3)\n                    print(4 + 4)\n\n                    print(5 + 5)": "",
    "typescript": "",
    "TypeScript": "",
    "markdown": "",
    "\n                    Hey this is Markdown!\n\n                    ```typescript\n                    let foo = 999;\n                    console.log(foo + 1999);\n                    ```\n\n                    ```typescript\n                    console.log(": "",
    ")\n                    ```\n                    ": "",
    "\n                    let foo = 999;\n                    console.log(foo + 1999);\n                    ": "",
    "console.log(\\\"foo\\\")\\n": "",
    "\n                    Hey this is Markdown!\n\n                    ```typescript\n                    let foo = 999;\n                    console.log(foo + 1999);\n                    ```\n\n                    ```ts\n                    console.log(": "",
    ")\n                    ```\n\n                    ```typescript\n                    console.log(": "",
    ")\n                    ```\n                ": "",
    "console.log(\\\"another code block\\\")\\n": "",
    "\n                    Hey this is Markdown!\n\n                    ```python\n                    print(": "",
    ")\n                    print(": "",
    "\n                print(": "",
    ")\n                print(": "",
    ")\n                ": ""
  },
  "zed/crates/repl/src/repl_sessions_ui.rs": {
    "Python": "",
    "REPL Sessions": "",
    "REPL Session Started": "",
    "To start interactively running code in your editor, you need to install and configure Jupyter kernels.": "",
    "No Jupyter Kernels Available": "",
    "install-kernels": "",
    "Install Kernels": "",
    "https://zed.dev/docs/repl#language-specific-instructions": "",
    "To run code in a Jupyter kernel, select some code and use the 'repl::Run' command.": "",
    "No Jupyter Kernel Sessions": "",
    "Jupyter Kernel Sessions": ""
  },
  "zed/crates/repl/src/repl_store.rs": {
    "repl": "",
    "getting python kernelspecs": "",
    "JUPYTER_SERVER": "",
    "JUPYTER_TOKEN": ""
  },
  "zed/crates/repl/src/session.rs": {
    "editor is not open": "",
    "workspace dropped": "",
    "\\n": "",
    "close_output_area": "",
    "Close output area": "",
    "Kernel Status Changed": "",
    "restarting kernel": "",
    "interrupt": "",
    "Interrupt": "",
    "Starting": "",
    "Error: {err}": "",
    "Shutting Down": "",
    "Shutdown": "",
    "Restarting": "",
    "({status_text})": "",
    "shutdown": ""
  },
  "zed/crates/reqwest_client/src/reqwest_client.rs": {
    "key=[^&]+": "",
    "Failed to initialize HTTP client": "",
    "Failed to parse proxy URL '{}': {}": "",
    "no tokio runtime found, creating one for Reqwest...": "",
    "key=REDACTED": "",
    "http://localhost:10809": "",
    "test": "",
    "https://localhost:10809": "",
    "socks4://localhost:10808": "",
    "socks4a://localhost:10808": "",
    "socks5://localhost:10808": "",
    "socks5h://localhost:10808": "",
    "socks://127.0.0.1:20170": "",
    "An invalid proxy URL should add no proxy to the client!": ""
  },
  "zed/crates/rope/src/chunk.rs": {
    "": "",
    "point {:?} extends beyond rows for string {:?}": "",
    "point {:?} extends beyond row for string {:?}": "",
    "point {:?} is beyond this chunk's extent {:?}": "",
    "point {:?} is beyond the end of the line in chunk {:?}": "",
    "point {:?} is within character in chunk {:?}": "",
    "Chunk: {:?}": "",
    "Range: {:?}": "",
    "nth_set_bit({:0128b}, {})": "",
    "Verifying chunk {:?}": "",
    "mismatch at offset {}": "",
    "mismatch at point {:?}": "",
    "mismatch at offset_utf16 {:?}": "",
    "mismatch at point_utf16 {:?}": "",
    "mismatch for unclipped_point_utf16_to_point at {:?}": "",
    "incorrect left clip at {:?}": "",
    "incorrect right clip at {:?}": "",
    "incorrect left clip within multi-byte char at {:?}": "",
    "incorrect right clip within multi-byte char at {:?}": "",
    "incorrect unclipped_point_utf16_to_point within multi-byte char at {:?}": "",
    "incorrect left clip_point_utf16 within multi-byte char at {:?}": "",
    "incorrect right clip_point_utf16 within multi-byte char at {:?}": "",
    "incorrect left clip_offset_utf16 within multi-byte char at {:?}": "",
    "incorrect right clip_offset_utf16 within multi-byte char at {:?}": "",
    "mismatch at final offset {}": "",
    "mismatch at final point {:?}": "",
    "mismatch at final point_utf16 {:?}": "",
    "mismatch for unclipped_point_utf16_to_point at final point {:?}": "",
    "incorrect left clip at final point {:?}": "",
    "incorrect right clip at final point {:?}": "",
    "incorrect left clip_point_utf16 at final point {:?}": "",
    "incorrect right clip_point_utf16 at final point {:?}": "",
    "incorrect left clip_offset_utf16 at final offset {:?}": "",
    "incorrect right clip_offset_utf16 at final offset {:?}": ""
  },
  "zed/crates/rpc/src/auth.rs": {
    "failed to encrypt string with public key": "",
    "failed to base64-decode encrypted string": "",
    "failed to decrypt string with private key": "",
    "decrypted content was not valid utf8": "",
    "failed to serialize public key": "",
    "failed to base64-decode public key string": "",
    "failed to parse public key": "",
    "MIGJAoGBAMPvufou8wOuUIF1Wlkbtn0ZMM9nC55QJ06nTZvgMfZv5esFVU9-cQO_JC1P9ZoEcMDJweFERnQuQLqzsrMDLFbkdgL128ZU43WOLiQraxaICFIZsPUeTtWMKp2D5bPWsNxs-lnCma7vCAry6fpXuj5AKQdk7cTZJNucgvZQ0uUfAgMBAAE=": "",
    "token {:?} has non-printable char {}": "",
    "token {:?} is not URL-safe": ""
  },
  "zed/crates/rpc/src/peer.rs": {
    "{}/{}": "",
    "test-support": "",
    "handle io future: start": "",
    "connection closed": "",
    "handle io future: end": "",
    "outer loop iteration start": "",
    "inner loop iteration start": "",
    "outgoing rpc message: writing": "",
    "outgoing rpc message: done writing": "",
    "failed to write RPC message": "",
    "keepalive interval: resetting after sending message": "",
    "outgoing rpc message: writing timed out": "",
    "timed out writing message": "",
    "outgoing rpc message: channel closed": "",
    "keepalive interval: pinging": "",
    "keepalive interval: done pinging": "",
    "failed to send keepalive": "",
    "keepalive interval: resetting after pinging": "",
    "keepalive interval: pinging timed out": "",
    "timed out sending keepalive": "",
    "error reading rpc message from socket": "",
    "incoming rpc message: received": "",
    "receive timeout: resetting": "",
    "incoming rpc message: processing": "",
    "incoming rpc message: processed": "",
    "incoming rpc message: channel closed": "",
    "incoming rpc message: processing timed out": "",
    "timed out processing incoming message": "",
    "receive timeout: delay between messages too long": "",
    "delay between messages too long": "",
    "incoming message future: start": "",
    "incoming message future: end": "",
    "incoming response: received": "",
    "incoming response: request future dropped": "",
    "incoming response: waiting to resume requester": "",
    "incoming response: requester resumed": "",
    "incoming stream response: request future dropped": "",
    "incoming stream response: waiting to resume requester": "",
    "incoming stream response: requester resumed": "",
    "incoming response: unknown request": "",
    "incoming message: received": "",
    "unable to construct a typed envelope": "",
    "received response of the wrong type": "",
    "connection was closed": "",
    "message {} was not handled": "",
    "no such connection: {connection_id}": "",
    "Peer": "",
    "connections": "",
    "unknown message type": "",
    "message 1": "",
    "message 2": "",
    "response": "",
    "response 2": ""
  },
  "zed/crates/rpc/src/proto_client.rs": {
    "registered handler for the same message twice": "",
    "EntityMessageSubscriber::Entity": "",
    "handle": "",
    "EntityMessageSubscriber::Pending": "",
    "envelopes": "",
    "received response of the wrong type": ""
  },
  "zed/crates/search/src/buffer_search.rs": {
    "util::serde::default_true": "",
    "search_bar": "",
    "Search…": "",
    "Replace with…": "",
    "{}/{}": "",
    "0/0": "",
    "BufferSearchBar": "",
    "in_replace": "",
    "Find in results": "",
    "editor-scroll": "",
    "buffer-search-bar-toggle-replace-button": "",
    "Toggle Replace": "",
    "buffer-search-bar-toggle-search-selection-button": "",
    "Toggle Search Selection": "",
    "select-all": "",
    "Select All Matches": "",
    "Select Previous Match": "",
    "Select Next Match": "",
    "Close": "",
    "Close Search Bar": "",
    "search-replace-next": "",
    "Replace Next Match": "",
    "search-replace-all": "",
    "Replace All Matches": "",
    "buffer_search": "",
    "query editor should be backed by a singleton buffer": "",
    "regex": "",
    "loading regex language": "",
    "": "",
    "\n                A regular expression (shortened as regex or regexp;[1] also referred to as\n                rational expression[2][3]) is a sequence of characters that specifies a search\n                pattern in text. Usually such patterns are used by string-searching algorithms\n                for ": "",
    " or ": "",
    " operations on strings, or for input validation.\n                ": "",
    "us": "",
    "or": "",
    "\n        A regular expression (shortened as regex or regexp;[1] also referred to as\n        rational expression[2][3]) is a sequence of characters that specifies a search\n        pattern in text. Usually such patterns are used by string-searching algorithms\n        for ": "",
    " operations on strings, or for input validation.\n        ": "",
    "Should pick a query with multiple results": "",
    "a": "",
    "Initially, the editor should not be focused": "",
    "Expected to have only one selection before adding carets to all matches, but got: {initial_selections:?}": "",
    "Should focus editor after successful SelectAllMatches": "",
    "Should select all `a` characters in the buffer, but got: {all_selections:?}": "",
    "Match index should not change after selecting all matches": "",
    "Should still have editor focused after SelectNextMatch": "",
    "On next match, should deselect items and select the next match": "",
    "Next match should be different from the first selection": "",
    "Match index should be updated to the next one": "",
    "Should still have editor focused after SelectPreviousMatch": "",
    "On previous match, should deselect items and select the previous item": "",
    "Previous match should be the same as the first selection": "",
    "Match index should be updated to the previous one": "",
    "abas_nonexistent_match": "",
    "Should not switch focus to editor if SelectAllMatches does not find any matches": "",
    "Should not select anything new if there are no matches": "",
    "For no matches, there should be no active match index": "",
    "\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.edit(\n                edits,\n                Some(AutoindentMode::Block {\n                    original_indent_columns,\n                }),\n                cx,\n            )\n        });\n\n        this.buffer.update(cx, |buffer, cx| {\n            buffer.edit([(end_of_line..start_of_next_line, replace)], None, cx)\n        });\n        ": "",
    "edit\\\\(": "",
    "Should select all `edit(` in the buffer, but got: {all_selections:?}": "",
    "edit(": "",
    "b": "",
    "c": "",
    "ba": "",
    "expression": "",
    "expr$1": "",
    "\n        A regular expr$1 (shortened as regex or regexp;[1] also referred to as\n        rational expr$1[2][3]) is a sequence of characters that specifies a search\n        pattern in text. Usually such patterns are used by string-searching algorithms\n        for ": "",
    "banana": "",
    "\n        A regular expr$1 (shortened as regex banana regexp;[1] also referred to as\n        rational expr$1[2][3]) is a sequence of characters that specifies a search\n        pattern in text. Usually such patterns are used by string-searching algorithms\n        for ": "",
    "\\\\[([^\\\\]]+)\\\\]": "",
    "${1}number": "",
    "\n        A regular expr$1 (shortened as regex banana regexp;1number also referred to as\n        rational expr$12number3number) is a sequence of characters that specifies a search\n        pattern in text. Usually such patterns are used by string-searching algorithms\n        for ": "",
    "a\\\\w+s": "",
    "things": "",
    "\n        A regular expr$1 (shortened as regex banana regexp;1number also referred to as\n        rational expr$12number3number) is a sequence of characters that specifies a search\n        pattern in text. Usually such patterns are used by string-searching things\n        for ": "",
    "\\n": "",
    "\n            A regular \\n (shortened as regex or regexp;[1] also referred to as\n            rational \\n[2][3]) is a sequence of characters that specifies a search\n            pattern in text. Usually such patterns are used by string-searching algorithms\n            for ": "",
    " operations on strings, or for input validation.\n            ": "",
    "\\\\\\n\\\\\\\\": "",
    "find": "",
    "find and replace": "",
    "#\n            .unindent(),\n        })\n        .await;\n\n        run_replacement_test(ReplacementTestParams {\n            editor: &editor,\n            search_bar: &search_bar,\n            cx,\n            search_text: r": "",
    ",\n            search_options: Some(SearchOptions::REGEX),\n            replacement_text: r": "",
    ",\n            replace_all: true,\n            expected_text: r#": "",
    "#\n            .unindent(),\n        })\n        .await;\n    }\n\n    #[gpui::test]\n    async fn test_find_matches_in_selections_singleton_buffer_multiple_selections(\n        cx: &mut TestAppContext,\n    ) {\n        init_globals(cx);\n        let buffer = cx.new(|cx| {\n            Buffer::local(\n                r#": "",
    "#\n                .unindent(),\n                cx,\n            )\n        });\n        let cx = cx.add_empty_window();\n        let editor =\n            cx.new_window_entity(|window, cx| Editor::for_buffer(buffer.clone(), None, window, cx));\n\n        let search_bar = cx.new_window_entity(|window, cx| {\n            let mut search_bar = BufferSearchBar::new(None, window, cx);\n            search_bar.set_active_pane_item(Some(&editor), window, cx);\n            search_bar.show(window, cx);\n            search_bar\n        });\n\n        editor.update_in(cx, |editor, window, cx| {\n            editor.change_selections(None, window, cx, |s| {\n                s.select_ranges(vec![Point::new(1, 0)..Point::new(2, 4)])\n            })\n        });\n\n        search_bar.update_in(cx, |search_bar, window, cx| {\n            let deploy = Deploy {\n                focus: true,\n                replace_enabled: false,\n                selection_search_enabled: true,\n            };\n            search_bar.deploy(&deploy, window, cx);\n        });\n\n        cx.run_until_parked();\n\n        search_bar\n            .update_in(cx, |search_bar, window, cx| {\n                search_bar.search(": "",
    ", None, window, cx)\n            })\n            .await\n            .unwrap();\n\n        editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.search_background_highlights(cx),\n                &[\n                    Point::new(1, 0)..Point::new(1, 3),\n                    Point::new(1, 8)..Point::new(1, 11),\n                    Point::new(2, 0)..Point::new(2, 3),\n                ]\n            );\n        });\n    }\n\n    #[gpui::test]\n    async fn test_find_matches_in_selections_multiple_excerpts_buffer_multiple_selections(\n        cx: &mut TestAppContext,\n    ) {\n        init_globals(cx);\n        let text = r#": "",
    "#\n        .unindent();\n\n        let cx = cx.add_empty_window();\n        let editor = cx.new_window_entity(|window, cx| {\n            let multibuffer = MultiBuffer::build_multi(\n                [\n                    (\n                        &text,\n                        vec![\n                            Point::new(0, 0)..Point::new(2, 0),\n                            Point::new(4, 0)..Point::new(5, 0),\n                        ],\n                    ),\n                    (&text, vec![Point::new(9, 0)..Point::new(11, 0)]),\n                ],\n                cx,\n            );\n            Editor::for_multibuffer(multibuffer, None, window, cx)\n        });\n\n        let search_bar = cx.new_window_entity(|window, cx| {\n            let mut search_bar = BufferSearchBar::new(None, window, cx);\n            search_bar.set_active_pane_item(Some(&editor), window, cx);\n            search_bar.show(window, cx);\n            search_bar\n        });\n\n        editor.update_in(cx, |editor, window, cx| {\n            editor.change_selections(None, window, cx, |s| {\n                s.select_ranges(vec![\n                    Point::new(1, 0)..Point::new(1, 4),\n                    Point::new(5, 3)..Point::new(6, 4),\n                ])\n            })\n        });\n\n        search_bar.update_in(cx, |search_bar, window, cx| {\n            let deploy = Deploy {\n                focus: true,\n                replace_enabled: false,\n                selection_search_enabled: true,\n            };\n            search_bar.deploy(&deploy, window, cx);\n        });\n\n        cx.run_until_parked();\n\n        search_bar\n            .update_in(cx, |search_bar, window, cx| {\n                search_bar.search(": "",
    ", None, window, cx)\n            })\n            .await\n            .unwrap();\n\n        editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.search_background_highlights(cx),\n                &[\n                    Point::new(1, 0)..Point::new(1, 3),\n                    Point::new(5, 8)..Point::new(5, 11),\n                    Point::new(6, 0)..Point::new(6, 3),\n                ]\n            );\n        });\n    }\n\n    #[gpui::test]\n    async fn test_invalid_regexp_search_after_valid(cx: &mut TestAppContext) {\n        let (editor, search_bar, cx) = init_test(cx);\n        // Search using valid regexp\n        search_bar\n            .update_in(cx, |search_bar, window, cx| {\n                search_bar.enable_search_option(SearchOptions::REGEX, window, cx);\n                search_bar.search(": "",
    ", None, window, cx)\n            })\n            .await\n            .unwrap();\n        editor.update_in(cx, |editor, window, cx| {\n            assert_eq!(\n                display_points_of(editor.all_text_background_highlights(window, cx)),\n                &[\n                    DisplayPoint::new(DisplayRow(0), 10)..DisplayPoint::new(DisplayRow(0), 20),\n                    DisplayPoint::new(DisplayRow(1), 9)..DisplayPoint::new(DisplayRow(1), 19),\n                ],\n            );\n        });\n\n        // Now, the expression is invalid\n        search_bar\n            .update_in(cx, |search_bar, window, cx| {\n                search_bar.search(": "",
    ", None, window, cx)\n            })\n            .await\n            .unwrap_err();\n        editor.update_in(cx, |editor, window, cx| {\n            assert!(\n                display_points_of(editor.all_text_background_highlights(window, cx)).is_empty(),\n            );\n        });\n    }\n\n    #[gpui::test]\n    async fn test_search_options_changes(cx: &mut TestAppContext) {\n        let (_editor, search_bar, cx) = init_test(cx);\n        update_search_settings(\n            SearchSettings {\n                button: true,\n                whole_word: false,\n                case_sensitive: false,\n                include_ignored: false,\n                regex: false,\n            },\n            cx,\n        );\n\n        let deploy = Deploy {\n            focus: true,\n            replace_enabled: false,\n            selection_search_enabled: true,\n        };\n\n        search_bar.update_in(cx, |search_bar, window, cx| {\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::NONE,\n                ": "",
    "\n            );\n            search_bar.toggle_search_option(SearchOptions::WHOLE_WORD, window, cx);\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::WHOLE_WORD,\n                ": "",
    "\n            );\n            assert!(\n                !search_bar.dismissed,\n                ": "",
    "\n            );\n            search_bar.deploy(&deploy, window, cx);\n            assert_eq!(\n                search_bar.configured_options,\n                SearchOptions::NONE,\n                ": "",
    "\n            );\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::WHOLE_WORD,\n                ": "",
    "\n            );\n\n            search_bar.dismiss(&Dismiss, window, cx);\n            search_bar.deploy(&deploy, window, cx);\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::NONE,\n                ": "",
    "\n            );\n\n            search_bar.toggle_search_option(SearchOptions::REGEX, window, cx);\n            search_bar.toggle_search_option(SearchOptions::WHOLE_WORD, window, cx);\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::REGEX | SearchOptions::WHOLE_WORD,\n                ": "",
    "\n            );\n        });\n\n        update_search_settings(\n            SearchSettings {\n                button: true,\n                whole_word: false,\n                case_sensitive: true,\n                include_ignored: false,\n                regex: false,\n            },\n            cx,\n        );\n        search_bar.update_in(cx, |search_bar, window, cx| {\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::REGEX | SearchOptions::WHOLE_WORD,\n                ": "",
    "\n            );\n\n            search_bar.deploy(&deploy, window, cx);\n            assert_eq!(\n                search_bar.configured_options,\n                SearchOptions::CASE_SENSITIVE,\n                ": "",
    "\n            );\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::REGEX | SearchOptions::WHOLE_WORD,\n                ": "",
    "\n            );\n            search_bar.dismiss(&Dismiss, window, cx);\n            search_bar.deploy(&deploy, window, cx);\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::CASE_SENSITIVE,\n                ": ""
  },
  "zed/crates/search/src/mode.rs": {
    "Text": "",
    "Regex": "",
    "Activate {} Mode": ""
  },
  "zed/crates/search/src/project_search.rs": {
    ",": "",
    "Searching…": "",
    "No Results": "",
    "Search All Files": "",
    "No results found in this project for the provided query": "",
    "project-search-landing-page": "",
    "Project Search": "",
    "": "",
    "Project Search Opened": "",
    "save_as should not have been called": "",
    "Search all files…": "",
    "Replace in project…": "",
    "Include: crates/**/*.toml": "",
    "Exclude: vendor/*, *.lock": "",
    "regex": "",
    "loading regex language": "",
    "Save": "",
    "Don't Save": "",
    "Cancel": "",
    "Project search buffer contains unsaved edits. Do you want to save it?": "",
    "Hit enter to search. For more options:": "",
    "filter-paths": "",
    "Include/exclude specific paths": "",
    "find-replace": "",
    "Find and replace": "",
    "Match with regex": "",
    "match-case": "",
    "Match case": "",
    "match-whole-words": "",
    "Match whole words": "",
    "test-support": "",
    "query editor should be backed by a singleton buffer": "",
    "project-search-filter-button": "",
    "Toggle Filters": "",
    "project-search-toggle-replace": "",
    "Toggle Replace": "",
    "{index}/{match_quantity}+": "",
    "{index}/{match_quantity}": "",
    "0/0": "",
    "project-search-prev-match": "",
    "Go To Previous Match": "",
    "project-search-next-match": "",
    "Go To Next Match": "",
    "matches": "",
    "Search limits reached.\\nTry narrowing your search.": "",
    "project-search-replace-next": "",
    "Replace Next Match": "",
    "project-search-replace-all": "",
    "Replace All Matches": "",
    "project-search-opened-only": "",
    "Only Search Open Files": "",
    "ProjectSearchBar": "",
    "in_replace": "",
    "/dir": "",
    "one.rs": "",
    "const ONE: usize = 1;": "",
    "two.rs": "",
    "const TWO: usize = one::ONE + one::ONE;": "",
    "three.rs": "",
    "const THREE: usize = one::ONE + two::TWO;": "",
    "four.rs": "",
    "const FOUR: usize = one::ONE + three::THREE;": "",
    "TWO": "",
    "\\n\\nconst THREE: usize = one::ONE + two::TWO;\\n\\n\\nconst TWO: usize = one::ONE + one::ONE;": "",
    "Expected no search panel to be active": "",
    "Search view expected to appear after new search event trigger": "",
    "Empty search view should be focused after the toggle focus event: no results panel to focus on": "",
    "Search view should be focused after the new search view is activated": "",
    "New search query should be empty but got '{query_text}'": "",
    "Empty search view should have no results but got '{results_text}'": "",
    "sOMETHINGtHATsURELYdOESnOTeXIST": "",
    "Search view for mismatching query should have no results but got '{results_text}'": "",
    "Search view should be focused after mismatching query had been used in search": "",
    "Search view with mismatching query should be focused after the toggle focus event: still no results panel to focus on": "",
    "Search view results should match the query": "",
    "Search view with mismatching query should be focused after search results are available": "",
    "Search view with matching query should still have its results editor focused after the toggle focus event": "",
    "two": "",
    "Query should be updated to first search result after search view 2nd open in a row": "",
    "Results should be unchanged after search view 2nd open in a row": "",
    "Focus should be moved into query editor again after search view 2nd open in a row": "",
    "Search view with matching query should switch focus to the results editor after the toggle focus event": "",
    "const FOUR": "",
    "Search view for query with the only match in an excluded file should have no results but got '{results_text}'": "",
    "\\n\\nconst FOUR: usize = one::ONE + three::THREE;": "",
    "Search view results should contain the queried result in the previously excluded file with filters toggled off": "",
    "New search view should be open after `workspace::NewSearch` event": "",
    "First search view should not have an updated query": "",
    "Results of the first search view should not update too": "",
    "Focus should be moved away from the first search view": "",
    "New search view should get the query from the text cursor was at during the event spawn (first search view's first result)": "",
    "No search results should be in the 2nd view yet, as we did not spawn a search for it": "",
    "Focus should be moved into query editor of the new window": "",
    "FOUR": "",
    "New search view with the updated query should have new search results": "",
    "a": "",
    "b": "",
    "no entry for /a/ directory": "",
    "Search view expected to appear after new search in directory event trigger": "",
    "On new search in directory, focus should be moved into query editor": "",
    "New search in directory should not have any excluded files": "",
    "New search in directory should have included dir entry path": "",
    "const": "",
    "\\n\\nconst ONE: usize = 1;\\n\\n\\nconst TWO: usize = one::ONE + one::ONE;": "",
    "New search in directory should have a filter that matches a certain directory": "",
    "ONE": "",
    "THREE": "",
    "JUST_TEXT_INPUT": "",
    "TWO_NEW": "",
    "1.txt": "",
    "\\n\\n\\n\\n\\n A \\n\\n\\n\\n\\n": "",
    "2.txt": "",
    "3.rs": "",
    "4.rs": "",
    "5.rs": "",
    "6.rs": "",
    "7.rs": "",
    "8.rs": "",
    "9.rs": "",
    "a.rs": "",
    "b.rs": "",
    "\\n\\n\\n\\n\\n B \\n\\n\\n\\n\\n": "",
    "c.rs": "",
    "d.rs": "",
    "e.rs": "",
    "f.rs": "",
    "g.rs": "",
    "h.rs": "",
    "i.rs": "",
    "j.rs": "",
    "k.rs": "",
    "A": "",
    " A ": "",
    "unable to update search view": "",
    "B": "",
    " B ": "",
    "search bar query": "",
    "should open a project search view after spawning a new search": "",
    "Project search should take the query from the buffer search bar since it got focused and had a query inside": ""
  },
  "zed/crates/search/src/search.rs": {
    "Match Whole Words": "",
    "Match Case Sensitively": "",
    "Also search files ignored by configuration": "",
    "Use Regular Expressions": "",
    "{:?} is not a named SearchOption": "",
    "No more matches": ""
  },
  "zed/crates/semantic_index/examples/index.rs": {
    "Zed semantic index example": "",
    "http://localhost:11434": "",
    "Usage: cargo run --example index -p semantic_index -- <project_path>": "",
    "OPENAI_API_KEY": "",
    "OPENAI_API_KEY not set": "",
    "/tmp/semantic-index-db.mdb": "",
    "no event emitted": "",
    "Index time: {:?}": "",
    "converting an anchor to a point": "",
    "✄✄✄✄✄✄✄✄✄✄✄✄✄✄ {:?} @ {} ✄✄✄✄✄✄✄✄✄✄✄✄✄✄": "",
    "{:?}:{:?}:{:?}": "",
    "{}": ""
  },
  "zed/crates/semantic_index/src/embedding/ollama.rs": {
    "nomic-embed-text": "",
    "mxbai-embed-large": "",
    "http://localhost:11434/api/embeddings": "",
    "Unable to pull response": ""
  },
  "zed/crates/semantic_index/src/chunking.rs": {
    "failed to parse file {path:?} for chunking": "",
    "\n            struct Person {\n                first_name: String,\n                last_name: String,\n                age: u32,\n            }\n\n            impl Person {\n                fn new(first_name: String, last_name: String, age: u32) -> Self {\n                    Self { first_name, last_name, age }\n                }\n\n                /// Returns the first name\n                /// something something something\n                fn first_name(&self) -> &str {\n                    &self.first_name\n                }\n\n                fn last_name(&self) -> &str {\n                    &self.last_name\n                }\n\n                fn age(&self) -> u32 {\n                    self.age\n                }\n            }\n        ": "",
    "lib.rs": "",
    "Self {": "",
    "struct Person {": "",
    "impl Person {": "",
    "    /// Returns the first name": "",
    "    fn last_name": "",
    "\n            struct T {}\n            struct U {}\n            struct V {}\n            struct W {\n                a: T,\n                b: U,\n            }\n        ": "",
    "struct T": "",
    "struct V": "",
    "struct W": "",
    "}": "",
    "\n            struct S { a: u32 }\n            struct T { a: u64 }\n            struct U { a: u64, b: u64, c: u64, d: u64, e: u64, f: u64, g: u64, h: u64, i: u64, j: u64 }\n            struct W { a: u64, b: u64, c: u64, d: u64, e: u64, f: u64, g: u64, h: u64, i: u64, j: u64 }\n        ": "",
    "struct S {": "",
    "struct U": "",
    "4, h: u64, i: u64": "",
    "unexpected number of chunks: {chunks:?}": "",
    "chunk {ix} starts at unexpected offset {}. expected {}": "",
    "invalid expected chunk prefix {ix}: {expected_prefix:?}": "",
    "chunk ranges are not contiguous: {:?}": "",
    "chunks don't cover entire text {:?}": "",
    "a\\n": "",
    "Rust": "",
    "rs": "",
    "\n            (function_item name: (_) @name) @item\n            (impl_item type: (_) @name) @item\n            (struct_item name: (_) @name) @item\n            (field_declaration name: (_) @name) @item\n        ": ""
  },
  "zed/crates/semantic_index/src/embedding_index.rs": {
    "failed to create read transaction": "",
    "failed to create iterator": "",
    "scanning for embedding index: {:?}": "",
    "embedding provider returned unexpected embedding count {}, expected {}": "",
    "deleting embeddings in range {:?}": "",
    "saving embedding for file {:?}": "",
    "no such path": "",
    "\\0": ""
  },
  "zed/crates/semantic_index/src/embedding.rs": {
    "Embedding(sized: {}; values: [": "",
    ", ": "",
    "{:.3}": "",
    "...": "",
    "])": ""
  },
  "zed/crates/semantic_index/src/project_index_debug_view.rs": {
    "chunk {} of {}. length: {}": "",
    "prev": "",
    "next": "",
    "selected-path-name": "",
    "x": "",
    "ProjectIndexDebugView": "",
    "Project Index (Debug)": ""
  },
  "zed/crates/semantic_index/src/project_index.rs": {
    "failed to create read transaction": "",
    "failed to iterate database": "",
    "Searching for {queries:?}": "",
    "The number of query embeddings does not match the number of queries": "",
    "searched {} entries in {:?}": "",
    "embedding query took {:?}": "",
    "failed to create db read transaction": "",
    "No summary found for {:?}": "",
    "Error reading from summary database: {:?}": "",
    "Error flushing summary backlog: {:?}": "",
    "Summary backlog flushed in {:?}": ""
  },
  "zed/crates/semantic_index/src/semantic_index.rs": {
    "opening database connection": "",
    "No SemanticDb, skipping project index": "",
    "\\n\\n": "",
    "garbage in": "",
    "garbage out": "",
    "/fake_project": "",
    "fixture": "",
    "main.rs": "",
    "../fixture/main.rs": "",
    "needle.md": "",
    "../fixture/needle.md": "",
    "garbage in, garbage out": "",
    "should have found some results, but only found {:?}": "",
    "result: {:?}": "",
    "score: {:?}": "",
    "fixture/needle.md": "",
    "cannot embed text containing a 'g' character": "",
    "test1.md": "",
    "abcdefghijklmnop": "",
    "test2.md": "",
    "qrstuvwxyz": "",
    "qrst": "",
    "uvwx": "",
    "yz": "",
    "one\\ntwo\\nthree\\nfour\\nfive\\n": "",
    "aaa\\nbbb\\nccc\\nddd\\neee\\n": "",
    "file1.txt": "",
    "file2.txt": "",
    "four": "",
    "fake_project/file1.txt": "",
    "one\\ntwo\\nthree\\n": "",
    "two": "",
    "two\\nthree\\nfour\\n": "",
    "fake_project/file2.txt": ""
  },
  "zed/crates/semantic_index/src/worktree_index.rs": {
    "digests-{}": "",
    "summaries-{}": "",
    "Updating entries...": "",
    "failed to create read transaction": ""
  },
  "zed/crates/semantic_version/src/semantic_version.rs": {
    "missing major version number": "",
    "missing minor version number": "",
    "missing patch version number": "",
    "{}.{}.{}": "",
    "Invalid version string \\\"{string}\\\"": ""
  },
  "zed/crates/settings/src/keymap_file.rs": {
    "{}": "",
    ", ": "",
    "KeymapAction": "",
    "Error loading built-in keymap \\\"{asset_path}\\\": {error_message}": "",
    "JSON parse error in built-in keymap \\\"{asset_path}\\\": {error}": "",
    "test-support": "",
    "{error_message}": "",
    "JSON parse error: {error}": "",
    " Parse error in section `context` field: {}": "",
    "\\n\\n - Unrecognized fields: {}": "",
    "{:?}": "",
    "  ": "",
    "\\n": "",
    "\\n\\n- In binding {}, {indented_err}": "",
    "\\\"{}\\\"": "",
    "Errors in user keymap file.\\n": "",
    "\\n\\nIn section without context predicate:": "",
    "\\n\\nIn section with {}:": "",
    "context = \\\"{}\\\"": "",
    "{section_errors}": "",
    ",\n                        MarkdownInlineCode(&action.0.to_string())\n                    ));\n                }\n                let serde_json::Value::String(ref name) = items[0] else {\n                    return Err(format!(\n                        ": "",
    ",\n                        MarkdownInlineCode(&action.0.to_string())\n                    ));\n                };\n                let action_input = items[1].clone();\n                let action_input_string = action_input.to_string();\n                (\n                    cx.build_action(&name, Some(action_input)),\n                    Some(action_input_string),\n                )\n            }\n            Value::String(name) => (cx.build_action(&name, None), None),\n            Value::Null => (Ok(NoAction.boxed_clone()), None),\n            _ => {\n                return Err(format!(\n                    ": "",
    ",\n                    MarkdownInlineCode(&action.0.to_string())\n                ));\n            }\n        };\n\n        let action = match build_result {\n            Ok(action) => action,\n            Err(ActionBuildError::NotFound { name }) => {\n                return Err(format!(\n                    ": "",
    ",\n                    MarkdownInlineCode(&format!(": "",
    "{}\\\"": "",
    "can't build {} action from input value {}: {}": "",
    "can't build {} action - it requires input data via [name, input]: {}": "",
    "invalid keystroke {}. {}": "",
    "deprecationMessage": "",
    "Deprecated, use {new_name}": "",
    "": "",
    "No action named this.": "",
    "No action named this that takes input.": "",
    "null": "",
    "[\n              // Standard macOS bindings\n              {\n                \\\"bindings\\\": {\n                  \\\"up\\\": \\\"menu::SelectPrevious\\\",\n                },\n              },\n            ]\n                  ": ""
  },
  "zed/crates/settings/src/settings_file.rs": {
    "empty-theme": "",
    "test-support": "",
    "windows": "",
    "ui_font_family": "",
    "Courier": "",
    "ui_font_features": "",
    "ui_font_size": "",
    "ui_font_fallback": "",
    "buffer_font_family": "",
    "buffer_font_features": "",
    "buffer_font_size": "",
    "buffer_font_fallback": "",
    "theme": "",
    "Courier New": "",
    "languages": ""
  },
  "zed/crates/settings/src/settings_store.rs": {
    "version": "",
    "missing default": "",
    "creating editorconfig parser": "",
    "parsing editorconfig sections": "",
    "A default setting must be added to the `default.json` file": "",
    "unregistered setting type {}": "",
    "no default value for setting type": "",
    "wrong value type for setting": "",
    "test-support": "",
    "{}": "",
    "Failed to canonicalize settings path {:?}": "",
    "Failed to write settings to file {:?}": "",
    "settings must be an object": "",
    "Attempted to submit tasks into the settings store": "",
    "Attempted to submit debugger config into the settings store": "",
    "": "",
    "dev": "",
    "nightly": "",
    "stable": "",
    "preview": "",
    "{message}": "",
    "SettingsStore": "",
    "types": "",
    "default_settings": "",
    "user_settings": "",
    "local_settings": "",
    "no default value for setting {}": "",
    "(pair key: (string) @key value: (_) @value)": "",
    "Failed to create PAIR_QUERY": "",
    "\\\"{}\\\"": "",
    "') {\n                if let Some(prev_key_start) = text[..key_start].rfind('": "",
    "\\\"{new_key}\\\": {new_val},\\n{space:width$}": "",
    ": {new_val},": "",
    "{\n                    ": "",
    ": false,\n                    ": "",
    ": {\n                        ": "",
    ": ": "",
    ",\n                        ": "",
    ": 30,\n                        ": "",
    ": false\n                    }\n                }": "",
    "John Doe": "",
    ": true,\n                    ": "",
    ": { ": "",
    ": 31 },\n                    ": "",
    "\n                }": "",
    "/root1": "",
    "{ ": "",
    ": true } }": "",
    "/root1/subdir": "",
    " } }": "",
    "/root2": "",
    ": 42 }, ": "",
    " }": "",
    "/root1/something": "",
    "/root1/subdir/something": "",
    "Jane Doe": "",
    "/root2/something": "",
    "a": "",
    "b": "",
    ": false\n                    },\n                    ": "",
    ": false }": "",
    "x": "",
    "{\n                ": "",
    ": {\n                    ": "",
    ": true\n                    }\n                }\n            }": "",
    "JSON": "",
    "Rust": "",
    ": true\n                    },\n                    ": "",
    ": false\n                    }\n                }\n            }": "",
    ":   { ": "",
    ": 36, ": "",
    ", ": "",
    ": true }\n            }": "",
    ": 37, ": "",
    ": 1, ": "",
    ": 2 }": "",
    ": {}\n            }": "",
    ": 37\n                }\n            }": "",
    ": 37\n                }\n            }\n            ": "",
    "{\n            }\n            ": "",
    " { ": "",
    ": 37 } ": "",
    ": 42 }": "",
    ": 42\n                }\n            }\n            ": "",
    ": {\n                ": "",
    "\n                }\n            }\n            ": "",
    "\n            }\n            ": "",
    ",\n                ": "",
    "\n            }": "",
    ": [\n                    {\n                        ": "",
    ": true\n                    },\n                    {\n                        ": "",
    ": false\n                    }\n                ]\n            }": "",
    "user": "",
    "user.age": "",
    "turbo": "",
    "key_1_first": "",
    "key_1_second": "",
    "{} {}": "",
    "snake_case": "",
    "journal": "",
    "time_format": "",
    "12": "",
    "24": "",
    ": 35,\n                        ": "",
    ": true\n                    }\n                }": "",
    "Global User": "",
    ": 40\n                    }\n                }": "",
    "vscode_languages": "",
    "name": ""
  },
  "zed/crates/settings_ui/src/appearance_settings_controls.rs": {
    "Theme": "",
    "Font": "",
    "theme": "",
    "Theme Mode": "",
    "light": "",
    "Light": "",
    "system": "",
    "System": "",
    "dark": "",
    "Dark": "",
    "UI Font Family": "",
    "ui-font-family": "",
    "UI Font Size": "",
    "ui-font-size": "",
    "UI Font Weight": "",
    "ui-font-weight": "",
    "UI Font Ligatures": "",
    "calt": "",
    "ui-font-ligatures": ""
  },
  "zed/crates/settings_ui/src/settings_ui.rs": {
    "settings-ui": "",
    "Failed to load {source} settings: {}": "",
    "Loading {source} settings from path: {:?}": "",
    "Could not find or load a {source} settings file": "",
    "Ok": "",
    "Importing settings may overwrite your existing settings": "",
    "Cancel": "",
    "Imported settings from {source}": "",
    "Settings": "",
    "Appearance": "",
    "Editor": ""
  },
  "zed/crates/snippet/src/snippet.rs": {
    "failed to parse snippet": "",
    "": "",
    "|": "",
    "expected a closing brace": "",
    "expected an integer": "",
    "Placeholder choice doesn't contain closing pipe-character '|'": "",
    "one-two-three": "",
    "one$1two": "",
    "onetwo": "",
    "one$123-$99-two": "",
    "one--two": "",
    "foo.$1": "",
    "foo.": "",
    "<div class=": "",
    ">$0</div>": "",
    "></div>": "",
    "one${1:two}three${2:four}": "",
    "onetwothreefour": "",
    "type ${1|i32, u32|} = $2": "",
    "Should be able to unpack choice placeholders": "",
    "type i32 = ": "",
    "i32": "",
    " u32": "",
    "${1|\\$\\{1\\|one\\,two\\,tree\\|\\}|}": "",
    "Should be able to parse choice with escape characters": "",
    "${1|one,two,tree|}": "",
    "for (${1:var ${2:i} = 0; ${2:i} < ${3:${4:array}.length}; ${2:i}++}) {$0}": "",
    "for (var i = 0; i < array.length; i++) {}": "",
    "\\\"\\\\$schema\\\": $1": "",
    "\\\"$schema\\\": ": "",
    "{a\\\\}": "",
    "{a}": "",
    "a\\\\b": "",
    "one\\\\\\\\$1two": "",
    "one\\\\two": ""
  },
  "zed/crates/snippets_ui/src/snippets_ui.rs": {
    "{}.json": "",
    "global": "",
    "snippets": "",
    "json": "",
    "default": "",
    "Select snippet scope...": ""
  },
  "zed/crates/sqlez/src/bindable.rs": {
    "Failed to bind bool at index {start_index}": "",
    "Failed to read bool at index {start_index}": "",
    "Failed to bind &[u8] at index {start_index}": "",
    "Failed to bind &[u8; C] at index {start_index}": "",
    "Failed to bind Vec<u8> at index {start_index}": "",
    "Failed to read Vec<u8> at index {start_index}": "",
    "Failed to bind f64 at index {start_index}": "",
    "Failed to parse f64 at index {start_index}": "",
    "Failed to parse f32 at index {start_index}": "",
    "Failed to bind i32 at index {start_index}": "",
    "Failed to bind i64 at index {start_index}": "",
    "Failed to bind usize at index {start_index}": ""
  },
  "zed/crates/sqlez/src/connection.rs": {
    "file:{}?mode=memory&cache=shared": "",
    ":memory:": "",
    "Could not create fallback in memory db": "",
    "main": "",
    ";": "",
    "CREATE TABLE {table_to_alter}({column})": "",
    "linux": "",
    "freebsd": "",
    "Sqlite call failed with code {code} and message: {message:?}": "",
    "alter": "",
    "table": "",
    "rename column": "",
    "drop column": "",
    "__place_holder_column_for_syntax_checking": "",
    "string_round_trips": "",
    "\n            CREATE TABLE text (\n                text TEXT\n            );": "",
    "Some test text": "",
    "INSERT INTO text (text) VALUES (?);": "",
    "SELECT text FROM text;": "",
    "tuple_round_trips": "",
    "\n                CREATE TABLE test (\n                    text TEXT,\n                    integer INTEGER,\n                    blob BLOB\n                );": "",
    "test": "",
    "test2": "",
    "INSERT INTO test (text, integer, blob) VALUES (?, ?, ?)": "",
    "SELECT * FROM test": "",
    "bool_round_trips": "",
    "\n                CREATE TABLE bools (\n                    t INTEGER,\n                    f INTEGER\n                );": "",
    "INSERT INTO bools(t, f) VALUES (?, ?)": "",
    "SELECT * FROM bools;": "",
    "backup_works": "",
    "\n                CREATE TABLE blobs (\n                    data BLOB\n                );": "",
    "INSERT INTO blobs (data) VALUES (?);": "",
    "backup_works_other": "",
    "SELECT * FROM blobs;": "",
    "multi_step_statement_works": "",
    "\n                CREATE TABLE test (\n                    col INTEGER\n                )": "",
    "\n            INSERT INTO test(col) VALUES (2)": "",
    "test_sql_has_syntax_errors": "",
    "CREATE TABLE kv_store(key TEXT PRIMARY KEY, value TEXT NOT NULL) STRICT ;": "",
    "SELECT FROM": "",
    "{}\\n{}": "",
    "test_alter_table_syntax": "",
    "ALTER TABLE test ADD x TEXT": "",
    "ALTER TABLE test AAD x TEXT": ""
  },
  "zed/crates/sqlez/src/migrations.rs": {
    "Error creating cstr": "",
    "Prepare call failed for query:\\n{}": "",
    "migrating": "",
    "\n                CREATE TABLE IF NOT EXISTS migrations (\n                    domain TEXT,\n                    step INTEGER,\n                    migration TEXT\n                )": "",
    "\n                    SELECT domain, step, migration FROM migrations\n                    WHERE domain = ?\n                    ORDER BY step\n                    ": "",
    "INSERT INTO migrations (domain, step, migration) VALUES (?, ?, ?)": "",
    "\n                            Migration changed for {domain} at step {index}\n\n                            Stored migration:\n                            {completed_migration}\n\n                            Proposed migration:\n                            {migration}": "",
    "migrations_are_added_to_table": "",
    "test": "",
    "\n                CREATE TABLE test1 (\n                    a TEXT,\n                    b TEXT\n                )": "",
    "SELECT (migration) FROM migrations": "",
    "CREATE TABLE test1 (a TEXT, b TEXT)": "",
    "\n                    CREATE TABLE test1 (\n                        a TEXT,\n                        b TEXT\n                    )": "",
    "\n                    CREATE TABLE test2 (\n                        c TEXT,\n                        d TEXT\n                    )": "",
    "CREATE TABLE test2 (c TEXT, d TEXT)": "",
    "migration_setup_works": "",
    "\n                CREATE TABLE IF NOT EXISTS migrations (\n                    domain TEXT,\n                    step INTEGER,\n                    migration TEXT\n                );": "",
    "\n                INSERT INTO migrations (domain, step, migration)\n                VALUES (?, ?, ?)": "",
    "test_domain": "",
    "CREATE TABLE table{} ( test TEXT );": "",
    "migrations_dont_rerun": "",
    "\n                CREATE TABLE test_table (\n                    test_column INTEGER\n                );": "",
    "\n            INSERT INTO test_table (test_column) VALUES (1);": "",
    "SELECT * FROM test_table": "",
    "DELETE FROM test_table": "",
    "INSERT INTO test_table (test_column) VALUES (2)": "",
    "changed_migration_fails": "",
    "test migration": "",
    "\n                CREATE TABLE test (\n                    col INTEGER\n                )": "",
    "\n                    INSERT INTO test (col) VALUES (1)": "",
    "\n                CREATE TABLE test (\n                    color INTEGER\n                )": "",
    "\n                INSERT INTO test (color) VALUES (1)": "",
    "test_create_alter_drop": "",
    "first_migration": "",
    "CREATE TABLE table1(a TEXT) STRICT;": "",
    "INSERT INTO table1(a) VALUES (\\\"test text\\\");": "",
    "second_migration": "",
    "\n                    CREATE TABLE table2(b TEXT) STRICT;\n\n                    INSERT INTO table2 (b)\n                    SELECT a FROM table1;\n\n                    DROP TABLE table1;\n\n                    ALTER TABLE table2 RENAME TO table1;\n                ": "",
    "SELECT b FROM table1": "",
    "test text": ""
  },
  "zed/crates/sqlez/src/savepoint.rs": {
    "SAVEPOINT {name}": "",
    "RELEASE {name}": "",
    "\n                    ROLLBACK TO {name};\n                    RELEASE {name}": "",
    "nested_savepoints": "",
    "\n            CREATE TABLE text (\n                text TEXT,\n                idx INTEGER\n            );": "",
    "test save1": "",
    "test save2": "",
    "first": "",
    "INSERT INTO text(text, idx) VALUES (?, ?)": "",
    "second": "",
    "SELECT text FROM text ORDER BY text.idx ASC": "",
    "Failed second save point :(": ""
  },
  "zed/crates/sqlez/src/statement.rs": {
    "Error creating cstr": "",
    "Parsing remaining sql": "",
    ";": "",
    "Prepare call failed for query:\\n{}": "",
    "Write statement prepared with connection that is not write capable. SQL:\\n{} ": "",
    "Failed to bind value at index {index}": "",
    "Failed to bind parameters": "",
    "Failed to read blob at index {index}": "",
    "Failed to read length of blob at index {index}": "",
    "Failed to read double at index {index}": "",
    "Failed to read int at index {index}": "",
    "Failed to read i64 at index {index}": "",
    "Failed to read text from column {index}": "",
    "": "",
    "Failed to read text length at {index}": "",
    "Column type returned was incorrect": "",
    "Statement step returned SQLITE_MISUSE": "",
    "Step returned error code and last error failed to catch it": "",
    "{:?}": "",
    "single called with query that returns no rows.": "",
    "single called with a query that returns more than one row.": "",
    "Failed on step call": "",
    "Failed to parse row result": "",
    "Second step call": "",
    "maybe called with a query that returns more than one row.": "",
    "binding_multiple_statements_with_parameter_gaps": "",
    "\n            CREATE TABLE test (\n                col INTEGER\n            )": "",
    "\n                INSERT INTO test(col) VALUES (?3);\n                SELECT * FROM test WHERE col = ?1": "",
    "Could not bind parameter to first index": "",
    "Could not bind parameter to second index": "",
    "Could not bind parameter to third index": "",
    "blob_round_trips": "",
    "\n                CREATE TABLE blobs (\n                    data BLOB\n                )": "",
    "INSERT INTO blobs (data) VALUES (?)": "",
    "SELECT * FROM blobs": "",
    "DELETE FROM blobs": "",
    "maybe_returns_options": "",
    "\n                CREATE TABLE texts (\n                    text TEXT\n                )": "",
    "SELECT text FROM texts": "",
    "This is a test": "",
    "INSERT INTO texts VALUES (?)": ""
  },
  "zed/crates/sqlez/src/thread_safe_connection.rs": {
    "Db initialize query failed to execute: {}": "",
    "Migration never run": "",
    "thread_safe_multi_migration": "",
    "Queues are inserted when build is called. This should always succeed": "",
    "Write queue unexpectedly closed": "",
    "Initialize query failed to execute: {}": "",
    "Could not send write action to background thread": "",
    "test": "",
    "CREATE TABLE test(col1 TEXT, col2 TEXT) STRICT;": "",
    "annoying-test.db": "",
    "PRAGMA journal_mode=WAL": "",
    "\n                                PRAGMA synchronous=NORMAL;\n                                PRAGMA busy_timeout=1;\n                                PRAGMA foreign_keys=TRUE;\n                                PRAGMA case_sensitive_like=TRUE;\n                            ": "",
    "workspace": "",
    "\n                    CREATE TABLE workspaces(\n                        workspace_id INTEGER PRIMARY KEY,\n                        dock_visible INTEGER, -- Boolean\n                        dock_anchor TEXT, -- Enum: 'Bottom' / 'Right' / 'Expanded'\n                        dock_pane INTEGER, -- NULL indicates that we don't have a dock pane yet\n                        timestamp TEXT DEFAULT CURRENT_TIMESTAMP NOT NULL,\n                        FOREIGN KEY(dock_pane) REFERENCES panes(pane_id),\n                        FOREIGN KEY(active_pane) REFERENCES panes(pane_id)\n                    ) STRICT;\n\n                    CREATE TABLE panes(\n                        pane_id INTEGER PRIMARY KEY,\n                        workspace_id INTEGER NOT NULL,\n                        active INTEGER NOT NULL, -- Boolean\n                        FOREIGN KEY(workspace_id) REFERENCES workspaces(workspace_id)\n                            ON DELETE CASCADE\n                            ON UPDATE CASCADE\n                    ) STRICT;\n                ": "",
    "wild_zed_lost_failure": "",
    "PRAGMA FOREIGN_KEYS=true": ""
  },
  "zed/crates/sqlez/src/typed_statements.rs": {
    "Bindings failed": "",
    "Maybe row failed": ""
  },
  "zed/crates/streaming_diff/src/streaming_diff.rs": {
    "column out of bounds": "",
    "row out of bounds": "",
    "{:5}": "",
    "aaaa\\nbbbb": "",
    "\\ncccc": "",
    "aaaa\\nbbbb\\ncccc": "",
    "BBBB": "",
    "aaaa\\nbbbb\\ncccc\\ndddd": "",
    "A": "",
    "\\nEEEE": "",
    "aaaabbbb": "",
    "\\n": "",
    "\\n\\n": "",
    "aaaa\\n\\n\\nbbbb": "",
    "line1\\nline2\\nline3\\nline4": "",
    "inserted\\n": "",
    "\\nnewline": "",
    "line1\\ninserted\\nline3\\nnewline\\nline4": "",
    "        for y in 0..size.y() {\\n": "",
    "            let a = 10;\\n": "",
    "            let b = 20;\\n": "",
    "        }": "",
    "let": "",
    " mut": "",
    " y": "",
    " =": "",
    " 0": "",
    ";": "",
    "        while": "",
    " < size": "",
    ".": "",
    "y": "",
    "()": "",
    " {": "",
    "    y": "",
    " +=": "",
    " 1": "",
    "        ": "",
    "OLD_TEXT_LEN": "",
    "invalid `OLD_TEXT_LEN` variable": "",
    "old text: {:?}": "",
    "new text: {:?}": "",
    "char operations: {:?}": "",
    "line operations: {:?}": "",
    "ITERATIONS": "",
    "invalid `ITERATIONS` variable": "",
    "SEED": "",
    "invalid `SEED` variable": "",
    "Running test with {} iterations and seed {}": "",
    "Iteration {}": "",
    "Hello, world!": "",
    "Rust": "",
    "Hello, Rust!": "",
    "": ""
  },
  "zed/crates/tab_switcher/src/tab_switcher.rs": {
    "TabSwitcher": "",
    "{:?} {:?}": "",
    "": "",
    "Search all tabs…": "",
    "No tabs": "",
    "Invalid matches state: no element for index {ix}": "",
    "close-button": "",
    "close_tab": "",
    "Close": ""
  },
  "zed/crates/task/src/task_template.rs": {
    "snake_case": "",
    "regular": "",
    "main": "",
    "non_empty_string_vec": "",
    "non_empty_string_vec_json_schema": "",
    "default_true": "",
    "\\\\n": "",
    "hashing task template": "",
    "hashing task variables": "",
    "{id_base}_{task_hash}_{variables_hash}": "",
    "serializing the object": "",
    "Unknown variable name: {variable_name}": "",
    "${{{var}}}": "",
    "test_base": "",
    "test_label": "",
    "test_command": "",
    "test_arg": "",
    "test_env_key": "",
    "test_env_var": "",
    "": "",
    "should not resolve task with blank label and/or command: {task_with_blank_property:?}": "",
    "test task": "",
    "echo 4": "",
    "failed to resolve task {task_without_cwd:?}": "",
    "When neither task nor task context have cwd, it should be None": "",
    "a": "",
    "b": "",
    "c": "",
    "TaskContext's cwd should be taken on resolve if task's cwd is None": "",
    "d": "",
    "e": "",
    "f": "",
    "TaskTemplate's cwd should be taken on resolve if TaskContext's cwd is None": "",
    "TaskTemplate's cwd should be taken on resolve if TaskContext's cwd is not None": "",
    "custom_variable_1": "",
    "custom_variable_2": "",
    "01": "",
    "1234": "",
    "5678": "",
    "test_file": "",
    "test_selected_text": "",
    "/test_root/": "",
    "test_custom_variable_1": "",
    "test_custom_variable_2": "",
    "test label for {} and {}": "",
    "echo {} {}": "",
    "arg1 {}": "",
    "arg2 {}": "",
    "arg3 {}": "",
    "env_key_1": "",
    "env_key_2": "",
    "env_var_2 {} {}": "",
    "env_key_3": "",
    "env_var_3 {}": "",
    "Should successfully resolve task {task_with_all_variables:?} with variables {all_variables:?}": "",
    "Step {i}, for the same task template and context, there should be the same resolved task id": "",
    "Resolved task should store its template without changes": "",
    "test label for 1234 and {long_value}": "",
    "Resolved task label should be substituted with variables and those should not be shortened": "",
    "test label for 1234 and …{}": "",
    "Human-readable label should have long substitutions trimmed": "",
    "echo test_file {long_value}": "",
    "Command should be substituted with variables and those should not be shortened": "",
    "arg1 $ZED_SELECTED_TEXT": "",
    "arg2 $ZED_COLUMN": "",
    "arg3 $ZED_SYMBOL": "",
    "Args should not be substituted with variables": "",
    "{} arg1 test_selected_text arg2 5678 arg3 {long_value}": "",
    "Command label args should be substituted with variables and those should not be shortened": "",
    "env_var_2 test_custom_variable_1 test_custom_variable_2": "",
    "env_var_3 {long_value}": "",
    "Env vars should be substituted with variables and those should not be shortened": "",
    "If any of the Zed task variables is not substituted, the task should not be resolved, but got some resolution without the variable {removed_variable:?} (index {i})": "",
    "My task": "",
    "echo": "",
    "$PATH": "",
    "$ZED_VARIABLE": "",
    "test_symbol": "",
    "test_label_{}": "",
    "test_command_{}": "",
    "test_arg_{}": "",
    "test_env_var_{}": "",
    "Failed to resolve task {symbol_dependent_task:?}": "",
    "(index {i}) Expected the task to depend on symbol task variable: {resolved:?}": "",
    "go test {}/{}": "",
    "go": "",
    "^{}$/^{}$": "",
    "my-symbol": "",
    "base": "",
    "my symbol": "",
    "my task": "",
    "TASK_ENV_VAR1": "",
    "TASK_ENV_VAR1_VALUE": "",
    "TASK_ENV_VAR2": "",
    "PROJECT_ENV_WILL_BE_OVERWRITTEN": "",
    "overwritten": "",
    "PROJECT_ENV_VAR1": "",
    "PROJECT_ENV_VAR1_VALUE": "",
    "PROJECT_ENV_WILL_BE_OVERWRITTEN_VALUE": "",
    "env_var_2 1234 5678": ""
  },
  "zed/crates/task/src/vscode_format.rs": {
    "camelCase": "",
    "type": "",
    "dependsOn": "",
    "Encountered unsupported `dependsOn` key during deserialization": "",
    "Missing `type` field in task": "",
    "npm": "",
    "run": "",
    "gulp": "",
    "workspaceFolder": "",
    "file": "",
    "lineNumber": "",
    "selectedText": "",
    "Food": "",
    "$PATH is an environment variable": "",
    "${PATH}": "",
    "${PATH:food}": "",
    "PATH": "",
    "ZED_PATH": "",
    "${ZED_PATH} is an environment variable": "",
    "${ZED_PATH}": "",
    "${ZED_PATH:food}": "",
    "../test_data/typescript.json": "",
    "gulp: tests": "",
    "build:tests:notypecheck": "",
    "tsc: watch ./src": "",
    "node": "",
    "${workspaceFolder}/node_modules/typescript/lib/tsc.js": "",
    "--build": "",
    "${workspaceFolder}/src": "",
    "--watch": "",
    "npm: build:compiler": "",
    "build:compiler": "",
    "npm: build:tests": "",
    "${ZED_WORKTREE_ROOT}/node_modules/typescript/lib/tsc.js": "",
    "${ZED_WORKTREE_ROOT}/src": "",
    "../test_data/rust-analyzer.json": "",
    "Build Extension in Background": "",
    "watch": "",
    "Build Extension": "",
    "build": "",
    "Build Server": "",
    "cargo build --package rust-analyzer": "",
    "Build Server (Release)": "",
    "cargo build --release --package rust-analyzer": "",
    "Pretest": "",
    "pretest": "",
    "Build Server and Extension": "",
    "Build Server (Release) and Extension": ""
  },
  "zed/crates/tasks_ui/src/modal.rs": {
    "Find a task, or run a command in the central pane": "",
    "Find a task, or run a command": "",
    ".zed": "",
    ".vscode": "",
    "TasksModal": "",
    "\\n#{}": "",
    "": "",
    "tasks-modal-{ix}": "",
    "#{}": "",
    " ": "",
    "delete": "",
    "Delete Previously Scheduled Task": "",
    "Rerun Last Task": "",
    "edit-current-task": "",
    "Spawn Oneshot Without History": "",
    "Spawn Oneshot": "",
    "spawn-onehshot": "",
    "Rerun Without History": "",
    "Spawn Without History": "",
    "spawn": "",
    "Rerun": "",
    "Spawn": "",
    "/dir": "",
    "tasks.json": "",
    "[\n                        {\n                            ": "",
    ": ": "",
    ",\n                            ": "",
    ": [": "",
    "]\n                        },\n                        {\n                            ": "",
    "]\n                        },\n                    ]": "",
    "a.ts": "",
    "a": "",
    "Initial query should be empty": "",
    "another one": "",
    "example task": "",
    "With no global tasks and no open item, a single worktree should be used and its tasks listed": "",
    "/dir/a.ts": "",
    "Initial tasks should be listed in alphabetical order": "",
    "tas": "",
    "Only one task should match the query {query_str}": "",
    "echo 4": "",
    "Query should be set to the selected task's command": "",
    "No task should be listed": "",
    "Query should be reset after confirming": "",
    "New oneshot task should be listed first": "",
    "New oneshot should match custom command query": "",
    "Last recently used one show task should be listed first": "",
    "Query should be set to the custom task's name": "",
    "Only custom task should be listed": "",
    "0": "",
    "echo 40": "",
    "New oneshot should not match any command query": "",
    "No query should be added to the list, as it was submitted with secondary action (that maps to omit_history = true)": "",
    ", ": "",
    "]\n                        }\n                    ]": "",
    "file_without_extension": "",
    "aaaaaaaaaaaaaaaaaaaa\\naaaaaaaaaaaaaaaaaa": "",
    "file_with.odd_extension": "",
    "b": "",
    "opened now: ": "",
    "When no file is open for a single worktree, should autodetect all worktree-related tasks": "",
    "/dir/file_with.odd_extension": "",
    "hello from ": "",
    "/dir/file_with.odd_extension:1:1": "",
    "Second opened buffer should fill the context, labels should be trimmed if long enough": "",
    "/dir/file_without_extension": "",
    "/dir/file_without_extension:2:3": "",
    "Opened buffer should fill the context, labels should be trimmed if long enough": "",
    "a1.ts": "",
    "// a1": "",
    "a2.ts": "",
    "// a2": "",
    "b.rs": "",
    "// b": "",
    "TypeScript": "",
    "ts": "",
    "Task without variables": "",
    "npm run clean": "",
    "TypeScript task from file $ZED_FILE": "",
    "npm run build": "",
    "Another task from file $ZED_FILE": "",
    "npm run lint": "",
    "Rust": "",
    "rs": "",
    "Rust task": "",
    "cargo check": "",
    "/dir/a1.ts": "",
    "Another task from file ": "",
    "TypeScript task from file ": "",
    "Should open spawn TypeScript tasks for the opened file, tasks with most template variables above, all groups sorted alphanumerically": "",
    "After spawning the task and getting it into the history, it should be up in the sort as recently used.\n            Tasks with the same labels and context are deduplicated.": "",
    "/dir/a2.ts": "",
    "Even when both TS files are open, should only show the history (on the top), and tasks, resolved for the current file": "",
    "/dir/b.rs": "",
    "Even when both TS files are open and one TS task spawned, opened file's language tasks should be displayed only": "",
    "\n        );\n    }\n\n    fn emulate_task_schedule(\n        tasks_picker: Entity<Picker<TasksModalDelegate>>,\n        project: &Entity<Project>,\n        scheduled_task_label: &str,\n        cx: &mut VisualTestContext,\n    ) {\n        let scheduled_task = tasks_picker.read_with(cx, |tasks_picker, _| {\n            tasks_picker\n                .delegate\n                .candidates\n                .iter()\n                .flatten()\n                .find(|(_, task)| task.resolved_label == scheduled_task_label)\n                .cloned()\n                .unwrap()\n        });\n        project.update(cx, |project, cx| {\n            if let Some(task_inventory) = project.task_store().read(cx).task_inventory().cloned() {\n                task_inventory.update(cx, |inventory, _| {\n                    let (kind, task) = scheduled_task;\n                    inventory.task_scheduled(kind, task);\n                });\n            }\n        });\n        tasks_picker.update(cx, |_, cx| {\n            cx.emit(DismissEvent);\n        });\n        drop(tasks_picker);\n        cx.executor().run_until_parked()\n    }\n\n    fn open_spawn_tasks(\n        workspace: &Entity<Workspace>,\n        cx: &mut VisualTestContext,\n    ) -> Entity<Picker<TasksModalDelegate>> {\n        cx.dispatch_action(Spawn::modal());\n        workspace.update(cx, |workspace, cx| {\n            workspace\n                .active_modal::<TasksModal>(cx)\n                .expect(": ""
  },
  "zed/crates/terminal/src/terminal.rs": {
    "macos": "",
    "<non-utf8 path> {}": "",
    "<none specified, using home directory> {}": "",
    "<none specified, could not find home directory>": "",
    "<system defined shell>": "",
    "{} {} ({})": "",
    " ": "",
    "{} {}": "",
    "Working directory: {} Shell command: `{}`, IOError: {}": "",
    "LANG": "",
    "en_US.UTF-8": "",
    "ZED_TERM": "",
    "true": "",
    "TERM_PROGRAM": "",
    "zed": "",
    "TERM": "",
    "xterm-256color": "",
    "TERM_PROGRAM_VERSION": "",
    "windows": "",
    "": "",
    "set color": "",
    "linux": "",
    "freebsd": "",
    "h": "",
    "left": "",
    "j": "",
    "down": "",
    "k": "",
    "up": "",
    "l": "",
    "right": "",
    "w": "",
    "b": "",
    "e": "",
    "%": "",
    "$": "",
    "0": "",
    "^": "",
    "H": "",
    "M": "",
    "L": "",
    "g": "",
    "G": "",
    "f": "",
    "d": "",
    "u": "",
    "v": "",
    "escape": "",
    "y": "",
    "i": "",
    "{}{}{}": "",
    "\\x1b[200~": "",
    "\\x1b[201~": "",
    "\\r\\n": "",
    "\\r": "",
    "\\x1b[I": "",
    "\\x1b[O": "",
    "{}{}": "",
    " {}": "",
    "{process_file} — {process_name}": "",
    "Terminal": "",
    "⏵ ": "",
    "{TASK_DELIMITER}Task `{escaped_full_label}` finished successfully": "",
    "{TASK_DELIMITER}Task `{escaped_full_label}` finished with non-zero error code: {error_code}": "",
    "{TASK_DELIMITER}Task `{escaped_full_label}` finished": "",
    "{TASK_DELIMITER}Command: {escaped_command_label}": "",
    "less public": "",
    "proper": ""
  },
  "zed/crates/terminal_view/src/persistence.rs": {
    "no window present": "",
    "horizontal": "",
    "vertical": "",
    "Invalid axis value: '{invalid}'": "",
    "Saving working directory {working_directory:?} for item {item_id} in workspace {workspace_id:?}": "",
    "INSERT INTO terminals(item_id, workspace_id, working_directory, working_directory_path)\n            VALUES (?1, ?2, ?3, ?4)\n            ON CONFLICT DO UPDATE SET\n                item_id = ?1,\n                workspace_id = ?2,\n                working_directory = ?3,\n                working_directory_path = ?4": ""
  },
  "zed/crates/terminal_view/src/terminal_panel.rs": {
    "TerminalPanel": "",
    "terminal-tab-bar-popover-menu": "",
    "plus": "",
    "New…": "",
    "New Terminal": "",
    "Spawn task": "",
    "terminal-pane-tab-bar-split": "",
    "terminal-pane-split": "",
    "Split Pane": "",
    "Split Right": "",
    "Split Left": "",
    "Split Up": "",
    "Split Down": "",
    "toggle_zoom": "",
    "Zoom Out": "",
    "Zoom In": "",
    "{:?}-{:?}": "",
    "Project is not local": "",
    "terminal not yet supported for remote projects": "",
    "retrieving active terminal item in the workspace": "",
    " {path:?}": "",
    "": "",
    "Terminal Panel": "",
    "terminal_inline_assistant": "",
    "Inline Assist": ""
  },
  "zed/crates/terminal_view/src/terminal_tab_tooltip.rs": {
    "Process ID (PID): {}": ""
  },
  "zed/crates/terminal_view/src/terminal_view.rs": {
    "a": "",
    "b": "",
    "New Terminal": "",
    "Copy": "",
    "Paste": "",
    "Select All": "",
    "Clear": "",
    "Inline Assist": "",
    "Close Terminal Tab": "",
    "ctrl-cmd-space": "",
    "Terminal": "",
    "vi_mode": "",
    "screen": "",
    "alt": "",
    "normal": "",
    "DECCKM": "",
    "DECPAM": "",
    "DECPNM": "",
    "DECTCEM": "",
    "DECAWM": "",
    "DECOM": "",
    "IRM": "",
    "LNM": "",
    "report_focus": "",
    "alternate_scroll": "",
    "bracketed_paste": "",
    "any_mouse_reporting": "",
    "click": "",
    "drag": "",
    "motion": "",
    "off": "",
    "mouse_reporting": "",
    "sgr": "",
    "utf8": "",
    "mouse_format": "",
    "terminal-view-scroll": "",
    "rerun-icon": "",
    "Rerun task": "",
    "workspace update": "",
    "Received {} items for one path {path_to_open:?}": "",
    ".": "",
    "easily": "",
    "~": "",
    "": "",
    "terminal-view": "",
    "term-tab-icon": "",
    "Updating workspace id for the terminal, old: {old_id:?}, new: {new_id:?}": "",
    "terminals": "",
    "/root.txt": "",
    "/root/": "",
    "/root1/": "",
    "/root2.txt": "",
    "/root2/": ""
  },
  "zed/crates/text/src/text.rs": {
    "test-support": "",
    "\\r\\n|\\r": "",
    "Failed to create LINE_SEPARATORS_REGEX": "",
    "{}": "",
    "Buffer id cannot be 0.": "",
    "gave up waiting for edits": "",
    "gave up waiting for anchors": "",
    "gave up waiting for version": "",
    "invalid edit": "",
    "fragment: {:?}\\ninsertion: {:?}": "",
    "\\r\\n": "",
    "mutating buffer {} with {:?}": "",
    "undoing buffer {} transaction {:?}": "",
    "invalid insertion": "",
    "invalid anchor {:?}. buffer id: {}, version: {:?}": "",
    "invalid version": "",
    "offset {} is out of range, max allowed is {}": "",
    "\\n": ""
  },
  "zed/crates/theme_importer/src/assets.rs": {
    "../../assets": "",
    "fonts/**/*": "",
    "*.DS_Store": "",
    "could not find asset at path {path:?}": ""
  },
  "zed/crates/theme_importer/src/main.rs": {
    "https://zed.dev/schema/themes/v0.2.0.json": "",
    "snake_case": "",
    "theme_printer": "",
    "could not initialize logger": "",
    "Failed to open file at path: {:?}": "",
    "failed to parse theme {theme_file_path:?}": "",
    "": "",
    "$schema": "",
    "{}": "",
    "Done!": ""
  },
  "zed/crates/theme_selector/src/theme_selector.rs": {
    "error loading theme {}: {}": "",
    "Select Theme...": "",
    "Settings Changed": "",
    "theme": "",
    "docs": "",
    "View Theme Docs": "",
    "https://zed.dev/docs/themes": "",
    "more-themes": "",
    "Install Themes": ""
  },
  "zed/crates/theme_selector/src/icon_theme_selector.rs": {
    "error loading icon theme {}: {err}": "",
    "Select Icon Theme...": "",
    "Settings Changed": "",
    "icon_theme": "",
    "docs": "",
    "View Icon Theme Docs": "",
    "https://zed.dev/docs/icon-themes": "",
    "more-icon-themes": "",
    "Install Icon Themes": ""
  },
  "zed/crates/time_format/src/time_format.rs": {
    "2021-12-31 3:00AM": "",
    "Today at x": "",
    "Yesterday at x": "",
    "Today at 12:00 PM": "",
    "Yesterday at 11:00 AM": "",
    "Feb. 24, 2024": "",
    "just now": "",
    "1 minute ago": "",
    "2 hours ago": "",
    "2 months ago": "",
    "macos": "",
    "Today": "",
    "Yesterday": "",
    "en-US": "",
    "{} {}": "",
    "Today at {}": "",
    "Yesterday at {}": "",
    "Just now": "",
    "{} minutes ago": "",
    "1 hour ago": "",
    "{} hours ago": "",
    "{} days ago": "",
    "1 week ago": "",
    "{} weeks ago": "",
    "1 month ago": "",
    "{} months ago": "",
    "1 year ago": "",
    "{} years ago": "",
    "PM": "",
    "AM": "",
    "{}:{:02} {}": "",
    "{:02}:{:02}": "",
    "{:02}/{:02}/{}": "",
    "es-MX": "",
    "es-CO": "",
    "es-SV": "",
    "es-NI": "",
    "es-HN": "",
    "en-CA": "",
    "en-AU": "",
    "en-NZ": "",
    "ar-SA": "",
    "ar-EG": "",
    "ar-JO": "",
    "en-IN": "",
    "hi-IN": "",
    "en-PK": "",
    "ur-PK": "",
    "en-PH": "",
    "fil-PH": "",
    "bn-BD": "",
    "ccp-BD": "",
    "en-IE": "",
    "ga-IE": "",
    "en-MY": "",
    "ms-MY": "",
    "9:30 AM": "",
    "09:30": "",
    "3:45 PM": "",
    "15:45": "",
    "Today at 15:30": "",
    "Today at 3:30 PM": "",
    "Yesterday at 9:00 AM": "",
    "Yesterday at 8:00 PM": "",
    "Yesterday at 6:00 PM": "",
    "Yesterday at 11:55 PM": "",
    "04/10/1990 8:20 PM": "",
    "4 weeks ago": "",
    "Valid timezone offset": ""
  },
  "zed/crates/title_bar/src/application_menu.rs": {
    "macos": "",
    "{}-menu-item": "",
    "{}-menu-popover": "",
    "{}-menu-trigger": "",
    "Open Application Menu": "",
    "ApplicationMenu": ""
  },
  "zed/crates/title_bar/src/collab.rs": {
    "Screen Share Disabled": "",
    "Screen Share Enabled": "",
    "Sharing Screen Failed": "",
    "{:?}\\n\\nPlease check that you have given Zed permissions to record your screen in Settings.": "",
    "Microphone Enabled": "",
    "Microphone Disabled": "",
    "collaborator-list": "",
    "collaborator": "",
    "Follow {login}": "",
    "{} is muted": "",
    "+{extra_count}": "",
    "toggle_sharing": "",
    "Unshare": "",
    "Share": "",
    "Stop sharing project with call participants": "",
    "Share project with call participants": "",
    "leave-call": "",
    "Leave call": "",
    "mute-microphone": "",
    "Unmute Microphone": "",
    "Audio will be unmuted": "",
    "Mute Microphone": "",
    "mute-sound": "",
    "Unmute Audio": "",
    "Microphone will be unmuted": "",
    "Mute Audio": "",
    "Microphone will be muted": "",
    "screen-share": "",
    "Stop Sharing Screen": "",
    "Share Screen": ""
  },
  "zed/crates/title_bar/src/title_bar.rs": {
    "stories": "",
    "macos": "",
    "title-bar": "",
    "linux": "",
    "freebsd": "",
    "titlebar": "",
    "titlebar-content": "",
    "ZED_USE_CROSS_PLATFORM_MENU": "",
    "Agentic Onboarding": "",
    "Agentic Editing": "",
    "windows": "",
    "Connecting to: {host}": "",
    "Connected to: {host}": "",
    "Connection attempt to {host} missed. Retrying...": "",
    "Lost connection to {host}. Reconnecting...": "",
    "Disconnected from {host}": "",
    "ssh-server-icon": "",
    "Remote Project": "",
    "disconnected": "",
    "Disconnected": "",
    "project_owner_trigger": "",
    "{} is sharing this project. Click to follow.": "",
    "Open recent project": "",
    "project_name_trigger": "",
    "Recent Projects": "",
    "project_branch_trigger": "",
    "Recent Branches": "",
    "Local branches only": "",
    "Please restart Zed to Collaborate": "",
    "Updating...": "",
    "Please update Zed to Collaborate": "",
    "connection-status": "",
    "sign_in": "",
    "Sign in": "",
    "user-menu": "",
    "Current Plan: {}": "",
    "None": "",
    "Zed Free": "",
    "Zed Pro": "",
    "Zed Pro (Trial)": "",
    "Settings": "",
    "Key Bindings": "",
    "Themes…": "",
    "Icon Themes…": "",
    "Extensions": "",
    "Sign Out": "",
    "Toggle User Menu": ""
  },
  "zed/crates/toolchain_selector/src/active_toolchain.rs": {
    "Toolchain": "",
    "change-toolchain": "",
    "Select {}": ""
  },
  "zed/crates/toolchain_selector/src/toolchain_selector.rs": {
    "worktree root": "",
    "`{}`": "",
    "Select a {} for {pretty_path}…": "",
    "Select a toolchain…": "",
    ".": "",
    "{}{}": ""
  },
  "zed/crates/util/src/paths.rs": {
    "failed to determine home directory": "",
    "Invalid WTF-8 sequence: {bytes:?}": "",
    "linux": "",
    "freebsd": "",
    "macos": "",
    "~": "",
    "windows": "",
    "/": "",
    "\\\\": "",
    "sanitized": "",
    "(?xs)\n    ([^\\(]+)(?:\n        \\((\\d+)[,:](\\d+)\\) # filename(row,column), filename(row:column)\n        |\n        \\((\\d+)\\)()     # filename(row)\n    )\n    |\n    (.+?)(?:\n        \\:+(\\d+)\\:(\\d+)\\:*$  # filename:row:column\n        |\n        \\:+(\\d+)\\:*()$       # filename:row\n    )": "",
    "test_file": "",
    "test_file:10": "",
    "test_file.rs": "",
    "test_file.rs:1": "",
    "test_file.rs:1:2": "",
    "test_file.rs:a": "",
    "test_file.rs:a:b": "",
    "test_file.rs::": "",
    "test_file.rs::1": "",
    "test_file.rs:1::": "",
    "test_file.rs::1:2": "",
    "test_file.rs:1::2": "",
    "test_file.rs:1:2:3": "",
    "digit or random string": "",
    "rsplitn should have the rest of the string as its last parameter that we reversed": "",
    "{path_string}:{row}:{column}": "",
    "{path_string}:{row}": "",
    "test_dirs": "",
    "test_dirs/1.46": "",
    "test_dirs/1.46/bar_1": "",
    "test_dirs/1.46/bar_2": "",
    "test_dirs/1.45": "",
    "test_dirs/1.45/foo_2": "",
    "test_dirs/1.45/foo_1": "",
    "root1/one.txt": "",
    "root1/one.two.txt": "",
    "test_dirs/file.rs": "",
    "test_dirs/file.txt": "",
    "test_dirs/file.md": "",
    "test_dirs/file": "",
    "test_dirs/file.a": "",
    "test_DIRS": "",
    "test_DIRS/foo_1": "",
    "test_DIRS/foo_2": "",
    "test_DIRS/bar": "",
    "test_DIRS/BAR": "",
    "test_dirs/foo_1": "",
    "test_dirs/foo_2": "",
    "test_dirs/bar": "",
    "test_dirs/BAR": "",
    "a:bc:.zip:1": "",
    "a:bc:.zip": "",
    "one.second.zip:1": "",
    "one.second.zip": "",
    "test_file:10:1:": "",
    "test_file.rs:": "",
    "test_file.rs:1:": "",
    "ab\\ncd": "",
    "👋\\nab": "",
    "foo/bar:34:in": "",
    "foo/bar": "",
    "foo/bar.rs:1902:::15:": "",
    "foo/bar.rs:1902": "",
    "app-editors:zed-0.143.6:20240710-201212.log:34:": "",
    "app-editors:zed-0.143.6:20240710-201212.log": "",
    "crates/file_finder/src/file_finder.rs:1902:13:": "",
    "crates/file_finder/src/file_finder.rs": "",
    "crate/utils/src/test:today.log:34": "",
    "crate/utils/src/test:today.log": "",
    "/testing/out/src/file_finder.odin(7:15)": "",
    "/testing/out/src/file_finder.odin": "",
    "crates\\\\utils\\\\paths.rs": "",
    "C:\\\\Users\\\\someone\\\\test_file.rs": "",
    "crates\\\\utils\\\\paths.rs:101": "",
    "\\\\\\\\?\\\\C:\\\\Users\\\\someone\\\\test_file.rs:1:20": "",
    "\\\\\\\\?\\\\C:\\\\Users\\\\someone\\\\test_file.rs": "",
    "C:\\\\Users\\\\someone\\\\test_file.rs(1902,13)": "",
    "\\\\\\\\?\\\\C:\\\\Users\\\\someone\\\\test_file.rs:1902:13:": "",
    "\\\\\\\\?\\\\C:\\\\Users\\\\someone\\\\test_file.rs:1902:13:15:": "",
    "\\\\\\\\?\\\\C:\\\\Users\\\\someone\\\\test_file.rs:1902": "",
    "\\\\\\\\?\\\\C:\\\\Users\\\\someone\\\\test_file.rs:1902:::15:": "",
    "\\\\\\\\?\\\\C:\\\\Users\\\\someone\\\\test_file.rs(1902,13):": "",
    "\\\\\\\\?\\\\C:\\\\Users\\\\someone\\\\test_file.rs(1902):": "",
    "C:\\\\Users\\\\someone\\\\test_file.rs:1902:13:": "",
    "C:\\\\Users\\\\someone\\\\test_file.rs(1902,13):": "",
    "C:\\\\Users\\\\someone\\\\test_file.rs(1902):": "",
    "crates/utils/paths.rs:101": "",
    "some_file.txt": "",
    "~/some_file.txt": "",
    "/a/b/c/file_name.rs": "",
    "rs": "",
    "/a/b/c/file.name.rs": "",
    "/a/b/c/long.file.name.rs": "",
    "/a/b/c/.gitignore": "",
    "gitignore": "",
    "/a/b/c/.eslintrc.js": "",
    "eslintrc.js": "",
    "/work/node_modules": "",
    "**/node_modules/**": "",
    "Path matcher should match {path:?}": "",
    "/Users/someonetoignore/work/zed/zed.dev/node_modules": ""
  },
  "zed/crates/util/src/test.rs": {
    ".git": "",
    "JSON object must contain only objects, strings, or null": "",
    "You must pass a JSON object to this helper": ""
  },
  "zed/crates/util/src/util.rs": {
    "test-support": "",
    "{}\\n{:?}": "",
    "...": "",
    "…": "",
    "\\n": "",
    "\\n…": "",
    "": "",
    "Line 1\\nLine 2\\nLine 3\\nLine 4": "",
    "Line 1\\n": "",
    "Line 1\\nLine 2\\n": "",
    "Line ": "",
    "Line 1\\nLíne 2\\nLine 3": "",
    "Line 1\\nLíne 2\\n": "",
    "call to getpwuid_r failed. uid: {}, status: {}": "",
    "passwd entry for uid {} not found": "",
    "passwd entry has different uid ({}) than getuid ({}) returned": "",
    "SHELL": "",
    "updating SHELL environment variable to value from passwd entry: {:?}": "",
    "set environment variables from shell:{}, path:{}": "",
    "PATH": "",
    "windows": "",
    "ZED_MEASUREMENTS": "",
    "1": "",
    "true": "",
    "{}: {:?}": "",
    "64": "",
    "ProgramFiles(x86)": "",
    "ProgramFiles": "",
    "32": "",
    "ProgramW6432": "",
    "PowerShell": "",
    "preview": "",
    "pwsh.exe": "",
    "LOCALAPPDATA": "",
    "Microsoft\\\\WindowsApps": "",
    "Microsoft.PowerShellPreview_": "",
    "Microsoft.PowerShell_": "",
    "USERPROFILE": "",
    "scoop\\\\shims\\\\pwsh.exe": "",
    "powershell.exe": "",
    "{reason} - {error:?}": "",
    "/": "",
    "{:?}": "",
    "SIMPLE_TEXT": "",
    "a": "",
    "A": "",
    "hello": "",
    "Hello": "",
    "WORLD": "",
    "(\\\\p{Emoji}|\\u{200D})": "",
    "👨‍👩‍👧‍👧👋": "",
    "👋!": "",
    "/bin/sh": "",
    "Request timed out": "",
    "Server reset the connection": "",
    "aaaaaa": "",
    "aaaaa…": "",
    "èèèèèè": "",
    "èèèèè…": "",
    "…aaaaa": "",
    "…èèèèè": "",
    "1a": "",
    "12ab": "",
    "ab": "",
    "12_ab": "",
    "_ab": "",
    "1_2ab": "",
    "_2ab": "",
    "1.2": "",
    ".2": "",
    "1.2_a": "",
    ".2_a": "",
    "12.2_a": "",
    "12a.2_a": "",
    "a.2_a": "",
    "1-abc": "",
    "10": "",
    "11def": "",
    "2": "",
    "21-abc": "",
    "numeric_prefix_less": "",
    "aaa": "",
    "~™£": "",
    "String without numeric prefix `{numeric_prefix_less}` should not be converted into NumericPrefixWithSuffix": "",
    "👨‍👩‍👧‍👧👋🥒": "",
    "👋": "",
    "!👋": "",
    "👋 ": "",
    " 👋": "",
    "Test": "",
    "Line 1\nLine 2\nLine 3": "",
    "Line 1\n…": "",
    "Line 1\nLine 2\n…": "",
    "hi": "",
    "héllo🦀world": "",
    "héllo": "",
    "world": ""
  },
  "zed/crates/vim/src/change_list.rs": {
    ".": "",
    "ˇ": "",
    "i 1 1 escape shift-o 2 2 escape shift-g o 3 3 escape": "",
    "22\n             11\n             3ˇ3": "",
    "g ;": "",
    "2ˇ2\n             11\n             33": "",
    "22\n             1ˇ1\n             33": "",
    "g ,": "",
    "shift-g i 4 4 escape": "",
    "22\n             11\n             34ˇ43": "",
    "2ˇ2\n             11\n             3443": "",
    "one two\n        three fˇour": "",
    "x k d i w ^ x": "",
    "ˇne•\n        three fur": "",
    "2 g ;": "",
    "ne•\n        three fˇur": "",
    "one two\n        three fˇr": "",
    "i o escape k g i": "",
    "u escape": "",
    "one two\n        three foˇur": "",
    "i o escape k ` .": "",
    "one two\n        three fˇor": ""
  },
  "zed/crates/vim/src/mode_indicator.rs": {
    "recording @{reg} ": "",
    "{}": "",
    "\\\"{reg}": "",
    "": "",
    "(insert) {}": "",
    "{} -- {} --": ""
  },
  "zed/crates/vim/src/normal.rs": {
    "Unexpected normal mode motion operator: {:?}": "",
    "^": "",
    "\\n": "",
    "[No Name]": "",
    " [modified]": "",
    "": "",
    "{}{} {} lines --{:.0}%--": "",
    "\\r": "",
    "h": "",
    "\n            ˇThe qˇuick\n            ˇbrown": "",
    "backspace": "",
    "\n            aaˇaa\n            😃😃": "",
    "j": "",
    "\n            aaaa\n            😃ˇ😃": "",
    "\n                ˇThe qˇuick broˇwn\n                ˇfox jumps": "",
    "enter": "",
    "\n            ˇThe qˇuick broˇwn\n            ˇfox jumps": "",
    "k": "",
    "\n            ˇThe qˇuick\n            ˇbrown fˇox jumˇps": "",
    "l": "",
    "\n            ˇThe qˇuicˇk\n            ˇbrowˇn": "",
    "$": "",
    "0": "",
    "\n                ˇThe qˇuicˇk\n                ˇbrowˇn": "",
    "shift-g": "",
    "\n                The ˇquick\n\n                brown fox jumps\n                overˇ the lazy doˇg": "",
    "\n            The quiˇck\n\n            brown": "",
    "\n            The quiˇck\n\n            ": "",
    "w": "",
    "\n            The ˇquickˇ-ˇbrown\n            ˇ\n            ˇ\n            ˇfox_jumps ˇover\n            ˇthˇe": "",
    "shift-w": "",
    "e": "",
    "\n            Thˇe quicˇkˇ-browˇn\n\n\n            fox_jumpˇs oveˇr\n            thˇe": "",
    "shift-e": "",
    "b": "",
    "\n            ˇThe ˇquickˇ-ˇbrown\n            ˇ\n            ˇ\n            ˇfox_jumps ˇover\n            ˇthe": "",
    "shift-b": "",
    "g g": "",
    "\n                The qˇuick\n\n                brown fox jumps\n                over ˇthe laˇzy dog": "",
    "\n\n\n                brown fox jumps\n                over the laˇzy dog": "",
    "2 g g": "",
    "\n                ˇ\n\n                brown fox jumps\n                over the lazydog": "",
    "2 shift-g": "",
    "a": "",
    "The qˇuicˇk": "",
    "shift-a": "",
    "\n            ˇ\n            The qˇuick\n            brown ˇfox ": "",
    "The qˇuick": "",
    " The qˇuick": "",
    "ˇ": "",
    "\n                The qˇuick\n                brown fox": "",
    "\n                ˇ\n                The quick": "",
    "   ˇ \\nThe quick": "",
    "shift-i": "",
    "shift-d": "",
    "\n                The quick\n                ˇ\n                brown fox": "",
    "x": "",
    "ˇTeˇsˇt": "",
    "\n                Tesˇt\n                test": "",
    "shift-x": "",
    "ˇTˇeˇsˇt": "",
    "\n                Test\n                ˇtest": "",
    "o": "",
    "The ˇquick": "",
    "\n                The qˇuick\n                brown ˇfox\n                jumps ˇover": "",
    "\n                fn test() {\n                    println!(ˇ);\n                }": "",
    "\n                fn test() {\n                    println!();\n                    ˇ\n                }": "",
    "\n                fn test(ˇ) {\n                    println!();\n                }": "",
    "\n                fn test() {\n                    ˇ\n                    println!();\n                }": "",
    "shift-o": "",
    "\n            The qˇuick\n            brown ˇfox\n            jumps ˇover": "",
    "\n            The quick\n            ˇ\n            brown fox": "",
    "\n                ˇ\n                fn test() {\n                    println!();\n                }": "",
    "[ space": "",
    "3 [ space": "",
    "] space": "",
    "3 ] space": "",
    "d d": "",
    "c c": "",
    "\n                The quˇick\n                brown ˇfox\n                jumps ˇover": "",
    "{count} w": "",
    "\n                    ˇThe quˇickˇ browˇn\n                    ˇ\n                    ˇfox ˇjumpsˇ-ˇoˇver\n                    ˇthe lazy dog\n                ": "",
    "Testˇ├ˇ──ˇ┐ˇTest": "",
    "\n                ˇaaaˇbˇ ˇbˇ   ˇbˇbˇ aˇaaˇbaaa\n                ˇ    ˇbˇaaˇa ˇbˇbˇb\n                ˇ\n                ˇb\n            ": "",
    "{count} f b": "",
    "{count} t b": "",
    "\n            ˇaaaˇbˇ ˇbˇ   ˇbˇbˇ aˇaaˇbaaa\n            ˇ    ˇbˇaaˇa ˇbˇbˇb\n            ˇ•••\n            ˇb\n            ": "",
    "{count} shift-f b": "",
    "{count} shift-t b": "",
    "f l": "",
    "\n            ˇfunction print() {\n                console.log('ok')\n            }\n            ": "",
    "\n            function print() {\n                consoˇle.log('ok')\n            }\n            ": "",
    "t l": "",
    "\n            function print() {\n                consˇole.log('ok')\n            }\n            ": "",
    "shift-f p": "",
    "\n            function print() {\n                console.ˇlog('ok')\n            }\n            ": "",
    "\n            function ˇprint() {\n                console.log('ok')\n            }\n            ": "",
    "shift-t p": "",
    "\n            function pˇrint() {\n                console.log('ok')\n            }\n            ": "",
    "f p": "",
    "ˇfmt.Println(\\\"Hello, World!\\\")": "",
    "fmt.ˇPrintln(\\\"Hello, World!\\\")": "",
    "fmt.Printlnˇ(\\\"Hello, World!\\\")": "",
    "t p": "",
    "fmtˇ.Println(\\\"Hello, World!\\\")": "",
    "fmt.Pˇrintln(\\\"Hello, World!\\\")": "",
    "%": "",
    "ˇconsole.logˇ(ˇvaˇrˇ)ˇ;": "",
    "ˇconsole.logˇ(ˇ'var', ˇ[ˇ1, ˇ2, 3ˇ]ˇ)ˇ;": "",
    "let result = curried_funˇ(ˇ)ˇ(ˇ)ˇ;": "",
    "ˇaa\\nbb\\ncc": "",
    "aˇa\\nbb\\ncc": "",
    "2 $": "",
    "aa\\nbˇb\\ncc": "",
    "4 $": "",
    "aa\\nbb\\ncˇc": "",
    "Editor && VimControl && !VimWaiting && !menu": "",
    "g e": "",
    "ˇassert_binding": "",
    "assert_ˇbinding": "",
    "c w": "",
    "ˇ_binding": "",
    "asserˇt_binding": "",
    "assert_bindinˇg": "",
    "ˇhello\\n": "",
    "r -": "",
    "ˇ-ello\\n": "",
    "3 r -": "",
    "--ˇ-lo\\n": "",
    "r - 2 l .": "",
    "-eˇ-lo\\n": "",
    "ˇhello world\\n": "",
    "2 r - f w .": "",
    "--llo -ˇ-rld\\n": "",
    "2 0 r - ": "",
    "  helloˇ world\\n": "",
    "r enter": "",
    "  hello\\n ˇ world\\n": "",
    "2 r enter": "",
    "  hello\\n ˇ orld\\n": "",
    "textwidth=5": "",
    "ˇth th th th th th\\n": "",
    "g q q": "",
    "th th\\nth th\\nˇth th\\n": "",
    "ˇth th th th th th\\nth th th th th th\\n": "",
    "v j g q": "",
    "th th\\nth th\\nth th\\nth th\\nth th\\nˇth th\\n": "",
    "filetype=rust": "",
    "// helloˇ\\n": "",
    "// hello\\n// ˇ\\n": "",
    "x escape shift-o": "",
    "// hello\\n// ˇ\\n// x\\n": "",
    "heˇllo\\n": "",
    "y y p": "",
    "hello\\nˇhello\\n": "",
    "heˇllo": "",
    "hello\\nˇhello": "",
    "heˇllo\\nhello": "",
    "2 y y p": "",
    "hello\\nˇhello\\nhello\\nhello": "",
    "p p": "",
    "\\nhello\\nˇhello": "",
    "v i w shift-i": "",
    "ˇhello": "",
    "\n            The quick brown\n            fox ˇjumps over\n            the lazy dog": "",
    "shift-v shift-i": "",
    "\n            The quick brown\n            ˇfox jumps over\n            the lazy dog": "",
    "shift-v shift-a": "",
    "\n            The quick brown\n            fox jˇumps over\n            the lazy dog": ""
  },
  "zed/crates/vim/src/surrounds.rs": {
    "{}\\n": "",
    "\\n{}": "",
    " ": "",
    "": "",
    "{}{}": "",
    "hello in a word": "",
    "b": "",
    ")": "",
    "B": "",
    "}": "",
    "a": "",
    ">": "",
    "r": "",
    "]": "",
    "{": "",
    "'": "",
    "`": "",
    "\\\"": "",
    "(": "",
    "|": "",
    "[": "",
    "<": "",
    "\n            The quˇick brown\n            fox jumps over\n            the lazy dog.": "",
    "y s i w {": "",
    "\n            The ˇ{ quick } brown\n            fox jumps over\n            the lazy dog.": "",
    "y s i w }": "",
    "\n            The ˇ{quick} brown\n            fox jumps over\n            the lazy dog.": "",
    "y s $ }": "",
    "\n            The quˇ{ick brown}\n            fox jumps over\n            the lazy dog.": "",
    "\n            The quˇick brown\n            fox jumps over\n            the laˇzy dog.": "",
    "y s i w '": "",
    "\n            The ˇ'quick' brown\n            fox jumps over\n            the ˇ'lazy' dog.": "",
    "y s $ '": "",
    "\n            The quˇ'ick brown'\n            fox jumps over\n            the laˇ'zy dog.'": "",
    "y s $ 1": "",
    "\n            The quˇ1ick brown1\n            fox jumps over\n            the laˇ1zy dog.1": "",
    "y s s {": "",
    "\n            ˇ{ The quick brown }\n            fox jumps over\n            the lazy dog.": "",
    "\n                The quˇick brown•\n            fox jumps over\n            the lazy dog.": "",
    "\n                ˇ{ The quick brown }•\n            fox jumps over\n            the lazy dog.": "",
    "2 y s s )": "",
    "\n                ˇ({ The quick brown }•\n            fox jumps over)\n            the lazy dog.": "",
    "\n            The [quˇick] brown\n            fox jumps over\n            the lazy dog.": "",
    "y s a ] )": "",
    "\n            The ˇ([quick]) brown\n            fox jumps over\n            the lazy dog.": "",
    "y s i ] )": "",
    "\n            The [ˇ(quick)] brown\n            fox jumps over\n            the lazy dog.": "",
    "shift-s": "",
    "vim_mode == visual": "",
    "v i w shift-s {": "",
    "v i w shift-s }": "",
    "v e shift-s }": "",
    "\n            The quˇ{ick} brown\n            fox jumps over\n            the lazy dog.": "",
    "v i w shift-s '": "",
    "ctrl-v i w j j shift-s '": "",
    "\n            The ˇ'quick' brown\n            fox 'jumps' over\n            the 'lazy 'dog.": "",
    "j shift-v shift-s '": "",
    "\n            The quick brown\n            ˇ'\n            fox jumps over\n            '\n            the lazy dog.": "",
    "\n            The {quˇick} brown\n            fox jumps over\n            the lazy dog.": "",
    "d s {": "",
    "\n            The ˇquick brown\n            fox jumps over\n            the lazy dog.": "",
    "d s [": "",
    "\n            The {quick} brˇown\n            fox jumps over\n            the lazy dog.": "",
    "\n            The { quick brown\n            fox jumˇps over }\n            the lazy dog.": "",
    "\n            The [quˇick] brown\n            fox jumps over\n            the [laˇzy] dog.": "",
    "d s ]": "",
    "\n            The ˇquick brown\n            fox jumps over\n            the ˇlazy dog.": "",
    "\n            Tˇhe [ quick ] brown\n            fox jumps over\n            the [laˇzy] dog.": "",
    "\n            Tˇhe [ quick ] brown\n            fox jumps over\n            the [laˇzy ] dog.": "",
    "\n            The [quˇick] brown\n            fox jumps over\n            the {laˇzy} dog.": "",
    "\n            The [quick] brown\n            fox jumps over\n            the ˇlazy dog.": "",
    "\n            fn test_surround() {\n                ifˇ 2 > 1 {\n                    ˇprintln!(\\\"it is fine\\\");\n                };\n            }": "",
    "d s }": "",
    "\n            fn test_surround() ˇ\n                if 2 > 1 ˇ\n                    println!(\\\"it is fine\\\");\n                ;\n            ": "",
    "c s { [": "",
    "\n            The ˇ[ quick ] brown\n            fox jumps over\n            the lazy dog.": "",
    "\n            The {quˇick} brown\n            fox jumps over\n            the {laˇzy} dog.": "",
    "\n            The ˇ[ quick ] brown\n            fox jumps over\n            the ˇ[ lazy ] dog.": "",
    "\n            Thˇe {quick} brown\n            fox jumps over\n            the {laˇzy} dog.": "",
    "\n            Thˇe { quick } brown\n            fox jumps over\n            the {laˇzy} dog.": "",
    "c s { ]": "",
    "\n            The ˇ[quick] brown\n            fox jumps over\n            the ˇ[lazy] dog.": "",
    "\n            The {quˇick} brown\n            fox jumps over\n            the [laˇzy] dog.": "",
    "c s [ '": "",
    "\n            The {quick} brown\n            fox jumps over\n            the ˇ'lazy' dog.": "",
    "\n            fn test_surround() {\n                ifˇ 2 > 1 {\n                    ˇprintln!(\\\"it is fine\\\");\n                }\n            };": "",
    "\n            fn test_surround() ˇ[\n                if 2 > 1 ˇ[\n                    println!(\\\"it is fine\\\");\n                ]\n            ];": "",
    "y s i w [": "",
    "c s [ }": "",
    "u": "",
    "y s i w b": "",
    "\n            The ˇ(quick) brown\n            fox jumps over\n            the lazy dog.": "",
    "y s i w B": "",
    "y s i w a": "",
    "\n            The ˇ<quick> brown\n            fox jumps over\n            the lazy dog.": "",
    "y s i w r": "",
    "\n            The ˇ[quick] brown\n            fox jumps over\n            the lazy dog.": "",
    "c s { b": "",
    "\n            The (quˇick) brown\n            fox jumps over\n            the lazy dog.": "",
    "c s ( B": "",
    "c s ( a": "",
    "\n            The <quˇick> brown\n            fox jumps over\n            the lazy dog.": "",
    "c s < b": "",
    "c s ( r": "",
    "c s [ b": "",
    "d s B": "",
    "d s b": "",
    "d s r": "",
    "d s a": ""
  },
  "zed/crates/welcome/src/base_keymap_picker.rs": {
    "Select a base keymap...": "",
    "Settings Changed": "",
    "keymap": ""
  },
  "zed/crates/welcome/src/multibuffer_hint.rs": {
    "MULTIBUFFER_HINT_SHOWN_COUNT": "",
    "{}": "",
    "Edit and save files directly in the results multibuffer!": "",
    "open_docs": "",
    "Learn More": "",
    "https://zed.dev/docs/multibuffers": "",
    "dismiss": "",
    "Dismiss Hint": ""
  },
  "zed/crates/welcome/src/welcome.rs": {
    "first_open": "",
    "https://zed.dev/docs/": "",
    "false": "",
    "Edit Prediction Enabled": "",
    "Try Edit Prediction": "",
    "Welcome": "",
    "icons/logo_96.svg": "",
    "Welcome to Zed": "",
    "The editor for what's next": "",
    "Get Started": "",
    "choose-theme": "",
    "Choose a Theme": "",
    "Welcome Theme Changed": "",
    "choose-keymap": "",
    "Choose a Keymap": "",
    "Welcome Keymap Changed": "",
    "try-zed-edit-prediction": "",
    "Welcome Screen Try Edit Prediction clicked": "",
    "edit settings": "",
    "Edit Settings": "",
    "Welcome Settings Edited": "",
    "Resources": "",
    "macos": "",
    "install-cli": "",
    "Install the CLI": "",
    "Welcome CLI Installed": "",
    "view-docs": "",
    "View Documentation": "",
    "Welcome Documentation Viewed": "",
    "explore-extensions": "",
    "Explore Extensions": "",
    "Welcome Extensions Page Opened": "",
    "enable-vim": "",
    "Enable Vim Mode": "",
    "Welcome Vim Mode Toggled": "",
    "vim-mode": "",
    "You can also toggle Vim Mode via the command palette or Editor Controls menu.": "",
    "enable-crash": "",
    "Send Crash Reports": "",
    "Welcome Diagnostic Telemetry Toggled": "",
    "Settings Changed": "",
    "diagnostic telemetry": "",
    "enable-telemetry": "",
    "Send Telemetry": "",
    "Welcome Metric Telemetry Toggled": "",
    "metric telemetry": "",
    "Welcome Page Closed": "",
    "Welcome Page Opened": ""
  },
  "zed/crates/workspace/src/notifications.rs": {
    "test-support": "",
    "Error: {err}": "",
    "See docs": "",
    "https://zed.dev/docs/linux#i-cant-open-any-files": "",
    "Response already sent": "",
    "Stream already closed": "",
    "language_server_prompt_notification": "",
    "suppress": "",
    "close": "",
    "copy": "",
    "Copy Description": "",
    "Suppress.\\nClose with click.": "",
    "Close.\\nSuppress with shift-click.": "",
    "error_message_prompt_notification": "",
    "error_message": "",
    "error_message_prompt_notification_button": "",
    "Close": "",
    "Showing error notification in workspace: {err:?}": "",
    "{err:?}": "",
    "Showing error notification in app: {message}": "",
    "{err}. Please try again.": "",
    "Ok": ""
  },
  "zed/crates/workspace/src/pane_group.rs": {
    "Pane not found": "",
    "{} is in an unshared pane": "",
    "Follow {} to their active project": "",
    "{} is viewing an unshared Zed project": "",
    "{} is viewing a window outside of Zed": "",
    "snake_case": "",
    "up": "",
    "down": "",
    "left": "",
    "right": ""
  },
  "zed/crates/workspace/src/pane.rs": {
    "snake_case": "",
    "you have unsaved changes": "",
    "AddItem": "",
    "item": "",
    "ActivateItem": "",
    "local": "",
    "Remove": "",
    "RemoveItem": "",
    "idx": "",
    "RemovedItem": "",
    "Split": "",
    "direction": "",
    "JoinAll": "",
    "JoinIntoNext": "",
    "ChangeItemTitle": "",
    "Focus": "",
    "ZoomIn": "",
    "ZoomOut": "",
    "UserSavedItem": "",
    "save_intent": "",
    "ItemPinned": "",
    "ItemUnpinned": "",
    "untitled": "",
    "{}\\n.. and {} more": "",
    "\\n": "",
    "Do you want to save changes to the following files?": "",
    "Save all": "",
    "Discard all": "",
    "Cancel": "",
    "This file has changed on disk since you started editing it. Do you want to overwrite it?": "",
    "This file has been deleted on disk since you started editing it. Do you want to recreate it?": "",
    "Save": "",
    "Close": "",
    "Overwrite": "",
    "Discard": "",
    "Don't Save": "",
    "save modal was not present in spawned modals after awaiting for its answer": "",
    "Unpin Tab": "",
    "unpin tab": "",
    "Close Tab": "",
    "close tab": "",
    "": "",
    "Close Others": "",
    "Close Left": "",
    "Close Right": "",
    "Close Clean": "",
    "Close All": "",
    "Pin Tab": "",
    "Copy Path": "",
    "Copy Relative Path": "",
    "Reveal In Project Panel": "",
    "Open in Terminal": "",
    "navigate_backward": "",
    "Go Back": "",
    "navigate_forward": "",
    "Go Forward": "",
    "tab_bar": "",
    "unpinned tabs": "",
    "tab_bar_drop_target": "",
    "macos": "",
    "Cannot drop files on a remote project": "",
    "pane-tab-bar-popover-menu": "",
    "plus": "",
    "New...": "",
    "New File": "",
    "Open File": "",
    "Search Project": "",
    "Search Symbols": "",
    "New Terminal": "",
    "pane-tab-bar-split": "",
    "split": "",
    "Split Pane": "",
    "Split Right": "",
    "Split Left": "",
    "Split Up": "",
    "Split Down": "",
    "toggle_zoom": "",
    "Zoom Out": "",
    "Zoom In": "",
    "Pane": "",
    "EmptyPane": "",
    "pane_placeholder": "",
    "Open a file or project to get started.": "",
    "This buffer": "",
    "{path} contains unsaved edits. Do you want to save it?": "",
    "{}": "",
    "7": "",
    "3": "",
    "4": "",
    "5": "",
    "6": "",
    "7*": "",
    "X": "",
    "X*": "",
    "D{}": "",
    "D0^": "",
    "D1^": "",
    "D2^": "",
    "D3^": "",
    "D4^": "",
    "D5^": "",
    "D6*^": "",
    "N{}": "",
    "D6^": "",
    "N0": "",
    "N1": "",
    "N2": "",
    "N3": "",
    "N4": "",
    "N5": "",
    "N6*": "",
    "A": "",
    "B": "",
    "C": "",
    "D": "",
    "E": "",
    "Settings": "",
    "Settings*": "",
    "C!": "",
    "D!": "",
    "A*^!": "",
    "A*!": "",
    "A*": "",
    "A!": "",
    "B*": "",
    "B*!": "",
    "B!": "",
    "C*": "",
    "C*!": "",
    "E*": "",
    "F": "",
    "F*": "",
    "G": "",
    "G*": "",
    "H": "",
    "H*": "",
    "D*": "",
    "D*!": "",
    "A*^": "",
    "A^": "",
    "B*^": "",
    "B^": "",
    "C*^": "",
    "C^": "",
    "G*^": "",
    "buffer 1": "",
    "one.txt": "",
    "buffer 1*": "",
    "1.txt": "",
    "buffer 2": "",
    "2.txt": "",
    "buffer 2*": "",
    "multibuffer 1": "",
    "multibuffer 1*": "",
    "multibuffer 1b": "",
    "multibuffer 1b*": "",
    "1": "",
    "1*": "",
    "A.txt": "",
    "B.txt": "",
    "C.txt": "",
    "AB": "",
    "AB^": "",
    "pane items do not match expectation": ""
  },
  "zed/crates/workspace/src/persistence.rs": {
    "Horizontal": "",
    "Vertical": "",
    "Stored serialized item kind is incorrect": "",
    "Windowed": "",
    "Maximized": "",
    "FullScreen": "",
    "Fixed": "",
    "Window State did not have a valid string": "",
    "Invalid BreakpointState discriminant {state}": "",
    "Failed to read BreakPoint at index {start_index}": "",
    "{}": "",
    "": "",
    "No workspaces found": "",
    "Getting center group": "",
    "Breakpoints are empty after querying database for them": "",
    "Got {} breakpoints from database at path: {}": "",
    "Breakpoints query failed with msg: {msg}": "",
    "Saving workspace at location: {:?}": "",
    "update_worktrees": "",
    "Clearing old panes": "",
    "Clearing old breakpoints": "",
    "Stored breakpoint at row: {} in path: {}": "",
    "{err}": "",
    "clearing out old locations": "",
    ",": "",
    "Updating workspace": "",
    "save pane group in save workspace": "",
    "Inserting SSH project at host {host}": "",
    "failed to insert ssh project": "",
    "Pane Group Child was neither a pane group or a pane": "",
    "Saving a pane group for workspace {workspace_id:?}": "",
    "Couldn't retrieve group_id from inserted pane_group": "",
    "Could not retrieve inserted pane_id": "",
    "Saving items": "",
    "Preparing insertion": "",
    "Setting toolchain for workspace, worktree: {worktree_id:?}, relative path: {relative_worktree_path:?}, toolchain: {}": "",
    "?": "",
    ", ": "",
    "DELETE FROM {table} WHERE workspace_id = ? AND item_id NOT IN ({placeholders})": "",
    "test_breakpoints": "",
    "/tmp/test.rs": "",
    "Test log message": "",
    "x > 5": "",
    ">= 3": "",
    "/tmp": "",
    "test_remove_last_breakpoint": "",
    "/tmp/test_remove_last_breakpoint.rs": "",
    "test_next_id_stability": "",
    "test_table": "",
    "test-text-1": "",
    "test_workspace_id_stability": "",
    "/tmp2": "",
    "test-text-2": "",
    "/tmp3": "",
    "test_full_workspace_serialization": "",
    "Terminal": "",
    "test_basic_functionality": "",
    "/tmp4": "",
    "tmp": "",
    "test_serializing_workspaces_session_id": "",
    "/tmp1": "",
    "session-id-1": "",
    "session-id-2": "",
    "my-host": "",
    "/tmp6a": "",
    "/tmp6b": "",
    "/tmp6c": "",
    "session-id-3": "",
    "dir1": "",
    "dir2": "",
    "dir3": "",
    "dir4": "",
    "test_serializing_workspaces_last_session_workspaces": "",
    "one-session": "",
    "test_serializing_workspaces_last_session_workspaces_ssh_projects": "",
    "host-1": "",
    "my-user-1": "",
    "host-2": "",
    "my-user-2": "",
    "host-3": "",
    "my-user-3": "",
    "host-4": "",
    "my-user-4": "",
    "test_get_or_create_ssh_project": "",
    "example.com": "",
    "/home/user": "",
    "/etc/nginx": "",
    "user": "",
    "otherexample.com": "",
    "/home/otheruser": "",
    "otheruser": "",
    "test_get_or_create_ssh_project_with_null_user": "",
    "test_get_ssh_projects": "",
    "anotherexample.com": "",
    "/home/user2": "",
    "user2": "",
    "yetanother.com": "",
    "/home/user3": "",
    "/proc/1234/exe": "",
    "simple_split": "",
    "test_cleanup_panes": ""
  },
  "zed/crates/workspace/src/theme_preview.rs": {
    "Overview": "",
    "Typography": "",
    "{} Preview": "",
    "https://avatars.githubusercontent.com/u/1714999?v=4": "",
    "{} ({:.2})": "",
    "Text": "",
    "Headline Sizes": "",
    "XLarge Headline": "",
    "Large Headline": "",
    "Medium Headline": "",
    "Small Headline": "",
    "XSmall Headline": "",
    "Text Colors": "",
    "Default Text": "",
    "Accent Text": "",
    "Conflict Text": "",
    "Created Text": "",
    "Deleted Text": "",
    "Disabled Text": "",
    "Error Text": "",
    "Hidden Text": "",
    "Hint Text": "",
    "Ignored Text": "",
    "Info Text": "",
    "Modified Text": "",
    "Muted Text": "",
    "Placeholder Text": "",
    "Selected Text": "",
    "Success Text": "",
    "Warning Text": "",
    "Wrapping Text": "",
    "This is a longer piece of text that should wrap to multiple lines. It demonstrates how text behaves when it exceeds the width of its container.": "",
    "Colors": "",
    "{:?}-preview": "",
    "{:?}": "",
    "theme-preview-overview": "",
    "Theme Preview": "",
    "This view lets you preview a range of UI elements across a theme. Use it for testing out changes to the theme.": "",
    "theme-preview-typography": "",
    "Headline 1": "",
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.": "",
    "Headline 2": "",
    "Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.": "",
    "Headline 3": "",
    "Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.": "",
    "Headline 4": "",
    "Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.": "",
    "Headline 5": "",
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.": "",
    "Body Text": "",
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.": "",
    "theme-preview-nav": "",
    "theme-preview": "",
    "ThemePreview": ""
  },
  "zed/crates/workspace/src/workspace.rs": {
    "ZED_WINDOW_SIZE": "",
    "ZED_WINDOW_POSITION": "",
    "default_true": "",
    "Failed to read WorkspaceId at index {start_index}": "",
    "cannot open file {:?}": "",
    "cannot deserialize {}, descriptor not found": "",
    "cannot cleanup {}, descriptor not found": "",
    "test-support": "",
    "global context": "",
    "Navigating to {project_path:?}": "",
    "Navigating to {abs_path:?}": "",
    "Failed to navigate history: {open_by_project_path_e:#} and {open_by_abs_path_e:#}": "",
    "": "",
    "macos": "",
    "Do you want to leave the current call?": "",
    "Close window and hang up": "",
    "Cancel": "",
    "bindings": "",
    "g z": "",
    "workspace::SendKeystrokes": "",
    ": j <enter> u": "",
    "over 100 keystrokes passed to send_keystrokes": "",
    "Do you want to save all changes in the following files?": "",
    "Save all": "",
    "Discard all": "",
    "open paths {abs_paths:?}": "",
    "You cannot add folders to someone else's project": "",
    "open abs path {abs_path:?} task spawn": "",
    "open abs path {abs_path:?} task returned incorrect number of results": "",
    "ensured single task result": "",
    "open abs path {abs_path:?} task join": "",
    "open abs path {abs_path:?} task returned None": "",
    "There must be an active pane": "",
    "pane was dropped": "",
    "Could not find a focus target when in switching focus in {direction} direction for a pane": "",
    "Could not find a focus target when in switching focus in {direction} direction for a {:?} dock": "",
    "following interrupted": "",
    ", ": "",
    "empty project": "",
    " — ": "",
    " ↙": "",
    " ↗": "",
    "invalid update": "",
    "invalid view id": "",
    "missing update view variant": "",
    "missing update view id": "",
    "workspace dropped": "",
    "no id for view": "",
    "stopped following": "",
    "missing view variant": "",
    "failed to construct view from leader (maybe from a different version of zed?)": "",
    "failed to send serializable item over channel: {err}": "",
    "Failed to save": "",
    "Failed to load the database file.": "",
    "File an Issue": "",
    "Workspace": "",
    "keyboard_layout": "",
    "debugger_running": "",
    "debugger_stopped": "",
    "workspace": "",
    "creator is missing": "",
    "OpenPaths": "",
    "paths": "",
    "Do you want to switch channels?": "",
    "Leaving this call will unshare your current project.": "",
    "Yes, Join Channel": "",
    "error connecting": "",
    "failed to join channel: {}": "",
    "Please sign in to continue.": "",
    "Your are running an unsupported version of Zed. Please update to continue.": "",
    "No matching channel was found. Please check the link and try again.": "",
    "This channel is private, and you do not have access. Please ask someone to add you and try again.": "",
    "Please check your internet connection and try again.": "",
    "{}\\n\\nPlease try again.": "",
    "Failed to join channel": "",
    "Ok": "",
    "could not open zed": "",
    "path {path:?} is not a file": "",
    "no paths given": "",
    "SSH Project Opened": "",
    "path": "",
    "'{path}' does not exist": "",
    "not in a call": "",
    "Are you sure you want to restart?": "",
    "Restart": "",
    "window-backdrop": "",
    "fetching serialized ssh project": "",
    "c": "",
    "b1/c": "",
    "a/b1/c": "",
    "b2/c": "",
    "a/b2/c": "",
    "/root1": "",
    "one.txt": "",
    "two.txt": "",
    "/root2": "",
    "three.txt": "",
    "root1": "",
    "root1 — one.txt": "",
    "root1 — two.txt": "",
    "root2": "",
    "root1, root2 — one.txt": "",
    "root2 — one.txt": "",
    "/root": "",
    "one": "",
    "root": "",
    "1.txt": "",
    "2.txt": "",
    "3.txt": "",
    "Discard": "",
    "{project_entry_id}.txt": "",
    "4.txt": "",
    "top.txt": "",
    "bottom.txt": "",
    "left.txt": "",
    "right.txt": "",
    "center.txt": "",
    "item{item_id}.txt": "",
    "item is in focus": "",
    "Fake Project Search": "",
    "Should select the multi buffer in the pane": "",
    "Closing all buffers but the multi buffer failed": "",
    "Should have only the multi buffer left in the pane": "",
    "The multi buffer containing the unsaved buffer should still be dirty": "",
    "Dirty multi buffer should prompt a save dialog": "",
    "Save": "",
    "Closing the multi buffer failed": "",
    "Multi buffer item should get be saved": "",
    "No more items should be left in the pane": "",
    "With one dirty item from the multi buffer not being in the pane, a save prompt should be shown": "",
    "test.txt": "",
    "Item should be automatically closed when file is deleted": "",
    "Item should remain open when close_on_disk_deletion is disabled": "",
    "Item should be marked as having deleted file": "",
    "Dirty items should not be automatically closed even when file is deleted": "",
    "Item should still be dirty": "",
    "test1.txt": "",
    "test2.txt": "",
    "Should have 1 item remaining after auto-close": "",
    "Navigation history should not contain closed item entries": "",
    "All dirty items from the multi buffer are in the pane still, no save prompts should be shown": "",
    "Closing multi buffer failed": "",
    "Should have no multi buffer left in the pane": "",
    "first.txt": "",
    "No new panes were created": "",
    "Single item was not moved anywhere": "",
    "second.txt": "",
    "A new pane should be created": "",
    "After moving, one item should be left in the original pane": "",
    "New item should have been moved to the new pane": "",
    "third.txt": "",
    "New pane should be ready to move one item out": "",
    "Previously created pane should be unchanged": "",
    "png": "",
    "ipynb": "",
    "one.png": "",
    "BINARYDATAHERE": "",
    "two.ipynb": "",
    "{ totally a notebook }": "",
    "editing text, sure why not?": ""
  },
  "zed/crates/worktree/src/worktree.rs": {
    "ephemeral": "",
    "LoadedBinaryFile": "",
    "file": "",
    "content_bytes": "",
    "": "",
    "could not relativize {path:?} against {relative_path:?}": "",
    "../": "",
    "/": "",
    "gitfile": "",
    "commondir": "",
    "parent": "",
    "failed to stat worktree path": "",
    "Failed to determine whether filesystem is case sensitive (falling back to true) due to error: {e:#}": "",
    "test-support": "",
    "remote worktrees can't yet load files": "",
    "remote worktrees can't yet load binary files": "",
    "remote worktree can't yet write files": "",
    "absolutizing {path:?}": "",
    "invalid entry": "",
    "no such entry": "",
    ".git": "",
    "~": "",
    "refreshing entries for the following always included paths: {:?}": "",
    "Failed to determine whether filesystem is case sensitive: {e:#}": "",
    "worktree was dropped": "",
    "Loading metadata for excluded file {abs_path:?}": "",
    "Excluded file {abs_path:?} got removed during loading": "",
    "File is too large to load": "",
    "absolutizing path {path:?}": "",
    "creating directory {task_abs_path:?}": "",
    "creating file {task_abs_path:?}": "",
    "invalid path {path:?}": "",
    "worktree dropped": "",
    "Fetching metadata after saving the excluded buffer {abs_path:?}": "",
    "Excluded buffer {path:?} got removed during saving": "",
    "no entry to rename for id {entry_id:?}": "",
    "no parent for path {:?}": "",
    "absolutizing path {new_path:?}": "",
    "Renaming {abs_old_path:?} into {abs_new_path:?}": "",
    "invalid target path": "",
    "Failed to copy file from {source:?} to {target:?}": "",
    "Dropped worktree": "",
    "Worktree is not local": "",
    "refreshed entry {path:?} in {:?}": "",
    "reading path after update": "",
    "waiting to resume updates": "",
    "consumer runs to completion": "",
    "absolutizing {new_path:?}": "",
    "C:\\Users\\user\\Desktop\\project": "",
    "\\\\\\\\?\\\\C:\\\\Users\\\\user\\\\Desktop\\\\project\\\\main.rs": "",
    "invalid path": "",
    "applying remote worktree update. {} entries updated, {} removed": "",
    "error loading .gitignore file {:?} - {:?}": "",
    "entries_by_path and entries_by_id are inconsistent": "",
    "populating a directory {:?} that has been removed": "",
    "background scanner removing path {path:?}": "",
    "not building git repository for nested `.git` directory, `.git` path in the worktree: {dot_git_path:?}": "",
    "not building git repository for the worktree itself, `.git` path in the worktree: {dot_git_path:?}": "",
    "existing git repository for {work_directory:?}": "",
    "inserting new local git repository": "",
    "HEAD": "",
    "config": "",
    "Snapshot": "",
    "id": "",
    "root_name": "",
    "entries_by_path": "",
    "entries_by_id": "",
    "not remote": "",
    "worktree id does not match file": "",
    "containing git repository: {containing_git_repository:?}": "",
    "adding path prefix {:?}": "",
    "rescanning paths {:?}": "",
    "failed to canonicalize root path {root_path:?}: {err}": "",
    "root renamed from {} to {}": "",
    "root path could not be canonicalized: {}": "",
    "stripping off the ancestor": "",
    "ignoring event {abs_path:?} as it's in the .git directory among skipped files or directories": "",
    "ignoring event {abs_path:?}, since it's in git dir outside of root path {root_canonical_path:?}": "",
    "ignoring event {abs_path:?} outside of root path {root_canonical_path:?}": "",
    "ignoring event {relative_path:?} within unloaded directory": "",
    "ignoring FS event for excluded path {relative_path:?}": "",
    "received fs events {:?}": "",
    "error scanning directory {:?}: {}": "",
    "skipping excluded directory {:?}": "",
    "scanning directory {:?}": "",
    "error processing entry {:?}": "",
    "skipping excluded child entry {child_path:?}": "",
    "error processing {child_abs_path:?}: {err:?}": "",
    "error reading target of symlink {child_abs_path:?}: {err:#}": "",
    "error canonicalizing root {:?}: {:?}": "",
    "detected private file: {relative_path:?}": "",
    "defer scanning directory {:?}": "",
    "channel is unbounded": "",
    "remove path {:?}": "",
    "updating ancestor git repository": "",
    "error reading file {abs_path:?} on event: {err:#}": "",
    "remove repo path: {:?}": "",
    "update ignore status {:?}": "",
    "reloading repositories: {dot_git_paths:?}": "",
    "considering ancestor: {ancestor_dot_git:?}": "",
    "inserting parent git repo for this worktree: {location_in_repo:?}": "",
    "redundant": "",
    "fs-event-sentinel": "",
    "gitdir:": "",
    "parsing gitfile content {content:?}": ""
  },
  "zed/crates/worktree/src/worktree_settings.rs": {
    "**/.git": "",
    "**/.svn": "",
    "**/.hg": "",
    "**/.jj": "",
    "**/CVS": "",
    "**/.DS_Store": "",
    "**/Thumbs.db": "",
    "**/.classpath": "",
    "**/.settings": "",
    ".env*": "",
    "docker-compose.*.yml": "",
    "**/.env*": "",
    "": "",
    "file_scan_exclusions": "",
    "private_files": "",
    "file_scan_inclusions": "",
    "files.watcherInclude": "",
    "files.watcherExclude": "",
    "Failed to parse globs from {}": ""
  },
  "zed/crates/zed/src/main.rs": {
    "mimalloc": "",
    "Zed failed to launch": "",
    "{kind} when creating directory {:?}": "",
    "match arm checks for a single entry": "",
    "{kind} when creating directories {paths:?}": "",
    ");\n                    }\n                    _ => {}\n                }\n            }\n\n            Some(error_kind_details)\n        })\n        .collect::<Vec<_>>().join(": "",
    ");\n\n    eprintln!(": "",
    ");\n    Application::new().run(move |cx| {\n        if let Ok(window) = cx.open_window(gpui::WindowOptions::default(), |_, cx| {\n            cx.new(|_| gpui::Empty)\n        }) {\n            window\n                .update(cx, |_, window, cx| {\n                    let response = window.prompt(\n                        gpui::PromptLevel::Critical,\n                        message,\n                        Some(&error_details),\n                        &[": "",
    "],\n                        cx,\n                    );\n\n                    cx.spawn_in(window, async move |_, cx| {\n                        response.await?;\n                        cx.update(|_, cx| cx.quit())\n                    })\n                    .detach_and_log_err(cx);\n                })\n                .log_err();\n        } else {\n            fail_to_open_window(anyhow::anyhow!(": "",
    "), cx)\n        }\n    })\n}\n\nfn fail_to_open_window_async(e: anyhow::Error, cx: &mut AsyncApp) {\n    cx.update(|cx| fail_to_open_window(e, cx)).log_err();\n}\n\nfn fail_to_open_window(e: anyhow::Error, _cx: &mut App) {\n    eprintln!(\n        ": "",
    "\n    );\n    #[cfg(not(any(target_os = ": "",
    ", target_os = ": "",
    ")))]\n    {\n        process::exit(1);\n    }\n\n    #[cfg(any(target_os = ": "",
    "))]\n    {\n        use ashpd::desktop::notification::{Notification, NotificationProxy, Priority};\n        _cx.spawn(async move |_cx| {\n            let Ok(proxy) = NotificationProxy::new().await else {\n                process::exit(1);\n            };\n\n            let notification_id = ": "",
    ";\n            proxy\n                .add_notification(\n                    notification_id,\n                    Notification::new(": "",
    ")\n                        .body(Some(\n                            format!(\n                                ": "",
    "\n                            )\n                            .as_str(),\n                        ))\n                        .priority(Priority::High)\n                        .icon(ashpd::desktop::Icon::with_names(&[\n                            ": "",
    ",\n                        ])),\n                )\n                .await\n                .ok();\n\n            process::exit(1);\n        })\n        .detach();\n    }\n}\n\npub fn main() {\n    #[cfg(unix)]\n    {\n        let is_root = nix::unistd::geteuid().is_root();\n        let allow_root = env::var(": "",
    ").is_ok_and(|val| val == ": "",
    ");\n\n        // Prevent running Zed with root privileges on Unix systems unless explicitly allowed\n        if is_root && !allow_root {\n            eprintln!(\n                ": "",
    "\n            );\n            process::exit(1);\n        }\n    }\n\n    // Check if there is a pending installer\n    // If there is, run the installer and exit\n    // And we don't want to run the installer if we are not the first instance\n    #[cfg(target_os = ": "",
    ")]\n    let is_first_instance = crate::zed::windows_only_instance::is_first_instance();\n    #[cfg(target_os = ": "",
    ")]\n    if is_first_instance && auto_update::check_pending_installation() {\n        return;\n    }\n\n    let args = Args::parse();\n\n    if let Some(socket) = &args.askpass {\n        askpass::main(socket);\n        return;\n    }\n\n    if args.dump_all_actions {\n        dump_all_gpui_actions();\n        return;\n    }\n\n    // Set custom data directory.\n    if let Some(dir) = &args.user_data_dir {\n        paths::set_custom_data_dir(dir);\n    }\n\n    #[cfg(all(not(debug_assertions), target_os = ": "",
    "))]\n    unsafe {\n        use windows::Win32::System::Console::{ATTACH_PARENT_PROCESS, AttachConsole};\n\n        if args.foreground {\n            let _ = AttachConsole(ATTACH_PARENT_PROCESS);\n        }\n    }\n\n    let file_errors = init_paths();\n    if !file_errors.is_empty() {\n        files_not_created_on_launch(file_errors);\n        return;\n    }\n\n    zlog::init();\n    if stdout_is_a_pty() {\n        zlog::init_output_stdout();\n    } else {\n        let result = zlog::init_output_file(paths::log_file(), Some(paths::old_log_file()));\n        if let Err(err) = result {\n            eprintln!(": "",
    ", err);\n            zlog::init_output_stdout();\n        };\n    }\n\n    let app_version = AppVersion::load(env!(": "",
    "));\n    let app_commit_sha =\n        option_env!(": "",
    ").map(|commit_sha| AppCommitSha::new(commit_sha.to_string()));\n\n    if args.system_specs {\n        let system_specs = feedback::system_specs::SystemSpecs::new_stateless(\n            app_version,\n            app_commit_sha.clone(),\n            *release_channel::RELEASE_CHANNEL,\n        );\n        println!(": "",
    ", system_specs);\n        return;\n    }\n\n    log::info!(": "",
    ");\n\n    let app = Application::new().with_assets(Assets);\n\n    let system_id = app.background_executor().block(system_id()).ok();\n    let installation_id = app.background_executor().block(installation_id()).ok();\n    let session_id = Uuid::new_v4().to_string();\n    let session = app.background_executor().block(Session::new());\n\n    reliability::init_panic_hook(\n        app_version,\n        app_commit_sha.clone(),\n        system_id.as_ref().map(|id| id.to_string()),\n        installation_id.as_ref().map(|id| id.to_string()),\n        session_id.clone(),\n    );\n\n    let (open_listener, mut open_rx) = OpenListener::new();\n\n    let failed_single_instance_check =\n        if *db::ZED_STATELESS || *release_channel::RELEASE_CHANNEL == ReleaseChannel::Dev {\n            false\n        } else {\n            #[cfg(any(target_os = ": "",
    "))]\n            {\n                crate::zed::listen_for_cli_connections(open_listener.clone()).is_err()\n            }\n\n            #[cfg(target_os = ": "",
    ")]\n            {\n                !crate::zed::windows_only_instance::handle_single_instance(\n                    open_listener.clone(),\n                    &args,\n                    is_first_instance,\n                )\n            }\n\n            #[cfg(target_os = ": "",
    ")]\n            {\n                use zed::mac_only_instance::*;\n                ensure_only_instance() != IsOnlyInstance::Yes\n            }\n        };\n    if failed_single_instance_check {\n        println!(": "",
    ");\n        return;\n    }\n\n    let git_hosting_provider_registry = Arc::new(GitHostingProviderRegistry::new());\n    let git_binary_path =\n        if cfg!(target_os = ": "",
    ") && option_env!(": "",
    ").as_deref() == Some(": "",
    ") {\n            app.path_for_auxiliary_executable(": "",
    ")\n                .context(": "",
    ")\n                .log_err()\n        } else {\n            None\n        };\n    log::info!(": "",
    ", git_binary_path);\n\n    let fs = Arc::new(RealFs::new(git_binary_path, app.background_executor()));\n    let user_settings_file_rx = watch_config_file(\n        &app.background_executor(),\n        fs.clone(),\n        paths::settings_file().clone(),\n    );\n    let global_settings_file_rx = watch_config_file(\n        &app.background_executor(),\n        fs.clone(),\n        paths::global_settings_file().clone(),\n    );\n    let user_keymap_file_rx = watch_config_file(\n        &app.background_executor(),\n        fs.clone(),\n        paths::keymap_file().clone(),\n    );\n\n    let (shell_env_loaded_tx, shell_env_loaded_rx) = oneshot::channel();\n    if !stdout_is_a_pty() {\n        app.background_executor()\n            .spawn(async {\n                #[cfg(unix)]\n                util::load_login_shell_environment().log_err();\n                shell_env_loaded_tx.send(()).ok();\n            })\n            .detach()\n    } else {\n        drop(shell_env_loaded_tx)\n    }\n\n    app.on_open_urls({\n        let open_listener = open_listener.clone();\n        move |urls| open_listener.open_urls(urls)\n    });\n    app.on_reopen(move |cx| {\n        if let Some(app_state) = AppState::try_global(cx).and_then(|app_state| app_state.upgrade())\n        {\n            cx.spawn({\n                let app_state = app_state.clone();\n                async move |mut cx| {\n                    if let Err(e) = restore_or_create_workspace(app_state, &mut cx).await {\n                        fail_to_open_window_async(e, &mut cx)\n                    }\n                }\n            })\n            .detach();\n        }\n    });\n\n    app.run(move |cx| {\n        menu::init();\n        zed_actions::init();\n\n        release_channel::init(app_version, cx);\n        gpui_tokio::init(cx);\n        if let Some(app_commit_sha) = app_commit_sha {\n            AppCommitSha::set_global(app_commit_sha, cx);\n        }\n        settings::init(cx);\n        zlog_settings::init(cx);\n        handle_settings_file_changes(\n            user_settings_file_rx,\n            global_settings_file_rx,\n            cx,\n            handle_settings_changed,\n        );\n        handle_keymap_file_changes(user_keymap_file_rx, cx);\n        client::init_settings(cx);\n        let user_agent = format!(\n            ": "",
    ",\n            AppVersion::global(cx),\n            std::env::consts::OS,\n            std::env::consts::ARCH\n        );\n        let proxy_str = ProxySettings::get_global(cx).proxy.to_owned();\n        let proxy_url = proxy_str\n            .as_ref()\n            .and_then(|input| {\n                input\n                    .parse::<Url>()\n                    .inspect_err(|e| log::error!(": "",
    ", e))\n                    .ok()\n            })\n            .or_else(read_proxy_from_env);\n        let http = {\n            let _guard = Tokio::handle(cx).enter();\n\n            ReqwestClient::proxy_and_user_agent(proxy_url, &user_agent)\n                .expect(": "",
    ")\n        };\n        cx.set_http_client(Arc::new(http));\n\n        <dyn Fs>::set_global(fs.clone(), cx);\n\n        GitHostingProviderRegistry::set_global(git_hosting_provider_registry, cx);\n        git_hosting_providers::init(cx);\n\n        OpenListener::set_global(cx, open_listener.clone());\n\n        extension::init(cx);\n        let extension_host_proxy = ExtensionHostProxy::global(cx);\n\n        let client = Client::production(cx);\n        cx.set_http_client(client.http_client());\n        let mut languages = LanguageRegistry::new(cx.background_executor().clone());\n        languages.set_language_server_download_dir(paths::languages_dir().clone());\n        let languages = Arc::new(languages);\n        let (mut tx, rx) = watch::channel(None);\n        cx.observe_global::<SettingsStore>(move |cx| {\n            let settings = &ProjectSettings::get_global(cx).node;\n            let options = NodeBinaryOptions {\n                allow_path_lookup: !settings.ignore_system_version,\n                // TODO: Expose this setting\n                allow_binary_download: true,\n                use_paths: settings.path.as_ref().map(|node_path| {\n                    let node_path = PathBuf::from(shellexpand::tilde(node_path).as_ref());\n                    let npm_path = settings\n                        .npm_path\n                        .as_ref()\n                        .map(|path| PathBuf::from(shellexpand::tilde(&path).as_ref()));\n                    (\n                        node_path.clone(),\n                        npm_path.unwrap_or_else(|| {\n                            let base_path = PathBuf::new();\n                            node_path.parent().unwrap_or(&base_path).join(": "",
    ")\n                        }),\n                    )\n                }),\n            };\n            tx.send(Some(options)).log_err();\n        })\n        .detach();\n        let node_runtime = NodeRuntime::new(client.http_client(), Some(shell_env_loaded_rx), rx);\n\n        debug_adapter_extension::init(extension_host_proxy.clone(), cx);\n        language::init(cx);\n        language_extension::init(extension_host_proxy.clone(), languages.clone());\n        languages::init(languages.clone(), node_runtime.clone(), cx);\n        let user_store = cx.new(|cx| UserStore::new(client.clone(), cx));\n        let workspace_store = cx.new(|cx| WorkspaceStore::new(client.clone(), cx));\n\n        Client::set_global(client.clone(), cx);\n\n        zed::init(cx);\n        project::Project::init(&client, cx);\n        debugger_ui::init(cx);\n        debugger_tools::init(cx);\n        client::init(&client, cx);\n        let telemetry = client.telemetry();\n        telemetry.start(\n            system_id.as_ref().map(|id| id.to_string()),\n            installation_id.as_ref().map(|id| id.to_string()),\n            session_id.clone(),\n            cx,\n        );\n\n        // We should rename these in the future to `first app open`, `first app open for release channel`, and `app open`\n        if let (Some(system_id), Some(installation_id)) = (&system_id, &installation_id) {\n            match (&system_id, &installation_id) {\n                (IdType::New(_), IdType::New(_)) => {\n                    telemetry::event!(": "",
    ");\n                    telemetry::event!(": "",
    ");\n                }\n                (IdType::Existing(_), IdType::New(_)) => {\n                    telemetry::event!(": "",
    ");\n                }\n                (_, IdType::Existing(_)) => {\n                    telemetry::event!(": "",
    ");\n                }\n            }\n        }\n        let app_session = cx.new(|cx| AppSession::new(session, cx));\n\n        let app_state = Arc::new(AppState {\n            languages: languages.clone(),\n            client: client.clone(),\n            user_store: user_store.clone(),\n            fs: fs.clone(),\n            build_window_options,\n            workspace_store,\n            node_runtime: node_runtime.clone(),\n            session: app_session,\n        });\n        AppState::set_global(Arc::downgrade(&app_state), cx);\n\n        auto_update::init(client.http_client(), cx);\n        dap_adapters::init(cx);\n        auto_update_ui::init(cx);\n        reliability::init(\n            client.http_client(),\n            system_id.as_ref().map(|id| id.to_string()),\n            installation_id.clone().map(|id| id.to_string()),\n            session_id.clone(),\n            cx,\n        );\n\n        SystemAppearance::init(cx);\n        theme::init(theme::LoadThemes::All(Box::new(Assets)), cx);\n        theme_extension::init(\n            extension_host_proxy.clone(),\n            ThemeRegistry::global(cx),\n            cx.background_executor().clone(),\n        );\n        command_palette::init(cx);\n        let copilot_language_server_id = app_state.languages.next_language_server_id();\n        copilot::init(\n            copilot_language_server_id,\n            app_state.fs.clone(),\n            app_state.client.http_client(),\n            app_state.node_runtime.clone(),\n            cx,\n        );\n        supermaven::init(app_state.client.clone(), cx);\n        language_model::init(app_state.client.clone(), cx);\n        language_models::init(\n            app_state.user_store.clone(),\n            app_state.client.clone(),\n            app_state.fs.clone(),\n            cx,\n        );\n        web_search::init(cx);\n        web_search_providers::init(app_state.client.clone(), cx);\n        snippet_provider::init(cx);\n        inline_completion_registry::init(\n            app_state.client.clone(),\n            app_state.user_store.clone(),\n            cx,\n        );\n        let prompt_builder = PromptBuilder::load(app_state.fs.clone(), stdout_is_a_pty(), cx);\n        agent::init(\n            app_state.fs.clone(),\n            app_state.client.clone(),\n            prompt_builder.clone(),\n            app_state.languages.clone(),\n            false,\n            cx,\n        );\n        assistant_tools::init(app_state.client.http_client(), cx);\n        repl::init(app_state.fs.clone(), cx);\n        extension_host::init(\n            extension_host_proxy,\n            app_state.fs.clone(),\n            app_state.client.clone(),\n            app_state.node_runtime.clone(),\n            cx,\n        );\n        recent_projects::init(cx);\n\n        load_embedded_fonts(cx);\n\n        app_state.languages.set_theme(cx.theme().clone());\n        editor::init(cx);\n        image_viewer::init(cx);\n        repl::notebook::init(cx);\n        diagnostics::init(cx);\n\n        audio::init(Assets, cx);\n        workspace::init(app_state.clone(), cx);\n        ui_prompt::init(cx);\n\n        go_to_line::init(cx);\n        file_finder::init(cx);\n        tab_switcher::init(cx);\n        outline::init(cx);\n        project_symbols::init(cx);\n        project_panel::init(cx);\n        outline_panel::init(cx);\n        tasks_ui::init(cx);\n        snippets_ui::init(cx);\n        channel::init(&app_state.client.clone(), app_state.user_store.clone(), cx);\n        search::init(cx);\n        vim::init(cx);\n        terminal_view::init(cx);\n        journal::init(app_state.clone(), cx);\n        language_selector::init(cx);\n        toolchain_selector::init(cx);\n        theme_selector::init(cx);\n        language_tools::init(cx);\n        call::init(app_state.client.clone(), app_state.user_store.clone(), cx);\n        notifications::init(app_state.client.clone(), app_state.user_store.clone(), cx);\n        collab_ui::init(&app_state, cx);\n        git_ui::init(cx);\n        jj_ui::init(cx);\n        feedback::init(cx);\n        markdown_preview::init(cx);\n        welcome::init(cx);\n        settings_ui::init(cx);\n        extensions_ui::init(cx);\n        zeta::init(cx);\n        inspector_ui::init(app_state.clone(), cx);\n\n        cx.observe_global::<SettingsStore>({\n            let fs = fs.clone();\n            let languages = app_state.languages.clone();\n            let http = app_state.client.http_client();\n            let client = app_state.client.clone();\n            move |cx| {\n                for &mut window in cx.windows().iter_mut() {\n                    let background_appearance = cx.theme().window_background_appearance();\n                    window\n                        .update(cx, |_, window, _| {\n                            window.set_background_appearance(background_appearance)\n                        })\n                        .ok();\n                }\n\n                eager_load_active_theme_and_icon_theme(fs.clone(), cx);\n\n                languages.set_theme(cx.theme().clone());\n                let new_host = &client::ClientSettings::get_global(cx).server_url;\n                if &http.base_url() != new_host {\n                    http.set_base_url(new_host);\n                    if client.status().borrow().is_connected() {\n                        client.reconnect(&cx.to_async());\n                    }\n                }\n            }\n        })\n        .detach();\n        telemetry::event!(\n            ": "",
    ",\n            setting = ": "",
    ",\n            value = cx.theme().name.to_string()\n        );\n        telemetry::event!(\n            ": "",
    ",\n            value = BaseKeymap::get_global(cx).to_string()\n        );\n        telemetry.flush_events().detach();\n\n        let fs = app_state.fs.clone();\n        load_user_themes_in_background(fs.clone(), cx);\n        watch_themes(fs.clone(), cx);\n        watch_languages(fs.clone(), app_state.languages.clone(), cx);\n\n        cx.set_menus(app_menus());\n        initialize_workspace(app_state.clone(), prompt_builder, cx);\n\n        cx.activate(true);\n\n        cx.spawn({\n            let client = app_state.client.clone();\n            async move |cx| match authenticate(client, &cx).await {\n                ConnectionResult::Timeout => log::error!(": "",
    "),\n                ConnectionResult::ConnectionReset => {\n                    log::error!(": "",
    ")\n                }\n                ConnectionResult::Result(r) => {\n                    r.log_err();\n                }\n            }\n        })\n        .detach();\n\n        let urls: Vec<_> = args\n            .paths_or_urls\n            .iter()\n            .filter_map(|arg| parse_url_arg(arg, cx).log_err())\n            .collect();\n\n        if !urls.is_empty() {\n            open_listener.open_urls(urls)\n        }\n\n        match open_rx\n            .try_next()\n            .ok()\n            .flatten()\n            .and_then(|urls| OpenRequest::parse(urls, cx).log_err())\n        {\n            Some(request) => {\n                handle_open_request(request, app_state.clone(), cx);\n            }\n            None => {\n                cx.spawn({\n                    let app_state = app_state.clone();\n                    async move |mut cx| {\n                        if let Err(e) = restore_or_create_workspace(app_state, &mut cx).await {\n                            fail_to_open_window_async(e, &mut cx)\n                        }\n                    }\n                })\n                .detach();\n            }\n        }\n\n        let app_state = app_state.clone();\n\n        crate::zed::component_preview::init(app_state.clone(), cx);\n\n        cx.spawn(async move |cx| {\n            while let Some(urls) = open_rx.next().await {\n                cx.update(|cx| {\n                    if let Some(request) = OpenRequest::parse(urls, cx).log_err() {\n                        handle_open_request(request, app_state.clone(), cx);\n                    }\n                })\n                .ok();\n            }\n        })\n        .detach();\n    });\n}\n\nfn handle_open_request(request: OpenRequest, app_state: Arc<AppState>, cx: &mut App) {\n    if let Some(connection) = request.cli_connection {\n        let app_state = app_state.clone();\n        cx.spawn(async move |cx| handle_cli_connection(connection, app_state, cx).await)\n            .detach();\n        return;\n    }\n\n    if let Some(action_index) = request.dock_menu_action {\n        cx.perform_dock_menu_action(action_index);\n        return;\n    }\n\n    if let Some(connection_options) = request.ssh_connection {\n        cx.spawn(async move |mut cx| {\n            let paths_with_position =\n                derive_paths_with_position(app_state.fs.as_ref(), request.open_paths).await;\n            open_ssh_project(\n                connection_options,\n                paths_with_position.into_iter().map(|p| p.path).collect(),\n                app_state,\n                workspace::OpenOptions::default(),\n                &mut cx,\n            )\n            .await\n        })\n        .detach_and_log_err(cx);\n        return;\n    }\n\n    let mut task = None;\n    if !request.open_paths.is_empty() {\n        let app_state = app_state.clone();\n        task = Some(cx.spawn(async move |mut cx| {\n            let paths_with_position =\n                derive_paths_with_position(app_state.fs.as_ref(), request.open_paths).await;\n            let (_window, results) = open_paths_with_positions(\n                &paths_with_position,\n                app_state,\n                workspace::OpenOptions::default(),\n                &mut cx,\n            )\n            .await?;\n            for result in results.into_iter().flatten() {\n                if let Err(err) = result {\n                    log::error!(": "",
    ",);\n                }\n            }\n            anyhow::Ok(())\n        }));\n    }\n\n    if !request.open_channel_notes.is_empty() || request.join_channel.is_some() {\n        cx.spawn(async move |mut cx| {\n            let result = maybe!(async {\n                if let Some(task) = task {\n                    task.await?;\n                }\n                let client = app_state.client.clone();\n                // we continue even if authentication fails as join_channel/ open channel notes will\n                // show a visible error message.\n                match authenticate(client, &cx).await {\n                    ConnectionResult::Timeout => {\n                        log::error!(": "",
    ")\n                    }\n                    ConnectionResult::ConnectionReset => {\n                        log::error!(": "",
    ")\n                    }\n                    ConnectionResult::Result(r) => r?,\n                };\n\n                if let Some(channel_id) = request.join_channel {\n                    cx.update(|cx| {\n                        workspace::join_channel(\n                            client::ChannelId(channel_id),\n                            app_state.clone(),\n                            None,\n                            cx,\n                        )\n                    })?\n                    .await?;\n                }\n\n                let workspace_window =\n                    workspace::get_any_active_workspace(app_state, cx.clone()).await?;\n                let workspace = workspace_window.entity(cx)?;\n\n                let mut promises = Vec::new();\n                for (channel_id, heading) in request.open_channel_notes {\n                    promises.push(cx.update_window(workspace_window.into(), |_, window, cx| {\n                        ChannelView::open(\n                            client::ChannelId(channel_id),\n                            heading,\n                            workspace.clone(),\n                            window,\n                            cx,\n                        )\n                        .log_err()\n                    })?)\n                }\n                future::join_all(promises).await;\n                anyhow::Ok(())\n            })\n            .await;\n            if let Err(err) = result {\n                fail_to_open_window_async(err, &mut cx);\n            }\n        })\n        .detach()\n    } else if let Some(task) = task {\n        cx.spawn(async move |mut cx| {\n            if let Err(err) = task.await {\n                fail_to_open_window_async(err, &mut cx);\n            }\n        })\n        .detach();\n    }\n}\n\nasync fn authenticate(client: Arc<Client>, cx: &AsyncApp) -> ConnectionResult<()> {\n    if stdout_is_a_pty() {\n        if client::IMPERSONATE_LOGIN.is_some() {\n            return client.authenticate_and_connect(false, cx).await;\n        } else if client.has_credentials(cx).await {\n            return client.authenticate_and_connect(true, cx).await;\n        }\n    } else if client.has_credentials(cx).await {\n        return client.authenticate_and_connect(true, cx).await;\n    }\n\n    ConnectionResult::Result(Ok(()))\n}\n\nasync fn system_id() -> Result<IdType> {\n    let key_name = ": "",
    ".to_string();\n\n    if let Ok(Some(system_id)) = GLOBAL_KEY_VALUE_STORE.read_kvp(&key_name) {\n        return Ok(IdType::Existing(system_id));\n    }\n\n    let system_id = Uuid::new_v4().to_string();\n\n    GLOBAL_KEY_VALUE_STORE\n        .write_kvp(key_name, system_id.clone())\n        .await?;\n\n    Ok(IdType::New(system_id))\n}\n\nasync fn installation_id() -> Result<IdType> {\n    let legacy_key_name = ": "",
    ".to_string();\n    let key_name = ": "",
    ".to_string();\n\n    // Migrate legacy key to new key\n    if let Ok(Some(installation_id)) = KEY_VALUE_STORE.read_kvp(&legacy_key_name) {\n        KEY_VALUE_STORE\n            .write_kvp(key_name, installation_id.clone())\n            .await?;\n        KEY_VALUE_STORE.delete_kvp(legacy_key_name).await?;\n        return Ok(IdType::Existing(installation_id));\n    }\n\n    if let Ok(Some(installation_id)) = KEY_VALUE_STORE.read_kvp(&key_name) {\n        return Ok(IdType::Existing(installation_id));\n    }\n\n    let installation_id = Uuid::new_v4().to_string();\n\n    KEY_VALUE_STORE\n        .write_kvp(key_name, installation_id.clone())\n        .await?;\n\n    Ok(IdType::New(installation_id))\n}\n\nasync fn restore_or_create_workspace(app_state: Arc<AppState>, cx: &mut AsyncApp) -> Result<()> {\n    if let Some(locations) = restorable_workspace_locations(cx, &app_state).await {\n        for location in locations {\n            match location {\n                SerializedWorkspaceLocation::Local(location, _) => {\n                    let task = cx.update(|cx| {\n                        workspace::open_paths(\n                            location.paths().as_ref(),\n                            app_state.clone(),\n                            workspace::OpenOptions::default(),\n                            cx,\n                        )\n                    })?;\n                    task.await?;\n                }\n                SerializedWorkspaceLocation::Ssh(ssh) => {\n                    let connection_options = cx.update(|cx| {\n                        SshSettings::get_global(cx)\n                            .connection_options_for(ssh.host, ssh.port, ssh.user)\n                    })?;\n                    let app_state = app_state.clone();\n                    cx.spawn(async move |cx| {\n                        recent_projects::open_ssh_project(\n                            connection_options,\n                            ssh.paths.into_iter().map(PathBuf::from).collect(),\n                            app_state,\n                            workspace::OpenOptions::default(),\n                            cx,\n                        )\n                        .await\n                        .log_err();\n                    })\n                    .detach();\n                }\n            }\n        }\n    } else if matches!(KEY_VALUE_STORE.read_kvp(FIRST_OPEN), Ok(None)) {\n        cx.update(|cx| show_welcome_view(app_state, cx))?.await?;\n    } else {\n        cx.update(|cx| {\n            workspace::open_new(\n                Default::default(),\n                app_state,\n                cx,\n                |workspace, window, cx| {\n                    Editor::new_file(workspace, &Default::default(), window, cx)\n                },\n            )\n        })?\n        .await?;\n    }\n\n    Ok(())\n}\n\npub(crate) async fn restorable_workspace_locations(\n    cx: &mut AsyncApp,\n    app_state: &Arc<AppState>,\n) -> Option<Vec<SerializedWorkspaceLocation>> {\n    let mut restore_behavior = cx\n        .update(|cx| WorkspaceSettings::get(None, cx).restore_on_startup)\n        .ok()?;\n\n    let session_handle = app_state.session.clone();\n    let (last_session_id, last_session_window_stack) = cx\n        .update(|cx| {\n            let session = session_handle.read(cx);\n\n            (\n                session.last_session_id().map(|id| id.to_string()),\n                session.last_session_window_stack(),\n            )\n        })\n        .ok()?;\n\n    if last_session_id.is_none()\n        && matches!(\n            restore_behavior,\n            workspace::RestoreOnStartupBehavior::LastSession\n        )\n    {\n        restore_behavior = workspace::RestoreOnStartupBehavior::LastWorkspace;\n    }\n\n    match restore_behavior {\n        workspace::RestoreOnStartupBehavior::LastWorkspace => {\n            workspace::last_opened_workspace_location()\n                .await\n                .map(|location| vec![location])\n        }\n        workspace::RestoreOnStartupBehavior::LastSession => {\n            if let Some(last_session_id) = last_session_id {\n                let ordered = last_session_window_stack.is_some();\n\n                let mut locations = workspace::last_session_workspace_locations(\n                    &last_session_id,\n                    last_session_window_stack,\n                )\n                .filter(|locations| !locations.is_empty());\n\n                // Since last_session_window_order returns the windows ordered front-to-back\n                // we need to open the window that was frontmost last.\n                if ordered {\n                    if let Some(locations) = locations.as_mut() {\n                        locations.reverse();\n                    }\n                }\n\n                locations\n            } else {\n                None\n            }\n        }\n        _ => None,\n    }\n}\n\nfn init_paths() -> HashMap<io::ErrorKind, Vec<&'static Path>> {\n    [\n        paths::config_dir(),\n        paths::extensions_dir(),\n        paths::languages_dir(),\n        paths::database_dir(),\n        paths::logs_dir(),\n        paths::temp_dir(),\n    ]\n    .into_iter()\n    .fold(HashMap::default(), |mut errors, path| {\n        if let Err(e) = std::fs::create_dir_all(path) {\n            errors.entry(e.kind()).or_insert_with(Vec::new).push(path);\n        }\n        errors\n    })\n}\n\npub fn stdout_is_a_pty() -> bool {\n    std::env::var(FORCE_CLI_MODE_ENV_VAR_NAME).ok().is_none() && io::stdout().is_terminal()\n}\n\n#[derive(Parser, Debug)]\n#[command(name = ": "",
    ", disable_version_flag = true)]\nstruct Args {\n    /// A sequence of space-separated paths or urls that you want to open.\n    ///\n    /// Use `path:line:row` syntax to open a file at a specific location.\n    /// Non-existing paths and directories will ignore `:line:row` suffix.\n    ///\n    /// URLs can either be `file://` or `zed://` scheme, or relative to <https://zed.dev>.\n    paths_or_urls: Vec<String>,\n\n    /// Sets a custom directory for all user data (e.g., database, extensions, logs).\n    /// This overrides the default platform-specific data directory location.\n    /// On macOS, the default is `~/Library/Application Support/Zed`.\n    /// On Linux/FreeBSD, the default is `$XDG_DATA_HOME/zed`.\n    /// On Windows, the default is `%LOCALAPPDATA%\\Zed`.\n    #[arg(long, value_name = ": "",
    ")]\n    user_data_dir: Option<String>,\n\n    /// Instructs zed to run as a dev server on this machine. (not implemented)\n    #[arg(long)]\n    dev_server_token: Option<String>,\n\n    /// Prints system specs. Useful for submitting issues on GitHub when encountering a bug\n    /// that prevents Zed from starting, so you can't run `zed: copy system specs to clipboard`\n    #[arg(long)]\n    system_specs: bool,\n\n    /// Used for SSH/Git password authentication, to remove the need for netcat as a dependency,\n    /// by having Zed act like netcat communicating over a Unix socket.\n    #[arg(long, hide = true)]\n    askpass: Option<String>,\n\n    /// Run zed in the foreground, only used on Windows, to match the behavior on macOS.\n    #[arg(long)]\n    #[cfg(target_os = ": "",
    ")]\n    #[arg(hide = true)]\n    foreground: bool,\n\n    /// The dock action to perform. This is used on Windows only.\n    #[arg(long)]\n    #[cfg(target_os = ": "",
    ")]\n    #[arg(hide = true)]\n    dock_action: Option<usize>,\n\n    #[arg(long, hide = true)]\n    dump_all_actions: bool,\n}\n\n#[derive(Clone, Debug)]\nenum IdType {\n    New(String),\n    Existing(String),\n}\n\nimpl ToString for IdType {\n    fn to_string(&self) -> String {\n        match self {\n            IdType::New(id) | IdType::Existing(id) => id.clone(),\n        }\n    }\n}\n\nfn parse_url_arg(arg: &str, cx: &App) -> Result<String> {\n    match std::fs::canonicalize(Path::new(&arg)) {\n        Ok(path) => Ok(format!(": "",
    ", path.display())),\n        Err(error) => {\n            if arg.starts_with(": "",
    ")\n                || arg.starts_with(": "",
    ")\n                || parse_zed_link(arg, cx).is_some()\n            {\n                Ok(arg.into())\n            } else {\n                anyhow::bail!(": "",
    ")\n            }\n        }\n    }\n}\n\nfn load_embedded_fonts(cx: &App) {\n    let asset_source = cx.asset_source();\n    let font_paths = asset_source.list(": "",
    ").unwrap();\n    let embedded_fonts = Mutex::new(Vec::new());\n    let executor = cx.background_executor();\n\n    executor.block(executor.scoped(|scope| {\n        for font_path in &font_paths {\n            if !font_path.ends_with(": "",
    ") {\n                continue;\n            }\n\n            scope.spawn(async {\n                let font_bytes = asset_source.load(font_path).unwrap().unwrap();\n                embedded_fonts.lock().push(font_bytes);\n            });\n        }\n    }));\n\n    cx.text_system()\n        .add_fonts(embedded_fonts.into_inner())\n        .unwrap();\n}\n\n/// Eagerly loads the active theme and icon theme based on the selections in the\n/// theme settings.\n///\n/// This fast path exists to load these themes as soon as possible so the user\n/// doesn't see the default themes while waiting on extensions to load.\nfn eager_load_active_theme_and_icon_theme(fs: Arc<dyn Fs>, cx: &App) {\n    let extension_store = ExtensionStore::global(cx);\n    let theme_registry = ThemeRegistry::global(cx);\n    let theme_settings = ThemeSettings::get_global(cx);\n    let appearance = SystemAppearance::global(cx).0;\n\n    if let Some(theme_selection) = theme_settings.theme_selection.as_ref() {\n        let theme_name = theme_selection.theme(appearance);\n        if matches!(theme_registry.get(theme_name), Err(ThemeNotFoundError(_))) {\n            if let Some(theme_path) = extension_store.read(cx).path_to_extension_theme(theme_name) {\n                cx.spawn({\n                    let theme_registry = theme_registry.clone();\n                    let fs = fs.clone();\n                    async move |cx| {\n                        theme_registry.load_user_theme(&theme_path, fs).await?;\n\n                        cx.update(|cx| {\n                            ThemeSettings::reload_current_theme(cx);\n                        })\n                    }\n                })\n                .detach_and_log_err(cx);\n            }\n        }\n    }\n\n    if let Some(icon_theme_selection) = theme_settings.icon_theme_selection.as_ref() {\n        let icon_theme_name = icon_theme_selection.icon_theme(appearance);\n        if matches!(\n            theme_registry.get_icon_theme(icon_theme_name),\n            Err(IconThemeNotFoundError(_))\n        ) {\n            if let Some((icon_theme_path, icons_root_path)) = extension_store\n                .read(cx)\n                .path_to_extension_icon_theme(icon_theme_name)\n            {\n                cx.spawn({\n                    let theme_registry = theme_registry.clone();\n                    let fs = fs.clone();\n                    async move |cx| {\n                        theme_registry\n                            .load_icon_theme(&icon_theme_path, &icons_root_path, fs)\n                            .await?;\n\n                        cx.update(|cx| {\n                            ThemeSettings::reload_current_icon_theme(cx);\n                        })\n                    }\n                })\n                .detach_and_log_err(cx);\n            }\n        }\n    }\n}\n\n/// Spawns a background task to load the user themes from the themes directory.\nfn load_user_themes_in_background(fs: Arc<dyn fs::Fs>, cx: &mut App) {\n    cx.spawn({\n        let fs = fs.clone();\n        async move |cx| {\n            if let Some(theme_registry) =\n                cx.update(|cx| ThemeRegistry::global(cx).clone()).log_err()\n            {\n                let themes_dir = paths::themes_dir().as_ref();\n                match fs\n                    .metadata(themes_dir)\n                    .await\n                    .ok()\n                    .flatten()\n                    .map(|m| m.is_dir)\n                {\n                    Some(is_dir) => {\n                        anyhow::ensure!(is_dir, ": "",
    ")\n                    }\n                    None => {\n                        fs.create_dir(themes_dir).await.with_context(|| {\n                            format!(": "",
    ")\n                        })?;\n                    }\n                }\n                theme_registry.load_user_themes(themes_dir, fs).await?;\n                cx.update(ThemeSettings::reload_current_theme)?;\n            }\n            anyhow::Ok(())\n        }\n    })\n    .detach_and_log_err(cx);\n}\n\n/// Spawns a background task to watch the themes directory for changes.\nfn watch_themes(fs: Arc<dyn fs::Fs>, cx: &mut App) {\n    use std::time::Duration;\n    cx.spawn(async move |cx| {\n        let (mut events, _) = fs\n            .watch(paths::themes_dir(), Duration::from_millis(100))\n            .await;\n\n        while let Some(paths) = events.next().await {\n            for event in paths {\n                if fs.metadata(&event.path).await.ok().flatten().is_some() {\n                    if let Some(theme_registry) =\n                        cx.update(|cx| ThemeRegistry::global(cx).clone()).log_err()\n                    {\n                        if let Some(()) = theme_registry\n                            .load_user_theme(&event.path, fs.clone())\n                            .await\n                            .log_err()\n                        {\n                            cx.update(ThemeSettings::reload_current_theme).log_err();\n                        }\n                    }\n                }\n            }\n        }\n    })\n    .detach()\n}\n\n#[cfg(debug_assertions)]\nfn watch_languages(fs: Arc<dyn fs::Fs>, languages: Arc<LanguageRegistry>, cx: &mut App) {\n    use std::time::Duration;\n\n    let path = {\n        let p = Path::new(": "",
    ");\n        let Ok(full_path) = p.canonicalize() else {\n            return;\n        };\n        full_path\n    };\n\n    cx.spawn(async move |_| {\n        let (mut events, _) = fs.watch(path.as_path(), Duration::from_millis(100)).await;\n        while let Some(event) = events.next().await {\n            let has_language_file = event.iter().any(|event| {\n                event\n                    .path\n                    .extension()\n                    .map(|ext| ext.to_string_lossy().as_ref() == ": ""
  },
  "zed/crates/zed/src/reliability.rs": {
    "<unnamed>": "",
    "Box<Any>": "",
    "Thread {:?} panicked with {:?} at {}:{}:{}\\n{}{:?}": "",
    ",\n                        commit_sha.full(),\n                        location.file(),\n                        location.line()\n                    ),\n                    None => ": "",
    ".to_string(),\n                },\n                backtrace,\n            );\n            std::process::exit(-1);\n        }\n        let main_module_base_address = get_main_module_base_address();\n\n        let backtrace = Backtrace::new();\n        let mut symbols = backtrace\n            .frames()\n            .iter()\n            .flat_map(|frame| {\n                let base = frame\n                    .module_base_address()\n                    .unwrap_or(main_module_base_address);\n                frame.symbols().iter().map(move |symbol| {\n                    format!(\n                        ": "",
    ",\n                        symbol\n                            .name()\n                            .as_ref()\n                            .map_or(": "",
    ".to_owned(), <_>::to_string),\n                        (frame.ip() as isize).saturating_sub(base as isize)\n                    )\n                })\n            })\n            .collect::<Vec<_>>();\n\n        // Strip out leading stack frames for rust panic-handling.\n        if let Some(ix) = symbols\n            .iter()\n            .position(|name| name == ": "",
    " || name == ": "",
    ")\n        {\n            symbols.drain(0..=ix);\n        }\n\n        let panic_data = telemetry_events::Panic {\n            thread: thread_name.into(),\n            payload,\n            location_data: info.location().map(|location| LocationData {\n                file: location.file().into(),\n                line: location.line(),\n            }),\n            app_version: app_version.to_string(),\n            app_commit_sha: app_commit_sha.as_ref().map(|sha| sha.full()),\n            release_channel: RELEASE_CHANNEL.dev_name().into(),\n            target: env!(": "",
    ").to_owned().into(),\n            os_name: telemetry::os_name(),\n            os_version: Some(telemetry::os_version()),\n            architecture: env::consts::ARCH.into(),\n            panicked_on: Utc::now().timestamp_millis(),\n            backtrace: symbols,\n            system_id: system_id.clone(),\n            installation_id: installation_id.clone(),\n            session_id: session_id.clone(),\n        };\n\n        if let Some(panic_data_json) = serde_json::to_string_pretty(&panic_data).log_err() {\n            log::error!(": "",
    ", panic_data_json);\n        }\n        zlog::flush();\n\n        if !is_pty {\n            if let Some(panic_data_json) = serde_json::to_string(&panic_data).log_err() {\n                let timestamp = chrono::Utc::now().format(": "",
    ").to_string();\n                let panic_file_path = paths::logs_dir().join(format!(": "",
    "));\n                let panic_file = std::fs::OpenOptions::new()\n                    .append(true)\n                    .create(true)\n                    .open(&panic_file_path)\n                    .log_err();\n                if let Some(mut panic_file) = panic_file {\n                    writeln!(&mut panic_file, ": "",
    ").log_err();\n                    panic_file.flush().log_err();\n                }\n            }\n        }\n\n        std::process::abort();\n    }));\n}\n\n#[cfg(not(target_os = ": "",
    "))]\nfn get_main_module_base_address() -> *mut c_void {\n    let mut dl_info = libc::Dl_info {\n        dli_fname: std::ptr::null(),\n        dli_fbase: std::ptr::null_mut(),\n        dli_sname: std::ptr::null(),\n        dli_saddr: std::ptr::null_mut(),\n    };\n    unsafe {\n        libc::dladdr(get_main_module_base_address as _, &mut dl_info);\n    }\n    dl_info.dli_fbase\n}\n\n#[cfg(target_os = ": "",
    ")]\nfn get_main_module_base_address() -> *mut c_void {\n    std::ptr::null_mut()\n}\n\npub fn init(\n    http_client: Arc<HttpClientWithUrl>,\n    system_id: Option<String>,\n    installation_id: Option<String>,\n    session_id: String,\n    cx: &mut App,\n) {\n    #[cfg(target_os = ": "",
    ")]\n    monitor_main_thread_hangs(http_client.clone(), installation_id.clone(), cx);\n\n    let Some(panic_report_url) = http_client\n        .build_zed_api_url(": "",
    ", &[])\n        .log_err()\n    else {\n        return;\n    };\n\n    upload_panics_and_crashes(\n        http_client.clone(),\n        panic_report_url.clone(),\n        installation_id.clone(),\n        cx,\n    );\n\n    cx.observe_new(move |project: &mut Project, _, cx| {\n        let http_client = http_client.clone();\n        let panic_report_url = panic_report_url.clone();\n        let session_id = session_id.clone();\n        let installation_id = installation_id.clone();\n        let system_id = system_id.clone();\n\n        if let Some(ssh_client) = project.ssh_client() {\n            ssh_client.update(cx, |client, cx| {\n                if TelemetrySettings::get_global(cx).diagnostics {\n                    let request = client.proto_client().request(proto::GetPanicFiles {});\n                    cx.background_spawn(async move {\n                        let panic_files = request.await?;\n                        for file in panic_files.file_contents {\n                            let panic: Option<Panic> = serde_json::from_str(&file)\n                                .log_err()\n                                .or_else(|| {\n                                    file.lines()\n                                        .next()\n                                        .and_then(|line| serde_json::from_str(line).ok())\n                                })\n                                .unwrap_or_else(|| {\n                                    log::error!(": "",
    ", file);\n                                    None\n                                });\n\n                            if let Some(mut panic) = panic {\n                                panic.session_id = session_id.clone();\n                                panic.system_id = system_id.clone();\n                                panic.installation_id = installation_id.clone();\n\n                                upload_panic(&http_client, &panic_report_url, panic, &mut None)\n                                    .await?;\n                            }\n                        }\n\n                        anyhow::Ok(())\n                    })\n                    .detach_and_log_err(cx);\n                }\n            })\n        }\n    })\n    .detach();\n}\n\n#[cfg(target_os = ": "",
    ")]\npub fn monitor_main_thread_hangs(\n    http_client: Arc<HttpClientWithUrl>,\n    installation_id: Option<String>,\n    cx: &App,\n) {\n    // This is too noisy to ship to stable for now.\n    if !matches!(\n        ReleaseChannel::global(cx),\n        ReleaseChannel::Dev | ReleaseChannel::Nightly | ReleaseChannel::Preview\n    ) {\n        return;\n    }\n\n    use nix::sys::signal::{\n        SaFlags, SigAction, SigHandler, SigSet,\n        Signal::{self, SIGUSR2},\n        sigaction,\n    };\n\n    use parking_lot::Mutex;\n\n    use http_client::Method;\n    use std::{\n        ffi::c_int,\n        sync::{OnceLock, mpsc},\n        time::Duration,\n    };\n    use telemetry_events::{BacktraceFrame, HangReport};\n\n    use nix::sys::pthread;\n\n    let foreground_executor = cx.foreground_executor();\n    let background_executor = cx.background_executor();\n    let telemetry_settings = *client::TelemetrySettings::get_global(cx);\n\n    // Initialize SIGUSR2 handler to send a backtrace to a channel.\n    let (backtrace_tx, backtrace_rx) = mpsc::channel();\n    static BACKTRACE: Mutex<Vec<backtrace::Frame>> = Mutex::new(Vec::new());\n    static BACKTRACE_SENDER: OnceLock<mpsc::Sender<()>> = OnceLock::new();\n    BACKTRACE_SENDER.get_or_init(|| backtrace_tx);\n    BACKTRACE.lock().reserve(100);\n\n    fn handle_backtrace_signal() {\n        unsafe {\n            extern ": "",
    " fn handle_sigusr2(_i: c_int) {\n                unsafe {\n                    // ASYNC SIGNAL SAFETY: This lock is only accessed one other time,\n                    // which can only be triggered by This signal handler. In addition,\n                    // this signal handler is immediately removed by SA_RESETHAND, and this\n                    // signal handler cannot be re-entrant due to the SIGUSR2 mask defined\n                    // below\n                    let mut bt = BACKTRACE.lock();\n                    bt.clear();\n                    backtrace::trace_unsynchronized(|frame| {\n                        if bt.len() < bt.capacity() {\n                            bt.push(frame.clone());\n                            true\n                        } else {\n                            false\n                        }\n                    });\n                }\n\n                BACKTRACE_SENDER.get().unwrap().send(()).ok();\n            }\n\n            let mut mask = SigSet::empty();\n            mask.add(SIGUSR2);\n            sigaction(\n                Signal::SIGUSR2,\n                &SigAction::new(\n                    SigHandler::Handler(handle_sigusr2),\n                    SaFlags::SA_RESTART | SaFlags::SA_RESETHAND,\n                    mask,\n                ),\n            )\n            .log_err();\n        }\n    }\n\n    handle_backtrace_signal();\n    let main_thread = pthread::pthread_self();\n\n    let (mut tx, mut rx) = futures::channel::mpsc::channel(3);\n    foreground_executor\n        .spawn(async move { while (rx.next().await).is_some() {} })\n        .detach();\n\n    background_executor\n        .spawn({\n            let background_executor = background_executor.clone();\n            async move {\n                loop {\n                    background_executor.timer(Duration::from_secs(1)).await;\n                    match tx.try_send(()) {\n                        Ok(_) => continue,\n                        Err(e) => {\n                            if e.into_send_error().is_full() {\n                                pthread::pthread_kill(main_thread, SIGUSR2).log_err();\n                            }\n                            // Only detect the first hang\n                            break;\n                        }\n                    }\n                }\n            }\n        })\n        .detach();\n\n    let app_version = release_channel::AppVersion::global(cx);\n    let os_name = client::telemetry::os_name();\n\n    background_executor\n        .clone()\n        .spawn(async move {\n            let os_version = client::telemetry::os_version();\n\n            loop {\n                while backtrace_rx.recv().is_ok() {\n                    if !telemetry_settings.diagnostics {\n                        return;\n                    }\n\n                    // ASYNC SIGNAL SAFETY: This lock is only accessed _after_\n                    // the backtrace transmitter has fired, which itself is only done\n                    // by the signal handler. And due to SA_RESETHAND  the signal handler\n                    // will not run again until `handle_backtrace_signal` is called.\n                    let raw_backtrace = BACKTRACE.lock().drain(..).collect::<Vec<_>>();\n                    let backtrace: Vec<_> = raw_backtrace\n                        .into_iter()\n                        .map(|frame| {\n                            let mut btf = BacktraceFrame {\n                                ip: frame.ip() as usize,\n                                symbol_addr: frame.symbol_address() as usize,\n                                base: frame.module_base_address().map(|addr| addr as usize),\n                                symbols: vec![],\n                            };\n\n                            backtrace::resolve_frame(&frame, |symbol| {\n                                if let Some(name) = symbol.name() {\n                                    btf.symbols.push(name.to_string());\n                                }\n                            });\n\n                            btf\n                        })\n                        .collect();\n\n                    // IMPORTANT: Don't move this to before `BACKTRACE.lock()`\n                    handle_backtrace_signal();\n\n                    log::error!(\n                        ": "",
    ",\n                        backtrace\n                            .iter()\n                            .flat_map(|bt| bt.symbols.first().as_ref().map(|s| s.as_str()))\n                            .collect::<Vec<_>>()\n                            .join(": "",
    ")\n                    );\n\n                    let report = HangReport {\n                        backtrace,\n                        app_version: Some(app_version),\n                        os_name: os_name.clone(),\n                        os_version: Some(os_version.clone()),\n                        architecture: env::consts::ARCH.into(),\n                        installation_id: installation_id.clone(),\n                    };\n\n                    let Some(json_bytes) = serde_json::to_vec(&report).log_err() else {\n                        continue;\n                    };\n\n                    let Some(checksum) = client::telemetry::calculate_json_checksum(&json_bytes)\n                    else {\n                        continue;\n                    };\n\n                    let Ok(url) = http_client.build_zed_api_url(": "",
    ", &[]) else {\n                        continue;\n                    };\n\n                    let Ok(request) = http_client::Request::builder()\n                        .method(Method::POST)\n                        .uri(url.as_ref())\n                        .header(": "",
    ", checksum)\n                        .body(json_bytes.into())\n                    else {\n                        continue;\n                    };\n\n                    if let Some(response) = http_client.send(request).await.log_err() {\n                        if response.status() != 200 {\n                            log::error!(": "",
    ", response.status());\n                        }\n                    }\n                }\n            }\n        })\n        .detach()\n}\n\nfn upload_panics_and_crashes(\n    http: Arc<HttpClientWithUrl>,\n    panic_report_url: Url,\n    installation_id: Option<String>,\n    cx: &App,\n) {\n    let telemetry_settings = *client::TelemetrySettings::get_global(cx);\n    cx.background_spawn(async move {\n        let most_recent_panic =\n            upload_previous_panics(http.clone(), &panic_report_url, telemetry_settings)\n                .await\n                .log_err()\n                .flatten();\n        upload_previous_crashes(http, most_recent_panic, installation_id, telemetry_settings)\n            .await\n            .log_err()\n    })\n    .detach()\n}\n\n/// Uploads panics via `zed.dev`.\nasync fn upload_previous_panics(\n    http: Arc<HttpClientWithUrl>,\n    panic_report_url: &Url,\n    telemetry_settings: client::TelemetrySettings,\n) -> anyhow::Result<Option<(i64, String)>> {\n    let mut children = smol::fs::read_dir(paths::logs_dir()).await?;\n\n    let mut most_recent_panic = None;\n\n    while let Some(child) = children.next().await {\n        let child = child?;\n        let child_path = child.path();\n\n        if child_path.extension() != Some(OsStr::new(": "",
    ")) {\n            continue;\n        }\n        let filename = if let Some(filename) = child_path.file_name() {\n            filename.to_string_lossy()\n        } else {\n            continue;\n        };\n\n        if !filename.starts_with(": "",
    ") {\n            continue;\n        }\n\n        if telemetry_settings.diagnostics {\n            let panic_file_content = smol::fs::read_to_string(&child_path)\n                .await\n                .context(": "",
    ")?;\n\n            let panic: Option<Panic> = serde_json::from_str(&panic_file_content)\n                .log_err()\n                .or_else(|| {\n                    panic_file_content\n                        .lines()\n                        .next()\n                        .and_then(|line| serde_json::from_str(line).ok())\n                })\n                .unwrap_or_else(|| {\n                    log::error!(": "",
    ", panic_file_content);\n                    None\n                });\n\n            if let Some(panic) = panic {\n                if !upload_panic(&http, &panic_report_url, panic, &mut most_recent_panic).await? {\n                    continue;\n                }\n            }\n        }\n\n        // We've done what we can, delete the file\n        std::fs::remove_file(child_path)\n            .context(": "",
    ")\n            .log_err();\n    }\n    Ok(most_recent_panic)\n}\n\nasync fn upload_panic(\n    http: &Arc<HttpClientWithUrl>,\n    panic_report_url: &Url,\n    panic: telemetry_events::Panic,\n    most_recent_panic: &mut Option<(i64, String)>,\n) -> Result<bool> {\n    *most_recent_panic = Some((panic.panicked_on, panic.payload.clone()));\n\n    let json_bytes = serde_json::to_vec(&PanicRequest { panic }).unwrap();\n\n    let Some(checksum) = client::telemetry::calculate_json_checksum(&json_bytes) else {\n        return Ok(false);\n    };\n\n    let Ok(request) = http_client::Request::builder()\n        .method(Method::POST)\n        .uri(panic_report_url.as_ref())\n        .header(": "",
    ", checksum)\n        .body(json_bytes.into())\n    else {\n        return Ok(false);\n    };\n\n    let response = http.send(request).await.context(": "",
    ")?;\n    if !response.status().is_success() {\n        log::error!(": "",
    ", response.status());\n    }\n\n    Ok(true)\n}\nconst LAST_CRASH_UPLOADED: &str = ": "",
    ";\n\n/// upload crashes from apple's diagnostic reports to our server.\n/// (only if telemetry is enabled)\nasync fn upload_previous_crashes(\n    http: Arc<HttpClientWithUrl>,\n    most_recent_panic: Option<(i64, String)>,\n    installation_id: Option<String>,\n    telemetry_settings: client::TelemetrySettings,\n) -> Result<()> {\n    if !telemetry_settings.diagnostics {\n        return Ok(());\n    }\n    let last_uploaded = KEY_VALUE_STORE\n        .read_kvp(LAST_CRASH_UPLOADED)?\n        .unwrap_or(": "",
    ".to_string()); // don't upload old crash reports from before we had this.\n    let mut uploaded = last_uploaded.clone();\n\n    let crash_report_url = http.build_zed_api_url(": "",
    ", &[])?;\n\n    // Crash directories are only set on macOS.\n    for dir in [crashes_dir(), crashes_retired_dir()]\n        .iter()\n        .filter_map(|d| d.as_deref())\n    {\n        let mut children = smol::fs::read_dir(&dir).await?;\n        while let Some(child) = children.next().await {\n            let child = child?;\n            let Some(filename) = child\n                .path()\n                .file_name()\n                .map(|f| f.to_string_lossy().to_lowercase())\n            else {\n                continue;\n            };\n\n            if !filename.starts_with(": "",
    ") || !filename.ends_with(": "",
    ") {\n                continue;\n            }\n\n            if filename <= last_uploaded {\n                continue;\n            }\n\n            let body = smol::fs::read_to_string(&child.path())\n                .await\n                .context(": "",
    ")?;\n\n            let mut request = http_client::Request::post(&crash_report_url.to_string())\n                .follow_redirects(http_client::RedirectPolicy::FollowAll)\n                .header(": "",
    ", ": "",
    ");\n\n            if let Some((panicked_on, payload)) = most_recent_panic.as_ref() {\n                request = request\n                    .header(": "",
    ", format!(": "",
    "))\n                    .header(": "",
    ", payload)\n            }\n            if let Some(installation_id) = installation_id.as_ref() {\n                request = request.header(": "",
    ", installation_id);\n            }\n\n            let request = request.body(body.into())?;\n\n            let response = http.send(request).await.context(": "",
    ")?;\n            if !response.status().is_success() {\n                log::error!(": ""
  },
  "zed/crates/zed/src/zed.rs": {
    "macos": "",
    "windows": "",
    "licenses.md": "",
    "Open Source License Attribution": "",
    "Markdown": "",
    "Default Settings": "",
    "JSON": "",
    "Default Key Bindings": "",
    "ZED_WINDOW_DECORATIONS": "",
    "server": "",
    "client": "",
    "Using GPU: {:?}": "",
    "linux": "",
    "freebsd": "",
    "\n            inotify_init returned {}\n\n            This may be due to system-wide limits on inotify instances. For troubleshooting see: https://zed.dev/docs/linux\n            ": "",
    "Could not start inotify": "",
    "Troubleshoot and Quit": "",
    "https://zed.dev/docs/linux#could-not-start-inotify": "",
    "\n            ReadDirectoryChangesW initialization failed: {}\n\n            This may occur on network filesystems and WSL paths. For troubleshooting see: https://zed.dev/docs/windows\n            ": "",
    "Could not start ReadDirectoryChangesW": "",
    "https://zed.dev/docs/windows": "",
    "ZED_ALLOW_EMULATED_GPU": "",
    "\n            Zed uses Vulkan for rendering and requires a compatible GPU.\n\n            Currently you are using a software emulated GPU ({}) which\n            will result in awful performance.\n\n            For troubleshooting see: https://zed.dev/docs/linux\n            Set ZED_ALLOW_EMULATED_GPU=1 env var to permanently override.\n            ": "",
    "Unsupported GPU": "",
    "Skip": "",
    "https://zed.dev/docs/linux#zed-fails-to-open-windows": "",
    "Project Opened": "",
    "zed:// links will now open in {}.": "",
    "Error registering zed:// scheme": "",
    "Settings file must have a location": "",
    "CARGO_PKG_VERSION": "",
    "(debug)": "",
    "": "",
    "{release_channel} {version} {debug}": "",
    "OK": "",
    "Ran the TestPanic action": "",
    "Are you sure you want to quit?": "",
    "Quit": "",
    "Cancel": "",
    "\\n": "",
    "Unable to access/open log file at path {:?}": "",
    "Log": "",
    "Last {} lines in {}": "",
    "user": "",
    "global": "",
    "Failed to load {} settings: {err}": "",
    "JSON parse error in keymap file. Bindings not reloaded.\\n\\n{error}": "",
    "Open Keymap File": "",
    "notification-cache": "",
    "New Window": "",
    "Invalid user settings file\\n{error}": "",
    "Open Settings File": "",
    "Not an ssh project": "",
    "worktree was removed": "",
    "unexpected item type: expected editor item": "",
    "This project has no folders open.": "",
    "// No data has been collected yet": "",
    "// Zed collects anonymous usage data to help us understand how people are using the app.\\n": "",
    "// Telemetry can be disabled via the `settings.json` file.\\n": "",
    "// Here is the data that has been reported for the current session:\\n": "",
    "{}\\n{}": "",
    "Telemetry Log": "",
    "/root": "",
    "a": "",
    "/root/a/new": "",
    "aa": "",
    "ab": "",
    "b": "",
    "ba": "",
    "bb": "",
    "c": "",
    "ca": "",
    "cb": "",
    "d": "",
    "da": "",
    "db": "",
    "e": "",
    "ea": "",
    "eb": "",
    "/root/a": "",
    "/root/b": "",
    "/root/c": "",
    "/root/d": "",
    "/root/e": "",
    "hey": "",
    "dir": "",
    "f": "",
    "/root/dir": "",
    "/root/dir/c": "",
    "dir1": "",
    "dir2": "",
    "/root/dir1/a": "",
    "/root/dir2/c": "",
    "/root/dir2": "",
    "EDIT": "",
    "Don't Save": "",
    "EDIThey": "",
    "/root/the-new-name": "",
    "the-new-name": "",
    "file1": "",
    "contents 1": "",
    "file2": "",
    "contents 2": "",
    "file3": "",
    "contents 3": "",
    "/": "",
    "a.txt": "",
    "b.txt": "",
    "dir3": "",
    "c.txt": "",
    "d.txt": "",
    "/dir1/": "",
    "found no project panels": "",
    "project panel should have a selected entry": "",
    "Unexpected project panel selected worktree path": "",
    "Unexpected project panel selected entry path": "",
    "/dir1/a.txt": "",
    "/dir1": "",
    "/dir2/b.txt": "",
    "/dir3": "",
    "/dir3/c.txt": "",
    "/d.txt": "",
    "excluded_dir": "",
    "**/.git": "",
    ".gitignore": "",
    "ignored_dir\\n": "",
    ".git": "",
    "HEAD": "",
    "ref: refs/heads/main": "",
    "regular_dir": "",
    "file": "",
    "regular file contents": "",
    "ignored_dir": "",
    "ignored_subdir": "",
    "ignored subfile contents": "",
    "ignored file contents": "",
    "excluded file contents": "",
    "/root/excluded_dir/file": "",
    "/root/.git/HEAD": "",
    "/root/excluded_dir/ignored_subdir": "",
    "Excluded files in subfolders of a workspace root should be opened in the workspace": "",
    "Expect to get the same number of opened items as submitted paths to open": "",
    "Excluded file {path:?} failed to open: {e:?}": "",
    ".git/HEAD": "",
    "excluded_dir/file": "",
    "Excluded files should get opened, excluded dir should not get opened": "",
    "Workspace entries should not change after opening excluded files and directories paths": "",
    "all excluded files that got open should have a path": "",
    "Despite not being present in the worktrees, buffers for excluded files are opened and added to the pane": "",
    "/root/a.txt": "",
    "x": "",
    "changed": "",
    "Overwrite": "",
    "untitled": "",
    "hi": "",
    "the-new-name.rs": "",
    "Rust": "",
    " there": "",
    "/root/the-new-name.rs": "",
    "dirt": "",
    "contents 1\\n": "",
    "contents 2\\n": "",
    "contents 3\\n": "",
    "/root/a/file2": "",
    "file4": "",
    "/settings.json": "",
    "{": "",
    ": ": "",
    "}": "",
    "/keymap.json": "",
    "[{": "",
    ": {": "",
    "}}]": "",
    "/global_settings.json": "",
    "backspace": "",
    "k": "",
    ": null}}]": "",
    "6": "",
    "vim::FindCommand": "",
    "vim::Literal": "",
    "vim::ResizePane": "",
    "vim::PushObject": "",
    "vim::PushFindForward": "",
    "vim::PushFindBackward": "",
    "vim::PushSneak": "",
    "vim::PushSneakBackward": "",
    "vim::PushChangeSurrounds": "",
    "vim::PushJump": "",
    "vim::PushDigraph": "",
    "vim::PushLiteral": "",
    "vim::Number": "",
    "vim::SelectRegister": "",
    "git::StageAndNext": "",
    "git::UnstageAndNext": "",
    "terminal::SendText": "",
    "terminal::SendKeystroke": "",
    "app_menu::OpenApplicationMenu": "",
    "picker::ConfirmInput": "",
    "editor::HandleInput": "",
    "editor::FoldAtLevel": "",
    "pane::ActivateItem": "",
    "workspace::ActivatePane": "",
    "workspace::MoveItemToPane": "",
    "workspace::MoveItemToPaneInDirection": "",
    "workspace::OpenTerminal": "",
    "workspace::SendKeystrokes": "",
    "zed::OpenBrowser": "",
    "zed::OpenZedUrl": "",
    "{action} failed to build: {err:?}": "",
    "Failed to build actions using {{}} as input: {:?}. Errors:\\n{}": "",
    "fonts/plex-mono/ZedPlexMono-Regular.ttf": "",
    "fonts/plex-sans/ZedPlexSans-Regular.ttf": "",
    "language name {name}": "",
    "rs": "",
    "md": "",
    "On {} Failed to find {}": "",
    "On {} Failed to find {} with key binding {}": "",
    "Running test_opening_project_settings_when_excluded": "",
    "{ ": "",
    ": true, ": "",
    ": { ": "",
    ": false } } }": "",
    ".zed": "",
    "settings.json": "",
    "Created project with .zed/settings.json containing UNIQUEVALUE": "",
    "/root/.zed/settings.json": "",
    "Original settings content: {}": "",
    "UNIQUEVALUE": "",
    "Test setup failed - settings file doesn't contain our marker": "",
    "Added .zed to file_scan_exclusions in settings": "",
    "Is .zed directory visible in worktree after exclusion: {}": "",
    "Test precondition failed: .zed directory should be excluded but was found in worktree": "",
    "About to call open_project_settings_file": "",
    "New settings content: {}": "",
    "Bug reproduced: {}": "",
    "BUG FOUND: Project settings were overwritten when opening via command - original custom content was lost": ""
  },
  "zed/crates/zed/src/zed/app_menus.rs": {
    "Zed": "",
    "About Zed…": "",
    "Check for Updates": "",
    "Settings": "",
    "Open Settings": "",
    "Open Key Bindings": "",
    "Open Default Settings": "",
    "Open Default Key Bindings": "",
    "Open Project Settings": "",
    "Select Theme...": "",
    "Services": "",
    "Extensions": "",
    "Install CLI": "",
    "macos": "",
    "Hide Zed": "",
    "Hide Others": "",
    "Show All": "",
    "Quit Zed": "",
    "File": "",
    "New": "",
    "New Window": "",
    "Open File...": "",
    "Open Folder...": "",
    "Open…": "",
    "Open Recent...": "",
    "Open Remote...": "",
    "Add Folder to Project…": "",
    "Save": "",
    "Save As…": "",
    "Save All": "",
    "Close Editor": "",
    "Close Window": "",
    "Edit": "",
    "Undo": "",
    "Redo": "",
    "Cut": "",
    "Copy": "",
    "Copy and Trim": "",
    "Paste": "",
    "Find": "",
    "Find In Project": "",
    "Toggle Line Comment": "",
    "Selection": "",
    "Select All": "",
    "Expand Selection": "",
    "Shrink Selection": "",
    "Add Cursor Above": "",
    "Add Cursor Below": "",
    "Select Next Occurrence": "",
    "Move Line Up": "",
    "Move Line Down": "",
    "Duplicate Selection": "",
    "View": "",
    "Zoom In": "",
    "Zoom Out": "",
    "Reset Zoom": "",
    "Toggle Left Dock": "",
    "Toggle Right Dock": "",
    "Toggle Bottom Dock": "",
    "Close All Docks": "",
    "Editor Layout": "",
    "Split Up": "",
    "Split Down": "",
    "Split Left": "",
    "Split Right": "",
    "Project Panel": "",
    "Outline Panel": "",
    "Collab Panel": "",
    "Terminal Panel": "",
    "Diagnostics": "",
    "Go": "",
    "Back": "",
    "Forward": "",
    "Command Palette...": "",
    "Go to File...": "",
    "Go to Symbol in Project": "",
    "Go to Symbol in Editor...": "",
    "Go to Line/Column...": "",
    "Go to Definition": "",
    "Go to Declaration": "",
    "Go to Type Definition": "",
    "Find All References": "",
    "Next Problem": "",
    "Previous Problem": "",
    "Run": "",
    "Spawn Task": "",
    "Start Debugger": "",
    "Edit tasks.json...": "",
    "Edit debug.json...": "",
    "Continue": "",
    "Step Over": "",
    "Step Into": "",
    "Step Out": "",
    "Toggle Breakpoint": "",
    "Edit Breakpoint": "",
    "Clear all Breakpoints": "",
    "Window": "",
    "Minimize": "",
    "Zoom": "",
    "Help": "",
    "View Release Notes": "",
    "View Telemetry": "",
    "View Dependency Licenses": "",
    "Show Welcome": "",
    "Give Feedback...": "",
    "Documentation": "",
    "https://zed.dev/docs": "",
    "Zed Twitter": "",
    "https://twitter.com/zeddotdev": "",
    "Join the Team": "",
    "https://zed.dev/jobs": ""
  },
  "zed/crates/zed/src/zed/mac_only_instance.rs": {
    "Zed Editor Dev Instance Running": "",
    "Zed Editor Nightly Instance Running": "",
    "Zed Editor Preview Instance Running": "",
    "Zed Editor Stable Instance Running": "",
    "Error binding to single instance port: {err}": "",
    "Backup handshake request failed, continuing without handshake": "",
    "Connected to single instance port but failed to read: {err}": "",
    "Got instance handshake": "",
    "Got wrong instance handshake value": ""
  },
  "zed/crates/zed/src/zed/open_listener.rs": {
    "zed-cli://": "",
    "zed-dock-action://": "",
    "file://": "",
    "zed://file": "",
    "zed://ssh": "",
    "ssh:/": "",
    "ssh://": "",
    "unhandled url: {}": "",
    "missing host in ssh url: {file}": "",
    "cannot open both local and ssh paths": "",
    "cannot open multiple ssh connections": "",
    "channel": "",
    "notes#": "",
    "notes": "",
    "invalid zed url: {request_path}": "",
    "no listener for open requests": "",
    "linux": "",
    "freebsd": "",
    "zed-{}.sock": "",
    "error connecting to cli": "",
    "error sending ipc handshake": "",
    "{e}": "",
    "failed to open a workspace": "",
    "error opening {path:?}: {err}": "",
    "error opening {paths_with_position:?}: {error}": "",
    "ssh://me@localhost:/": "",
    "localhost": "",
    "me": "",
    "/": "",
    "/root": "",
    "dir1": "",
    "file1.txt": "",
    "content1": "",
    "file2.txt": "",
    "content2": "",
    "/root/dir1": "",
    "/root/dir1/file1.txt": "",
    "Workspace should have two items": "",
    "/root/file5.txt": "",
    "/root/file6.txt": "",
    "/root/file7.txt": ""
  },
  "zed/crates/zed/src/zed/quick_action_bar.rs": {
    "empty quick action bar": "",
    "toggle buffer search": "",
    "Buffer Search": "",
    "toggle inline assistant": "",
    "Inline Assist": "",
    "toggle_code_actions_icon": "",
    "Code Actions": "",
    "No Code Actions Available": "",
    "editor-selections-dropdown": "",
    "toggle_editor_selections_icon": "",
    "Selection Controls": "",
    "Select All": "",
    "Select Next Occurrence": "",
    "Expand Selection": "",
    "Shrink Selection": "",
    "Add Cursor Above": "",
    "Add Cursor Below": "",
    "Go to Symbol": "",
    "Go to Line/Column": "",
    "Next Problem": "",
    "Previous Problem": "",
    "Next Hunk": "",
    "Previous Hunk": "",
    "Move Line Up": "",
    "Move Line Down": "",
    "Duplicate Selection": "",
    "editor-settings": "",
    "toggle_editor_settings_icon": "",
    "Editor Controls": "",
    "Inlay Hints": "",
    "Inline Values": "",
    "Diagnostics": "",
    "Inline Diagnostics": "",
    "Minimap": "",
    "Edit Predictions": "",
    "You can't toggle edit predictions for this file as it is within the excluded files list.": "",
    "Line Numbers": "",
    "Selection Menu": "",
    "Auto Signature Help": "",
    "Inline Git Blame": "",
    "Column Git Blame": "",
    "Vim Mode": "",
    "quick action bar": ""
  },
  "zed/crates/zed/src/zed/windows_only_instance.rs": {
    "{}-Instance-Mutex": "",
    "Unable to create instance mutex.": "",
    "\\\\\\\\.\\\\pipe\\\\{}-Named-Pipe": "",
    "Failed to create named pipe: {:?}": "",
    "Failed to read from named pipe": "",
    "zed-dock-action://{}": "",
    "Handshake before Zed spawn": "",
    "zed-cli://{server_name}": "",
    "zed://": "",
    "http://": "",
    "https://": "",
    "file://": "",
    "ssh://": "",
    "error parsing path argument: {}": "",
    "Handshake after Zed spawn": "",
    "{message}": ""
  },
  "zed/crates/zed/src/zed/quick_action_bar/markdown_preview.rs": {
    "click": "",
    "toggle-markdown-preview": "",
    "Preview Markdown": "",
    "{} to open in a split": ""
  },
  "zed/crates/zed/src/zed/quick_action_bar/repl_menu.rs": {
    "https://zed.dev/docs/repl": "",
    "repl-menu": "",
    "{}-{}": "",
    "menu": "",
    "kernel: {} ({})": "",
    "{}...": "",
    "Run Selection": "",
    "Run Line": "",
    "Interrupt": "",
    "Clear Outputs": "",
    "Shut Down Kernel": "",
    "Restart Kernel": "",
    "View Sessions": "",
    "Shut Down all Kernels": "",
    "dropdown": "",
    "REPL Menu": "",
    "toggle_repl_icon": "",
    "arrow-circle": "",
    "Start REPL for {}": "",
    "kernel-selector": "",
    "Select Kernel": "",
    "Setup Zed REPL for {}": "",
    "{}#installation": "",
    "Nothing running": "",
    "Restarting {}": "",
    "Run code on {} ({})": "",
    "Interrupt {} ({})": "",
    "{} is starting": "",
    "Error with kernel {}: {}": "",
    "{} is shutting down": ""
  },
  "zed/crates/zeta/src/zeta.rs": {
    "<|user_cursor_is_here|>": "",
    "<|start_of_file|>": "",
    "<|editable_region_start|>": "",
    "<|editable_region_end|>": "",
    "zed_predict_data_collection_choice": "",
    "{}": "",
    "InlineCompletion": "",
    "id": "",
    "path": "",
    "edits": "",
    "untitled": "",
    "Events:\\n{}\\nExcerpt:\\n{:?}": "",
    "Update Zed": "",
    "https://zed.dev/releases": "",
    "completion response: {}": "",
    "test-support": "",
    "a longggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg line\n            And maybe a short line\n\n            Then a few lines\n\n            and then another\n            ": "",
    "e7861db5-0cea-4761-b1c5-ad083ac53a80": "",
    "{EDITABLE_REGION_START_MARKER}\na longggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg line\n[here's an edit]\nAnd maybe a short line\nThen a few lines\nand then another\n{EDITABLE_REGION_END_MARKER}\n                        ": "",
    "077c556a-2c49-44e2-bbc6-dafc09032a5e": "",
    "{EDITABLE_REGION_START_MARKER}\na longggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg line\nAnd maybe a short line\n[and another edit]\nThen a few lines\nand then another\n{EDITABLE_REGION_END_MARKER}\n                        ": "",
    "df8c7b23-3d1d-4f99-a306-1f6264a41277": "",
    "{EDITABLE_REGION_START_MARKER}\na longggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg line\nAnd maybe a short line\n\nThen a few lines\n\nand then another\n{EDITABLE_REGION_END_MARKER}\n                        ": "",
    "c743958d-e4d8-44a8-aa5b-eb1e305c5f5c": "",
    "ff5cd7ab-ad06-4808-986e-d3391e7b8355": "",
    "{EDITABLE_REGION_START_MARKER}\na longggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg line\nAnd maybe a short line\nThen a few lines\n[a third completion]\nand then another\n{EDITABLE_REGION_END_MARKER}\n                        ": "",
    "83cafa55-cdba-4b27-8474-1865ea06be94": "",
    "{EDITABLE_REGION_START_MARKER}\na longggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg line\nAnd maybe a short line\nand then another\n[fourth completion example]\n{EDITABLE_REGION_END_MARKER}\n                        ": "",
    "d5bd3afd-8723-47c7-bd77-15a3a926867b": "",
    "{EDITABLE_REGION_START_MARKER}\na longggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg line\nAnd maybe a short line\nThen a few lines\nand then another\n[fifth and final completion]\n{EDITABLE_REGION_END_MARKER}\n                        ": "",
    "ZED_PREDICT_EDITS_URL": "",
    "/predict_edits/v2": "",
    "Content-Type": "",
    "application/json": "",
    "Authorization": "",
    "Bearer {}": "",
    "error predicting edits.\\nStatus: {:?}\\nBody: {}": "",
    "ZED_ACCEPT_PREDICTION_URL": "",
    "/predict_edits/accept": "",
    "error accepting edit prediction.\\nStatus: {:?}\\nBody: {}": "",
    "": "",
    "expected exactly one start marker, found {}": "",
    "expected exactly one end marker, found {}": "",
    "expected at most one start-of-file marker, found {}": "",
    "could not find newline": "",
    "\\n{EDITABLE_REGION_END_MARKER}": "",
    "could not find end marker": "",
    "Edit Prediction Rated": "",
    "true": "",
    "false": "",
    "unknown value in '{ZED_PREDICT_DATA_COLLECTION_CHOICE}'": "",
    "You must update to Zed version {minimum_version} or higher to continue using edit predictions.": "",
    "detected '{path:?}' as open source license": "",
    "didn't detect '{path:?}' as open source license": "",
    "didn't find a license file to check, assuming closed source": "",
    "```{}": "",
    " ": "",
    "{}{}": "",
    "```": "",
    "\\n\\n": "",
    "User renamed {:?} to {:?}\\n": "",
    "User edited {:?}:\\n```diff\\n{}\\n```": "",
    "zed-predict": "",
    "Zed's Edit Predictions": "",
    "edit prediction failed": "",
    "Lorem ipsum dolor": "",
    "REM": "",
    "R": "",
    "EM": "",
    "E": "",
    "M": "",
    "\n                fn main() {\n                    let word_1 = \\\"lorem\\\";\n                    let range = word.len()..word.len();\n                }\n            ": "",
    "\n                <|editable_region_start|>\n                fn main() {\n                    let word_1 = \\\"lorem\\\";\n                    let range = word_1.len()..word_1.len();\n                }\n\n                <|editable_region_end|>\n            ": "",
    "_1": "",
    "\n                fn main() {\n                    let story = \\\"the quick\\\"\n                }\n            ": "",
    "\n                <|editable_region_start|>\n                fn main() {\n                    let story = \\\"the quick brown fox jumps over the lazy dog\\\";\n                }\n\n                <|editable_region_end|>\n            ": "",
    " brown fox jumps over the lazy dog": "",
    ";": "",
    "lorem\\n": "",
    "\n            ```animals.js\n            <|start_of_file|>\n            <|editable_region_start|>\n            lorem\n            ipsum\n            <|editable_region_end|>\n            ```": "",
    "7e86480f-3536-4d2c-9334-8213e3445d45": "",
    "lorem\\nipsum": ""
  },
  "zed/crates/agent/src/profile_selector.rs": {}
}
